{"version":3,"sources":["src/database/realtime/WebSocketConnection.ts","database/realtime/WebSocketConnection.js"],"names":["setWebSocketImpl","WEBSOCKET_MAX_FRAME_SIZE","WEBSOCKET_KEEPALIVE_INTERVAL","WebSocketImpl","MozWebSocket","WebSocket","impl","WebSocketConnection","connId","repoInfo","transportSessionId","lastSessionId","keepaliveTimer","frames","totalFrames","bytesSent","bytesReceived","log_","stats_","getCollection","connURL","connectionURL_","urlParams","location","href","indexOf","connectionURL","prototype","open","onMessage","onDisconnect","_this","everConnected_","set","device","NODE_ADMIN","options","SDK_VERSION","process","platform","env","proxy","origin","mySock","e","error","message","data","onClosed_","onopen","onclose","onmessage","m","handleIncomingFrame","onerror","start","forceDisallow","forceDisallow_","isAvailable","isOldAndroid","navigator","userAgent","oldAndroidRegex","oldAndroidMatch","match","length","parseFloat","previouslyFailed","isInMemoryStorage","get","markConnectionHealthy","remove","appendFrame_","push","fullMess","join","jsonMess","handleNewFrameCount_","frameCount","extractFrameCount_","Number","isNaN","mess","incrementCounter","resetKeepAlive","remainingData","send","dataStr","dataSegs","sendString_","String","i","shutdown_","isClosed_","clearInterval","close","setInterval","Math","floor","str","setTimeout","bind","responsesRequiredToBeHealthy","healthyTimeout"],"mappings":"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","file":"WebSocketConnection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { RepoInfo } from '../core/RepoInfo';\n\ndeclare const MozWebSocket: any;\n\nimport firebase from '../../app';\nimport { assert } from '../../utils/assert';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM,\n  WEBSOCKET\n} from './Constants';\nimport { CONSTANTS as ENV_CONSTANTS } from '../../utils/constants';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '../../utils/json';\nimport { isNodeSdk } from '../../utils/environment';\nimport { Transport } from './Transport';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\n\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nexport function setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nexport class WebSocketConnection implements Transport {\n  keepaliveTimer: number | null = null;\n  frames: string[] | null = null;\n  totalFrames = 0;\n  bytesSent = 0;\n  bytesReceived = 0;\n  connURL: string;\n  onDisconnect: (a?: boolean) => void;\n  onMessage: (msg: Object) => void;\n  mySock: any | null;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_: boolean;\n  private isClosed_: boolean;\n\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  constructor(public connId: string, repoInfo: RepoInfo,\n              transportSessionId?: string, lastSessionId?: string) {\n    this.log_ = logWrapper(this.connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);\n  }\n\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  private static connectionURL_(repoInfo: RepoInfo, transportSessionId?: string, lastSessionId?: string): string {\n    const urlParams: { [k: string]: string } = {};\n    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n\n    if (!isNodeSdk() &&\n      typeof location !== 'undefined' &&\n      location.href &&\n      location.href.indexOf(FORGE_DOMAIN) !== -1) {\n      urlParams[REFERER_PARAM] = FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(WEBSOCKET, urlParams);\n  }\n\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n\n    this.log_('Websocket connecting to ' + this.connURL);\n\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (isNodeSdk()) {\n        const device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        const options: { [k: string]: object } = {\n          'headers': {\n            'User-Agent': `Firebase/${PROTOCOL_VERSION}/${firebase.SDK_VERSION}/${process.platform}/${device}`\n        }};\n\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        const env = process['env'];\n        const proxy = (this.connURL.indexOf('wss://') == 0)\n          ? (env['HTTPS_PROXY'] || env['https_proxy'])\n          : (env['HTTP_PROXY'] || env['http_proxy']);\n\n        if (proxy) {\n          options['proxy'] = {origin: proxy};\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = () => {\n      this.log_('Websocket connected.');\n      this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = () => {\n      this.log_('Websocket connection was disconnected.');\n      this.mySock = null;\n      this.onClosed_();\n    };\n\n    this.mySock.onmessage = (m: object) => {\n      this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = (e: any) => {\n      this.log_('WebSocket error.  Closing connection.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n    };\n  }\n\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  start() {};\n\n  static forceDisallow_: Boolean;\n\n  static forceDisallow() {\n    WebSocketConnection.forceDisallow_ = true;\n  }\n\n  static isAvailable(): boolean {\n    let isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n  }\n\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  static responsesRequiredToBeHealthy = 2;\n\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  static healthyTimeout = 30000;\n\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  static previouslyFailed(): boolean {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return PersistentStorage.isInMemoryStorage ||\n      PersistentStorage.get('previous_websocket_failure') === true;\n  }\n\n  markConnectionHealthy() {\n    PersistentStorage.remove('previous_websocket_failure');\n  }\n\n  private appendFrame_(data: string) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      const fullMess = this.frames.join('');\n      this.frames = null;\n      const jsonMess = jsonEval(fullMess);\n\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  }\n\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  private handleNewFrameCount_(frameCount: number) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  }\n\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  private extractFrameCount_(data: string): string | null {\n    assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      const frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  }\n\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  handleIncomingFrame(mess: { [k: string]: any }) {\n    if (this.mySock === null)\n      return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    const data = mess['data'] as string;\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      const remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  send(data: Object) {\n\n    this.resetKeepAlive();\n\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n\n    //Send the actual data in segments.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  }\n\n  private shutdown_() {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  }\n\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  resetKeepAlive() {\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(() => {\n      //If there has been no websocket activity for a while, send a no-op\n      if (this.mySock) {\n        this.sendString_('0');\n      }\n      this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)) as any;\n  }\n\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  private sendString_(str: string) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  }\n}\n\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport firebase from '../../app';\nimport { assert } from '../../utils/assert';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport { FORGE_DOMAIN, FORGE_REF, LAST_SESSION_PARAM, PROTOCOL_VERSION, REFERER_PARAM, TRANSPORT_SESSION_PARAM, VERSION_PARAM, WEBSOCKET } from './Constants';\nimport { CONSTANTS as ENV_CONSTANTS } from '../../utils/constants';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '../../utils/json';\nimport { isNodeSdk } from '../../utils/environment';\nvar WEBSOCKET_MAX_FRAME_SIZE = 16384;\nvar WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nvar WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n    WebSocketImpl = MozWebSocket;\n}\nelse if (typeof WebSocket !== 'undefined') {\n    WebSocketImpl = WebSocket;\n}\nexport function setWebSocketImpl(impl) {\n    WebSocketImpl = impl;\n}\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nvar WebSocketConnection = (function () {\n    /**\n     * @param {string} connId identifier for this transport\n     * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n     *                                         session\n     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n     */\n    function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n        this.connId = connId;\n        this.keepaliveTimer = null;\n        this.frames = null;\n        this.totalFrames = 0;\n        this.bytesSent = 0;\n        this.bytesReceived = 0;\n        this.log_ = logWrapper(this.connId);\n        this.stats_ = StatsManager.getCollection(repoInfo);\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);\n    }\n    /**\n     * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n     *                                         session\n     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n     * @return {string} connection url\n     * @private\n     */\n    WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {\n        var urlParams = {};\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n        if (!isNodeSdk() &&\n            typeof location !== 'undefined' &&\n            location.href &&\n            location.href.indexOf(FORGE_DOMAIN) !== -1) {\n            urlParams[REFERER_PARAM] = FORGE_REF;\n        }\n        if (transportSessionId) {\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n        }\n        if (lastSessionId) {\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\n        }\n        return repoInfo.connectionURL(WEBSOCKET, urlParams);\n    };\n    /**\n     *\n     * @param onMessage Callback when messages arrive\n     * @param onDisconnect Callback with connection lost.\n     */\n    WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {\n        var _this = this;\n        this.onDisconnect = onDisconnect;\n        this.onMessage = onMessage;\n        this.log_('Websocket connecting to ' + this.connURL);\n        this.everConnected_ = false;\n        // Assume failure until proven otherwise.\n        PersistentStorage.set('previous_websocket_failure', true);\n        try {\n            if (isNodeSdk()) {\n                var device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n                var options = {\n                    'headers': {\n                        'User-Agent': \"Firebase/\" + PROTOCOL_VERSION + \"/\" + firebase.SDK_VERSION + \"/\" + process.platform + \"/\" + device\n                    }\n                };\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n                var env = process['env'];\n                var proxy = (this.connURL.indexOf('wss://') == 0)\n                    ? (env['HTTPS_PROXY'] || env['https_proxy'])\n                    : (env['HTTP_PROXY'] || env['http_proxy']);\n                if (proxy) {\n                    options['proxy'] = { origin: proxy };\n                }\n                this.mySock = new WebSocketImpl(this.connURL, [], options);\n            }\n            else {\n                this.mySock = new WebSocketImpl(this.connURL);\n            }\n        }\n        catch (e) {\n            this.log_('Error instantiating WebSocket.');\n            var error = e.message || e.data;\n            if (error) {\n                this.log_(error);\n            }\n            this.onClosed_();\n            return;\n        }\n        this.mySock.onopen = function () {\n            _this.log_('Websocket connected.');\n            _this.everConnected_ = true;\n        };\n        this.mySock.onclose = function () {\n            _this.log_('Websocket connection was disconnected.');\n            _this.mySock = null;\n            _this.onClosed_();\n        };\n        this.mySock.onmessage = function (m) {\n            _this.handleIncomingFrame(m);\n        };\n        this.mySock.onerror = function (e) {\n            _this.log_('WebSocket error.  Closing connection.');\n            var error = e.message || e.data;\n            if (error) {\n                _this.log_(error);\n            }\n            _this.onClosed_();\n        };\n    };\n    /**\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n     */\n    WebSocketConnection.prototype.start = function () { };\n    ;\n    WebSocketConnection.forceDisallow = function () {\n        WebSocketConnection.forceDisallow_ = true;\n    };\n    WebSocketConnection.isAvailable = function () {\n        var isOldAndroid = false;\n        if (typeof navigator !== 'undefined' && navigator.userAgent) {\n            var oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n                    isOldAndroid = true;\n                }\n            }\n        }\n        return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n    };\n    /**\n     * Returns true if we previously failed to connect with this transport.\n     * @return {boolean}\n     */\n    WebSocketConnection.previouslyFailed = function () {\n        // If our persistent storage is actually only in-memory storage,\n        // we default to assuming that it previously failed to be safe.\n        return PersistentStorage.isInMemoryStorage ||\n            PersistentStorage.get('previous_websocket_failure') === true;\n    };\n    WebSocketConnection.prototype.markConnectionHealthy = function () {\n        PersistentStorage.remove('previous_websocket_failure');\n    };\n    WebSocketConnection.prototype.appendFrame_ = function (data) {\n        this.frames.push(data);\n        if (this.frames.length == this.totalFrames) {\n            var fullMess = this.frames.join('');\n            this.frames = null;\n            var jsonMess = jsonEval(fullMess);\n            //handle the message\n            this.onMessage(jsonMess);\n        }\n    };\n    /**\n     * @param {number} frameCount The number of frames we are expecting from the server\n     * @private\n     */\n    WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {\n        this.totalFrames = frameCount;\n        this.frames = [];\n    };\n    /**\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n     * @param {!String} data\n     * @return {?String} Any remaining data to be process, or null if there is none\n     * @private\n     */\n    WebSocketConnection.prototype.extractFrameCount_ = function (data) {\n        assert(this.frames === null, 'We already have a frame buffer');\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n        if (data.length <= 6) {\n            var frameCount = Number(data);\n            if (!isNaN(frameCount)) {\n                this.handleNewFrameCount_(frameCount);\n                return null;\n            }\n        }\n        this.handleNewFrameCount_(1);\n        return data;\n    };\n    /**\n     * Process a websocket frame that has arrived from the server.\n     * @param mess The frame data\n     */\n    WebSocketConnection.prototype.handleIncomingFrame = function (mess) {\n        if (this.mySock === null)\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n        var data = mess['data'];\n        this.bytesReceived += data.length;\n        this.stats_.incrementCounter('bytes_received', data.length);\n        this.resetKeepAlive();\n        if (this.frames !== null) {\n            // we're buffering\n            this.appendFrame_(data);\n        }\n        else {\n            // try to parse out a frame count, otherwise, assume 1 and process it\n            var remainingData = this.extractFrameCount_(data);\n            if (remainingData !== null) {\n                this.appendFrame_(remainingData);\n            }\n        }\n    };\n    /**\n     * Send a message to the server\n     * @param {Object} data The JSON object to transmit\n     */\n    WebSocketConnection.prototype.send = function (data) {\n        this.resetKeepAlive();\n        var dataStr = stringify(data);\n        this.bytesSent += dataStr.length;\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\n        //up into multiple pieces if it doesn't fit in one request.\n        var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n        //Send the length header\n        if (dataSegs.length > 1) {\n            this.sendString_(String(dataSegs.length));\n        }\n        //Send the actual data in segments.\n        for (var i = 0; i < dataSegs.length; i++) {\n            this.sendString_(dataSegs[i]);\n        }\n    };\n    WebSocketConnection.prototype.shutdown_ = function () {\n        this.isClosed_ = true;\n        if (this.keepaliveTimer) {\n            clearInterval(this.keepaliveTimer);\n            this.keepaliveTimer = null;\n        }\n        if (this.mySock) {\n            this.mySock.close();\n            this.mySock = null;\n        }\n    };\n    WebSocketConnection.prototype.onClosed_ = function () {\n        if (!this.isClosed_) {\n            this.log_('WebSocket is closing itself');\n            this.shutdown_();\n            // since this is an internal close, trigger the close listener\n            if (this.onDisconnect) {\n                this.onDisconnect(this.everConnected_);\n                this.onDisconnect = null;\n            }\n        }\n    };\n    /**\n     * External-facing close handler.\n     * Close the websocket and kill the connection.\n     */\n    WebSocketConnection.prototype.close = function () {\n        if (!this.isClosed_) {\n            this.log_('WebSocket is being closed');\n            this.shutdown_();\n        }\n    };\n    /**\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n     * the last activity.\n     */\n    WebSocketConnection.prototype.resetKeepAlive = function () {\n        var _this = this;\n        clearInterval(this.keepaliveTimer);\n        this.keepaliveTimer = setInterval(function () {\n            //If there has been no websocket activity for a while, send a no-op\n            if (_this.mySock) {\n                _this.sendString_('0');\n            }\n            _this.resetKeepAlive();\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n    };\n    /**\n     * Send a string over the websocket.\n     *\n     * @param {string} str String to send.\n     * @private\n     */\n    WebSocketConnection.prototype.sendString_ = function (str) {\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n        // calls for some unknown reason.  We treat these as an error and disconnect.\n        // See https://app.asana.com/0/58926111402292/68021340250410\n        try {\n            this.mySock.send(str);\n        }\n        catch (e) {\n            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\n            setTimeout(this.onClosed_.bind(this), 0);\n        }\n    };\n    return WebSocketConnection;\n}());\nexport { WebSocketConnection };\n/**\n * Number of response before we consider the connection \"healthy.\"\n * @type {number}\n */\nWebSocketConnection.responsesRequiredToBeHealthy = 2;\n/**\n * Time to wait for the connection te become healthy before giving up.\n * @type {number}\n */\nWebSocketConnection.healthyTimeout = 30000;\n\n\n"]}