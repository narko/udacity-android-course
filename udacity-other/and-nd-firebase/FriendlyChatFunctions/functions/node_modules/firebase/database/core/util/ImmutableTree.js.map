{"version":3,"sources":["database/src/database/core/util/ImmutableTree.ts","database/core/util/ImmutableTree.js"],"names":["emptyChildrenSingleton","EmptyChildren","ImmutableTree","value","children","fromObject","obj","tree","Empty","childPath","childSnap","set","prototype","isEmpty","findRootMostMatchingPathAndValue","relativePath","predicate","path","front","getFront","child","get","childExistingPathAndValue","popFront","fullPath","findRootMostValueAndPath","subtree","childTree","toSet","newChild","newChildren","insert","remove","setTree","newTree","fold","fn","fold_","pathSoFar","accum","inorderTraversal","childKey","findOnPath","f","findOnPath_","pathToFollow","result","nextChild","foreachOnPath","foreachOnPath_","currentRelativePath","foreach","foreach_","childName","foreachChild"],"mappings":"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","file":"ImmutableTree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare } from './util';\nimport { forEach } from '../../../utils/obj';\n\nlet emptyChildrenSingleton: SortedMap<string, ImmutableTree<null>>;\n\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nconst EmptyChildren = (): SortedMap<string, ImmutableTree<null>> => {\n  if (!emptyChildrenSingleton) {\n    emptyChildrenSingleton = new SortedMap<string, ImmutableTree<null>>(stringCompare);\n  }\n  return emptyChildrenSingleton;\n};\n\n/**\n * A tree with immutable elements.\n */\nexport class ImmutableTree<T> {\n  static Empty = new ImmutableTree<any>(null);\n\n  /**\n   * @template T\n   * @param {!Object.<string, !T>} obj\n   * @return {!ImmutableTree.<!T>}\n   */\n  static fromObject<T>(obj: { [k: string]: T }): ImmutableTree<T> {\n    let tree: ImmutableTree<T> = ImmutableTree.Empty;\n    forEach(obj, (childPath: string, childSnap: T) => {\n      tree = tree.set(new Path(childPath), childSnap);\n    });\n    return tree;\n  }\n\n  /**\n   * @template T\n   * @param {?T} value\n   * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n   */\n  constructor(public readonly value: T | null,\n              public readonly children: SortedMap<string, ImmutableTree<T>> = EmptyChildren()) {\n  }\n\n  /**\n   * True if the value is empty and there are no children\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return this.value === null && this.children.isEmpty();\n  }\n\n  /**\n   * Given a path and predicate, return the first node and the path to that node\n   * where the predicate returns true.\n   *\n   * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n   * on the way back out, it may be better to pass down a pathSoFar obj.\n   *\n   * @param {!Path} relativePath The remainder of the path\n   * @param {function(T):boolean} predicate The predicate to satisfy to return a\n   *   node\n   * @return {?{path:!Path, value:!T}}\n   */\n  findRootMostMatchingPathAndValue(relativePath: Path,\n                                   predicate: (a: T) => boolean): { path: Path, value: T } | null {\n    if (this.value != null && predicate(this.value)) {\n      return {path: Path.Empty, value: this.value};\n    } else {\n      if (relativePath.isEmpty()) {\n        return null;\n      } else {\n        const front = relativePath.getFront();\n        const child = this.children.get(front);\n        if (child !== null) {\n          const childExistingPathAndValue =\n            child.findRootMostMatchingPathAndValue(relativePath.popFront(),\n              predicate);\n          if (childExistingPathAndValue != null) {\n            const fullPath = new Path(front).child(childExistingPathAndValue.path);\n            return {path: fullPath, value: childExistingPathAndValue.value};\n          } else {\n            return null;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find, if it exists, the shortest subpath of the given path that points a defined\n   * value in the tree\n   * @param {!Path} relativePath\n   * @return {?{path: !Path, value: !T}}\n   */\n  findRootMostValueAndPath(relativePath: Path): { path: Path, value: T } | null {\n    return this.findRootMostMatchingPathAndValue(relativePath, () => true);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @return {!ImmutableTree.<T>} The subtree at the given path\n   */\n  subtree(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return this;\n    } else {\n      const front = relativePath.getFront();\n      const childTree = this.children.get(front);\n      if (childTree !== null) {\n        return childTree.subtree(relativePath.popFront());\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Sets a value at the specified path.\n   *\n   * @param {!Path} relativePath Path to set value at.\n   * @param {?T} toSet Value to set.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  set(relativePath: Path, toSet: T | null): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return new ImmutableTree(toSet, this.children);\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.set(relativePath.popFront(), toSet);\n      const newChildren = this.children.insert(front, newChild);\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Removes the value at the specified path.\n   *\n   * @param {!Path} relativePath Path to value to remove.\n   * @return {!ImmutableTree.<T>} Resulting tree.\n   */\n  remove(relativePath: Path): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      if (this.children.isEmpty()) {\n        return ImmutableTree.Empty;\n      } else {\n        return new ImmutableTree(null, this.children);\n      }\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        const newChild = child.remove(relativePath.popFront());\n        let newChildren;\n        if (newChild.isEmpty()) {\n          newChildren = this.children.remove(front);\n        } else {\n          newChildren = this.children.insert(front, newChild);\n        }\n        if (this.value === null && newChildren.isEmpty()) {\n          return ImmutableTree.Empty;\n        } else {\n          return new ImmutableTree(this.value, newChildren);\n        }\n      } else {\n        return this;\n      }\n    }\n  }\n\n  /**\n   * Gets a value from the tree.\n   *\n   * @param {!Path} relativePath Path to get value for.\n   * @return {?T} Value at path, or null.\n   */\n  get(relativePath: Path): T | null {\n    if (relativePath.isEmpty()) {\n      return this.value;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front);\n      if (child) {\n        return child.get(relativePath.popFront());\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Replace the subtree at the specified path with the given new tree.\n   *\n   * @param {!Path} relativePath Path to replace subtree for.\n   * @param {!ImmutableTree} newTree New tree.\n   * @return {!ImmutableTree} Resulting tree.\n   */\n  setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T> {\n    if (relativePath.isEmpty()) {\n      return newTree;\n    } else {\n      const front = relativePath.getFront();\n      const child = this.children.get(front) || ImmutableTree.Empty;\n      const newChild = child.setTree(relativePath.popFront(), newTree);\n      let newChildren;\n      if (newChild.isEmpty()) {\n        newChildren = this.children.remove(front);\n      } else {\n        newChildren = this.children.insert(front, newChild);\n      }\n      return new ImmutableTree(this.value, newChildren);\n    }\n  }\n\n  /**\n   * Performs a depth first fold on this tree. Transforms a tree into a single\n   * value, given a function that operates on the path to a node, an optional\n   * current value, and a map of child names to folded subtrees\n   * @template V\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   */\n  fold<V>(fn: (path: Path, value: T, children: { [k: string]: V }) => V): V {\n    return this.fold_(Path.Empty, fn);\n  }\n\n  /**\n   * Recursive helper for public-facing fold() method\n   * @template V\n   * @param {!Path} pathSoFar\n   * @param {function(Path, ?T, Object.<string, V>):V} fn\n   * @return {V}\n   * @private\n   */\n  private fold_<V>(pathSoFar: Path, fn: (path: Path, value: T | null, children: { [k: string]: V }) => V): V {\n    const accum: {[k: string]: V} = {};\n    this.children.inorderTraversal(function (childKey: string, childTree: ImmutableTree<T>) {\n      accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n    });\n    return fn(pathSoFar, this.value, accum);\n  }\n\n  /**\n   * Find the first matching value on the given path. Return the result of applying f to it.\n   * @template V\n   * @param {!Path} path\n   * @param {!function(!Path, !T):?V} f\n   * @return {?V}\n   */\n  findOnPath<V>(path: Path, f: (path: Path, value: T) => (V | null)): V | null {\n    return this.findOnPath_(path, Path.Empty, f);\n  }\n\n  private findOnPath_<V>(pathToFollow: Path, pathSoFar: Path, f: (path: Path, value: T) => (V | null)): V | null {\n    const result = this.value ? f(pathSoFar, this.value) : false;\n    if (result) {\n      return result;\n    } else {\n      if (pathToFollow.isEmpty()) {\n        return null;\n      } else {\n        const front = pathToFollow.getFront()!;\n        const nextChild = this.children.get(front);\n        if (nextChild) {\n          return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\n        } else {\n          return null;\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {!Path} path\n   * @param {!function(!Path, !T)} f\n   * @returns {!ImmutableTree.<T>}\n   */\n  foreachOnPath(path: Path, f: (path: Path, value: T) => void): ImmutableTree<T> {\n    return this.foreachOnPath_(path, Path.Empty, f);\n  }\n\n  private foreachOnPath_(pathToFollow: Path, currentRelativePath: Path,\n                         f: (path: Path, value: T) => void): ImmutableTree<T> {\n    if (pathToFollow.isEmpty()) {\n      return this;\n    } else {\n      if (this.value) {\n        f(currentRelativePath, this.value);\n      }\n      const front = pathToFollow.getFront();\n      const nextChild = this.children.get(front);\n      if (nextChild) {\n        return nextChild.foreachOnPath_(pathToFollow.popFront(),\n          currentRelativePath.child(front), f);\n      } else {\n        return ImmutableTree.Empty;\n      }\n    }\n  }\n\n  /**\n   * Calls the given function for each node in the tree that has a value.\n   *\n   * @param {function(!Path, !T)} f A function to be called with\n   *   the path from the root of the tree to a node, and the value at that node.\n   *   Called in depth-first order.\n   */\n  foreach(f: (path: Path, value: T) => void) {\n    this.foreach_(Path.Empty, f);\n  }\n\n  private foreach_(currentRelativePath: Path, f: (path: Path, value: T) => void) {\n    this.children.inorderTraversal(function (childName, childTree) {\n      childTree.foreach_(currentRelativePath.child(childName), f);\n    });\n    if (this.value) {\n      f(currentRelativePath, this.value);\n    }\n  }\n\n  /**\n   *\n   * @param {function(string, !T)} f\n   */\n  foreachChild(f: (name: string, value: T) => void) {\n    this.children.inorderTraversal((childName: string, childTree: ImmutableTree<T>) => {\n      if (childTree.value) {\n        f(childName, childTree.value);\n      }\n    });\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { SortedMap } from './SortedMap';\nimport { Path } from './Path';\nimport { stringCompare } from './util';\nimport { forEach } from '../../../utils/obj';\nvar emptyChildrenSingleton;\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nvar EmptyChildren = function () {\n    if (!emptyChildrenSingleton) {\n        emptyChildrenSingleton = new SortedMap(stringCompare);\n    }\n    return emptyChildrenSingleton;\n};\n/**\n * A tree with immutable elements.\n */\nvar ImmutableTree = (function () {\n    /**\n     * @template T\n     * @param {?T} value\n     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n     */\n    function ImmutableTree(value, children) {\n        if (children === void 0) { children = EmptyChildren(); }\n        this.value = value;\n        this.children = children;\n    }\n    /**\n     * @template T\n     * @param {!Object.<string, !T>} obj\n     * @return {!ImmutableTree.<!T>}\n     */\n    ImmutableTree.fromObject = function (obj) {\n        var tree = ImmutableTree.Empty;\n        forEach(obj, function (childPath, childSnap) {\n            tree = tree.set(new Path(childPath), childSnap);\n        });\n        return tree;\n    };\n    /**\n     * True if the value is empty and there are no children\n     * @return {boolean}\n     */\n    ImmutableTree.prototype.isEmpty = function () {\n        return this.value === null && this.children.isEmpty();\n    };\n    /**\n     * Given a path and predicate, return the first node and the path to that node\n     * where the predicate returns true.\n     *\n     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n     * on the way back out, it may be better to pass down a pathSoFar obj.\n     *\n     * @param {!Path} relativePath The remainder of the path\n     * @param {function(T):boolean} predicate The predicate to satisfy to return a\n     *   node\n     * @return {?{path:!Path, value:!T}}\n     */\n    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {\n        if (this.value != null && predicate(this.value)) {\n            return { path: Path.Empty, value: this.value };\n        }\n        else {\n            if (relativePath.isEmpty()) {\n                return null;\n            }\n            else {\n                var front = relativePath.getFront();\n                var child = this.children.get(front);\n                if (child !== null) {\n                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);\n                    if (childExistingPathAndValue != null) {\n                        var fullPath = new Path(front).child(childExistingPathAndValue.path);\n                        return { path: fullPath, value: childExistingPathAndValue.value };\n                    }\n                    else {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    };\n    /**\n     * Find, if it exists, the shortest subpath of the given path that points a defined\n     * value in the tree\n     * @param {!Path} relativePath\n     * @return {?{path: !Path, value: !T}}\n     */\n    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {\n        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });\n    };\n    /**\n     * @param {!Path} relativePath\n     * @return {!ImmutableTree.<T>} The subtree at the given path\n     */\n    ImmutableTree.prototype.subtree = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            return this;\n        }\n        else {\n            var front = relativePath.getFront();\n            var childTree = this.children.get(front);\n            if (childTree !== null) {\n                return childTree.subtree(relativePath.popFront());\n            }\n            else {\n                return ImmutableTree.Empty;\n            }\n        }\n    };\n    /**\n     * Sets a value at the specified path.\n     *\n     * @param {!Path} relativePath Path to set value at.\n     * @param {?T} toSet Value to set.\n     * @return {!ImmutableTree.<T>} Resulting tree.\n     */\n    ImmutableTree.prototype.set = function (relativePath, toSet) {\n        if (relativePath.isEmpty()) {\n            return new ImmutableTree(toSet, this.children);\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front) || ImmutableTree.Empty;\n            var newChild = child.set(relativePath.popFront(), toSet);\n            var newChildren = this.children.insert(front, newChild);\n            return new ImmutableTree(this.value, newChildren);\n        }\n    };\n    /**\n     * Removes the value at the specified path.\n     *\n     * @param {!Path} relativePath Path to value to remove.\n     * @return {!ImmutableTree.<T>} Resulting tree.\n     */\n    ImmutableTree.prototype.remove = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            if (this.children.isEmpty()) {\n                return ImmutableTree.Empty;\n            }\n            else {\n                return new ImmutableTree(null, this.children);\n            }\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front);\n            if (child) {\n                var newChild = child.remove(relativePath.popFront());\n                var newChildren = void 0;\n                if (newChild.isEmpty()) {\n                    newChildren = this.children.remove(front);\n                }\n                else {\n                    newChildren = this.children.insert(front, newChild);\n                }\n                if (this.value === null && newChildren.isEmpty()) {\n                    return ImmutableTree.Empty;\n                }\n                else {\n                    return new ImmutableTree(this.value, newChildren);\n                }\n            }\n            else {\n                return this;\n            }\n        }\n    };\n    /**\n     * Gets a value from the tree.\n     *\n     * @param {!Path} relativePath Path to get value for.\n     * @return {?T} Value at path, or null.\n     */\n    ImmutableTree.prototype.get = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            return this.value;\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front);\n            if (child) {\n                return child.get(relativePath.popFront());\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Replace the subtree at the specified path with the given new tree.\n     *\n     * @param {!Path} relativePath Path to replace subtree for.\n     * @param {!ImmutableTree} newTree New tree.\n     * @return {!ImmutableTree} Resulting tree.\n     */\n    ImmutableTree.prototype.setTree = function (relativePath, newTree) {\n        if (relativePath.isEmpty()) {\n            return newTree;\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front) || ImmutableTree.Empty;\n            var newChild = child.setTree(relativePath.popFront(), newTree);\n            var newChildren = void 0;\n            if (newChild.isEmpty()) {\n                newChildren = this.children.remove(front);\n            }\n            else {\n                newChildren = this.children.insert(front, newChild);\n            }\n            return new ImmutableTree(this.value, newChildren);\n        }\n    };\n    /**\n     * Performs a depth first fold on this tree. Transforms a tree into a single\n     * value, given a function that operates on the path to a node, an optional\n     * current value, and a map of child names to folded subtrees\n     * @template V\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\n     * @return {V}\n     */\n    ImmutableTree.prototype.fold = function (fn) {\n        return this.fold_(Path.Empty, fn);\n    };\n    /**\n     * Recursive helper for public-facing fold() method\n     * @template V\n     * @param {!Path} pathSoFar\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\n     * @return {V}\n     * @private\n     */\n    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {\n        var accum = {};\n        this.children.inorderTraversal(function (childKey, childTree) {\n            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n        });\n        return fn(pathSoFar, this.value, accum);\n    };\n    /**\n     * Find the first matching value on the given path. Return the result of applying f to it.\n     * @template V\n     * @param {!Path} path\n     * @param {!function(!Path, !T):?V} f\n     * @return {?V}\n     */\n    ImmutableTree.prototype.findOnPath = function (path, f) {\n        return this.findOnPath_(path, Path.Empty, f);\n    };\n    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {\n        var result = this.value ? f(pathSoFar, this.value) : false;\n        if (result) {\n            return result;\n        }\n        else {\n            if (pathToFollow.isEmpty()) {\n                return null;\n            }\n            else {\n                var front = pathToFollow.getFront();\n                var nextChild = this.children.get(front);\n                if (nextChild) {\n                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    };\n    /**\n     *\n     * @param {!Path} path\n     * @param {!function(!Path, !T)} f\n     * @returns {!ImmutableTree.<T>}\n     */\n    ImmutableTree.prototype.foreachOnPath = function (path, f) {\n        return this.foreachOnPath_(path, Path.Empty, f);\n    };\n    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {\n        if (pathToFollow.isEmpty()) {\n            return this;\n        }\n        else {\n            if (this.value) {\n                f(currentRelativePath, this.value);\n            }\n            var front = pathToFollow.getFront();\n            var nextChild = this.children.get(front);\n            if (nextChild) {\n                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);\n            }\n            else {\n                return ImmutableTree.Empty;\n            }\n        }\n    };\n    /**\n     * Calls the given function for each node in the tree that has a value.\n     *\n     * @param {function(!Path, !T)} f A function to be called with\n     *   the path from the root of the tree to a node, and the value at that node.\n     *   Called in depth-first order.\n     */\n    ImmutableTree.prototype.foreach = function (f) {\n        this.foreach_(Path.Empty, f);\n    };\n    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {\n        this.children.inorderTraversal(function (childName, childTree) {\n            childTree.foreach_(currentRelativePath.child(childName), f);\n        });\n        if (this.value) {\n            f(currentRelativePath, this.value);\n        }\n    };\n    /**\n     *\n     * @param {function(string, !T)} f\n     */\n    ImmutableTree.prototype.foreachChild = function (f) {\n        this.children.inorderTraversal(function (childName, childTree) {\n            if (childTree.value) {\n                f(childName, childTree.value);\n            }\n        });\n    };\n    return ImmutableTree;\n}());\nexport { ImmutableTree };\nImmutableTree.Empty = new ImmutableTree(null);\n\n\n"]}