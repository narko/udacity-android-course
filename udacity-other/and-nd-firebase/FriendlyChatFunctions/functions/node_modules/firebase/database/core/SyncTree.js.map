{"version":3,"sources":["src/database/core/SyncTree.ts","database/core/SyncTree.js"],"names":["SyncTree","listenProvider_","syncPointTree_","Empty","pendingWriteTree_","tagToQueryMap_","queryToTagMap_","prototype","applyUserOverwrite","path","newData","writeId","visible","addOverwrite","applyOperationToSyncPoints_","User","applyUserMerge","changedChildren","addMerge","changeTree","fromObject","ackUserWrite","revert","write","getWrite","needToReevaluate","removeWrite","affectedTree_1","snap","set","children","pathString","node","applyServerOverwrite","Server","applyServerMerge","applyListenComplete","applyTaggedQueryOverwrite","tag","queryKey","queryKeyForTag_","r","parseQueryKey_","queryPath","queryId","relativePath","op","forServerTaggedQuery","applyTaggedOperation_","applyTaggedQueryMerge","applyTaggedListenComplete","addEventRegistration","query","eventRegistration","serverCache","foundAncestorDefaultView","foreachOnPath","pathToSyncPoint","sp","getCompleteServerCache","hasCompleteView","syncPoint","get","serverCacheComplete","EMPTY_NODE","subtree","foreachChild","childName","childSyncPoint","completeCache","updateImmediateChild","viewAlreadyExists","viewExistsForQuery","getQueryParams","loadsAllData","makeQueryKey_","getNextQueryTag_","writesCache","childWrites","events","view","viewForQuery","concat","setupListener_","removeEventRegistration","cancelError","_this","maybeSyncPoint","cancelEvents","queryIdentifier","removedAndEvents","isEmpty","remove","removed","removingDefault","findIndex","covered","findOnPath","parentSyncPoint","newViews","collectDistinctViewsForSubTree_","i","length","newQuery","getQuery","listener","createListenerForView_","startListening","queryForListening_","tagForQuery_","hashFn","onComplete","defaultTag","stopListening","forEach","queryToRemove","tagToRemove","removeTags_","calcCompleteEventCache","writeIdsToExclude","includeHiddenSets","writeTree","pathSoFar","fold","maybeChildSyncPoint","childMap","completeView","getCompleteView","views_1","getQueryViews","key","childViews","queries","j","removedQuery","removedQueryKey","removedQueryTag","isDefault","getRef","value","queriesToStop","queries_1","map","childQueries","queryToStop","cache","getServerCache","hash","status","error","toString","splitIndex","indexOf","substr","nextQueryTag_","operation","applyOperation","applyOperationHelper_","syncPointTree","applyOperationDescendantsHelper_","getFront","childOperation","operationForChild","childTree","childServerCache","getImmediateChild","childWritesCache","child","inorderTraversal"],"mappings":"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","file":"SyncTree.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { errorForServerCode } from './util/util';\nimport { AckUserWrite } from './operation/AckUserWrite';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { forEach, safeGet } from '../../utils/obj';\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { ListenComplete } from './operation/ListenComplete';\nimport { Merge } from './operation/Merge';\nimport { Operation, OperationSource } from './operation/Operation';\nimport { Overwrite } from './operation/Overwrite';\nimport { Path } from './util/Path';\nimport { SyncPoint } from './SyncPoint';\nimport { WriteTree, WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { Node } from './snap/Node';\nimport { Event } from './view/Event';\nimport { EventRegistration } from './view/EventRegistration';\nimport { View } from './view/View';\n\n/**\n * @typedef {{\n *   startListening: function(\n *     !Query,\n *     ?number,\n *     function():string,\n *     function(!string, *):!Array.<!Event>\n *   ):!Array.<!Event>,\n *\n *   stopListening: function(!Query, ?number)\n * }}\n */\nexport interface ListenProvider {\n  startListening(query: Query,\n                 tag: number | null,\n                 hashFn: () => string,\n                 onComplete: (a: string, b?: any) => Event[]): Event[];\n\n  stopListening(a: Query, b: number | null): void;\n}\n\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nexport class SyncTree {\n  /**\n   * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n   * @type {!ImmutableTree.<!SyncPoint>}\n   * @private\n   */\n  private syncPointTree_: ImmutableTree<SyncPoint> = ImmutableTree.Empty;\n\n  /**\n   * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n   * @type {!WriteTree}\n   * @private\n   */\n  private pendingWriteTree_ = new WriteTree();\n\n  private tagToQueryMap_: { [k: string]: string } = {};\n  private queryToTagMap_: { [k: string]: number } = {};\n\n  /**\n   * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n   *   to server data.\n   */\n  constructor(private listenProvider_: ListenProvider) {\n  }\n\n  /**\n   * Apply the data changes for a user-generated set() or transaction() call.\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @param {number} writeId\n   * @param {boolean=} visible\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserOverwrite(path: Path, newData: Node, writeId: number, visible?: boolean): Event[] {\n    // Record pending write.\n    this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n\n    if (!visible) {\n      return [];\n    } else {\n      return this.applyOperationToSyncPoints_(\n        new Overwrite(OperationSource.User, path, newData));\n    }\n  }\n\n  /**\n   * Apply the data from a user-generated update() call\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserMerge(path: Path, changedChildren: { [k: string]: Node }, writeId: number): Event[] {\n    // Record pending merge.\n    this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.User, path, changeTree));\n  }\n\n  /**\n   * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n   *\n   * @param {!number} writeId\n   * @param {boolean=} revert True if the given write failed and needs to be reverted\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  ackUserWrite(writeId: number, revert: boolean = false) {\n    const write = this.pendingWriteTree_.getWrite(writeId);\n    const needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n    if (!needToReevaluate) {\n      return [];\n    } else {\n      let affectedTree = ImmutableTree.Empty;\n      if (write.snap != null) { // overwrite\n        affectedTree = affectedTree.set(Path.Empty, true);\n      } else {\n        forEach(write.children, function (pathString: string, node: Node) {\n          affectedTree = affectedTree.set(new Path(pathString), node);\n        });\n      }\n      return this.applyOperationToSyncPoints_(new AckUserWrite(write.path, affectedTree, revert));\n    }\n  }\n\n  /**\n   * Apply new server data for the specified path..\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerOverwrite(path: Path, newData: Node): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new Overwrite(OperationSource.Server, path, newData));\n  }\n\n  /**\n   * Apply new server data to be merged in at the specified path.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerMerge(path: Path, changedChildren: { [k: string]: Node }): Event[] {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.Server, path, changeTree));\n  }\n\n  /**\n   * Apply a listen complete for a query\n   *\n   * @param {!Path} path\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyListenComplete(path: Path): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new ListenComplete(OperationSource.Server, path));\n  }\n\n  /**\n   * Apply new server data for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryOverwrite(path: Path, snap: Node, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey != null) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path, queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new Overwrite(OperationSource.forServerTaggedQuery(queryId),\n        relativePath, snap);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // Query must have been removed already\n      return [];\n    }\n  }\n\n  /**\n   * Apply server data to be merged in for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryMerge(path: Path, changedChildren: { [k: string]: Node }, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path, queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const changeTree = ImmutableTree.fromObject(changedChildren);\n      const op = new Merge(OperationSource.forServerTaggedQuery(queryId),\n        relativePath, changeTree);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Apply a listen complete for a tagged query\n   *\n   * @param {!Path} path\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedListenComplete(path: Path, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path, queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new ListenComplete(OperationSource.forServerTaggedQuery(queryId),\n        relativePath);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(query: Query, eventRegistration: EventRegistration): Event[] {\n    const path = query.path;\n\n    let serverCache: Node | null = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {\n      const relativePath = Path.relativePath(pathToSyncPoint, path);\n      serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n      foundAncestorDefaultView = foundAncestorDefaultView || sp.hasCompleteView();\n    });\n    let syncPoint = this.syncPointTree_.get(path);\n    if (!syncPoint) {\n      syncPoint = new SyncPoint();\n      this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n    } else {\n      foundAncestorDefaultView = foundAncestorDefaultView || syncPoint.hasCompleteView();\n      serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let serverCacheComplete;\n    if (serverCache != null) {\n      serverCacheComplete = true;\n    } else {\n      serverCacheComplete = false;\n      serverCache = ChildrenNode.EMPTY_NODE;\n      const subtree = this.syncPointTree_.subtree(path);\n      subtree.foreachChild(function (childName, childSyncPoint) {\n        const completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\n        if (completeCache) {\n          serverCache = serverCache.updateImmediateChild(childName, completeCache);\n        }\n      });\n    }\n\n    const viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n    if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n      // We need to track a tag for this query\n      const queryKey = SyncTree.makeQueryKey_(query);\n      assert(!(queryKey in this.queryToTagMap_),\n        'View does not exist, but we have a tag');\n      const tag = SyncTree.getNextQueryTag_();\n      this.queryToTagMap_[queryKey] = tag;\n      // Coerce to string to avoid sparse arrays.\n      this.tagToQueryMap_['_' + tag] = queryKey;\n    }\n    const writesCache = this.pendingWriteTree_.childWrites(path);\n    let events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n    if (!viewAlreadyExists && !foundAncestorDefaultView) {\n      const view = /** @type !View */ (syncPoint.viewForQuery(query));\n      events = events.concat(this.setupListener_(query, view));\n    }\n    return events;\n  }\n\n  /**\n   * Remove event callback(s).\n   *\n   * If query is the default query, we'll check all queries for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n   */\n  removeEventRegistration(query: Query, eventRegistration: EventRegistration | null,\n                          cancelError?: Error): Event[] {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query.path;\n    const maybeSyncPoint = this.syncPointTree_.get(path);\n    let cancelEvents: Event[] = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (maybeSyncPoint && (query.queryIdentifier() === 'default' || maybeSyncPoint.viewExistsForQuery(query))) {\n      /**\n       * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n       */\n      const removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);\n      if (maybeSyncPoint.isEmpty()) {\n        this.syncPointTree_ = this.syncPointTree_.remove(path);\n      }\n      const removed = removedAndEvents.removed;\n      cancelEvents = removedAndEvents.events;\n      // We may have just removed one of many listeners and can short-circuit this whole process\n      // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n      // properly set up.\n      //\n      // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n      // queryId === 'default'\n      const removingDefault = -1 !== removed.findIndex(function (query) {\n        return query.getQueryParams().loadsAllData();\n      });\n      const covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {\n        return parentSyncPoint.hasCompleteView();\n      });\n\n      if (removingDefault && !covered) {\n        const subtree = this.syncPointTree_.subtree(path);\n        // There are potentially child listeners. Determine what if any listens we need to send before executing the\n        // removal\n        if (!subtree.isEmpty()) {\n          // We need to fold over our subtree and collect the listeners to send\n          const newViews = this.collectDistinctViewsForSubTree_(subtree);\n\n          // Ok, we've collected all the listens we need. Set them up.\n          for (let i = 0; i < newViews.length; ++i) {\n            const view = newViews[i], newQuery = view.getQuery();\n            const listener = this.createListenerForView_(view);\n            this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery),\n              listener.hashFn, listener.onComplete);\n          }\n        } else {\n          // There's nothing below us, so nothing we need to start listening on\n        }\n      }\n      // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n      // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n      // Also, note that if we have a cancelError, it's already been removed at the provider level.\n      if (!covered && removed.length > 0 && !cancelError) {\n        // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n        // default. Otherwise, we need to iterate through and cancel each individual query\n        if (removingDefault) {\n          // We don't tag default listeners\n          const defaultTag: number | null = null;\n          this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);\n        } else {\n          removed.forEach((queryToRemove: Query) => {\n            const tagToRemove = this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];\n            this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);\n          });\n        }\n      }\n      // Now, clear all of the tags we're tracking for the removed listens\n      this.removeTags_(removed);\n    } else {\n      // No-op, this listener must've been already removed\n    }\n    return cancelEvents;\n  }\n\n  /**\n   * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n   * it, but as this is only used by transaction code, that should always be the case anyways.\n   *\n   * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n   * @param {!Path} path The path to the data we want\n   * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n   * @return {?Node}\n   */\n  calcCompleteEventCache(path: Path, writeIdsToExclude?: number[]): Node | null {\n    const includeHiddenSets = true;\n    const writeTree = this.pendingWriteTree_;\n    const serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {\n      const relativePath = Path.relativePath(pathSoFar, path);\n      const serverCache = syncPoint.getCompleteServerCache(relativePath);\n      if (serverCache) {\n        return serverCache;\n      }\n    });\n    return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);\n  }\n\n  /**\n   * This collapses multiple unfiltered views into a single view, since we only need a single\n   * listener for them.\n   *\n   * @param {!ImmutableTree.<!SyncPoint>} subtree\n   * @return {!Array.<!View>}\n   * @private\n   */\n  private collectDistinctViewsForSubTree_(subtree: ImmutableTree<SyncPoint>): View[] {\n    return subtree.fold<View[]>((relativePath, maybeChildSyncPoint, childMap) => {\n      if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n        const completeView = maybeChildSyncPoint.getCompleteView();\n        return [completeView];\n      } else {\n        // No complete view here, flatten any deeper listens into an array\n        let views: View[] = [];\n        if (maybeChildSyncPoint) {\n          views = maybeChildSyncPoint.getQueryViews();\n        }\n        forEach(childMap, function (key: string, childViews: View[]) {\n          views = views.concat(childViews);\n        });\n        return views;\n      }\n    });\n  }\n\n  /**\n   * @param {!Array.<!Query>} queries\n   * @private\n   */\n  private removeTags_(queries: Query[]) {\n    for (let j = 0; j < queries.length; ++j) {\n      const removedQuery = queries[j];\n      if (!removedQuery.getQueryParams().loadsAllData()) {\n        // We should have a tag for this\n        const removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n        const removedQueryTag = this.queryToTagMap_[removedQueryKey];\n        delete this.queryToTagMap_[removedQueryKey];\n        delete this.tagToQueryMap_['_' + removedQueryTag];\n      }\n    }\n  }\n\n\n  /**\n   * Normalizes a query to a query we send the server for listening\n   * @param {!Query} query\n   * @return {!Query} The normalized query\n   * @private\n   */\n  private static queryForListening_(query: Query): Query {\n    if (query.getQueryParams().loadsAllData() && !query.getQueryParams().isDefault()) {\n      // We treat queries that load all data as default queries\n      // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n      // from Query\n      return /** @type {!Query} */(query.getRef());\n    } else {\n      return query;\n    }\n  }\n\n\n  /**\n   * For a given new listen, manage the de-duplication of outstanding subscriptions.\n   *\n   * @param {!Query} query\n   * @param {!View} view\n   * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n   * @private\n   */\n  private setupListener_(query: Query, view: View): Event[] {\n    const path = query.path;\n    const tag = this.tagForQuery_(query);\n    const listener = this.createListenerForView_(view);\n\n    const events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn,\n      listener.onComplete);\n\n    const subtree = this.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n      assert(!subtree.value.hasCompleteView(), 'If we\\'re adding a query, it shouldn\\'t be shadowed');\n    } else {\n      // Shadow everything at or below this location, this is a default listener.\n      const queriesToStop = subtree.fold<Query[]>(function (relativePath, maybeChildSyncPoint, childMap) {\n        if (!relativePath.isEmpty() && maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n          return [maybeChildSyncPoint.getCompleteView().getQuery()];\n        } else {\n          // No default listener here, flatten any deeper queries into an array\n          let queries: Query[] = [];\n          if (maybeChildSyncPoint) {\n            queries = queries.concat(\n              maybeChildSyncPoint.getQueryViews().map(view=> view.getQuery())\n            );\n          }\n          forEach(childMap, function (key: string, childQueries: Query[]) {\n            queries = queries.concat(childQueries);\n          });\n          return queries;\n        }\n      });\n      for (let i = 0; i < queriesToStop.length; ++i) {\n        const queryToStop = queriesToStop[i];\n        this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));\n      }\n    }\n    return events;\n  }\n\n  /**\n   *\n   * @param {!View} view\n   * @return {{hashFn: function(), onComplete: function(!string, *)}}\n   * @private\n   */\n  private createListenerForView_(view: View): { hashFn(): string, onComplete(a: string, b?: any): Event[] } {\n    const query = view.getQuery();\n    const tag = this.tagForQuery_(query);\n\n    return {\n      hashFn: () => {\n        const cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\n        return cache.hash();\n      },\n      onComplete: (status: string): Event[] => {\n        if (status === 'ok') {\n          if (tag) {\n            return this.applyTaggedListenComplete(query.path, tag);\n          } else {\n            return this.applyListenComplete(query.path);\n          }\n        } else {\n          // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n          // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n          const error = errorForServerCode(status, query);\n          return this.removeEventRegistration(query, /*eventRegistration*/null, error);\n        }\n      }\n    };\n  }\n\n  /**\n   * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n   * @private\n   * @param {!Query} query\n   * @return {string}\n   */\n  private static makeQueryKey_(query: Query): string {\n    return query.path.toString() + '$' + query.queryIdentifier();\n  }\n\n  /**\n   * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n   * @private\n   * @param {!string} queryKey\n   * @return {{queryId: !string, path: !Path}}\n   */\n  private static parseQueryKey_(queryKey: string): { queryId: string, path: Path } {\n    const splitIndex = queryKey.indexOf('$');\n    assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\n    return {\n      queryId: queryKey.substr(splitIndex + 1),\n      path: new Path(queryKey.substr(0, splitIndex))\n    };\n  }\n\n  /**\n   * Return the query associated with the given tag, if we have one\n   * @param {!number} tag\n   * @return {?string}\n   * @private\n   */\n  private queryKeyForTag_(tag: number): string | null {\n    return this.tagToQueryMap_['_' + tag];\n  }\n\n  /**\n   * Return the tag associated with the given query.\n   * @param {!Query} query\n   * @return {?number}\n   * @private\n   */\n  private tagForQuery_(query: Query): number | null {\n    const queryKey = SyncTree.makeQueryKey_(query);\n    return safeGet(this.queryToTagMap_, queryKey);\n  }\n\n  /**\n   * Static tracker for next query tag.\n   * @type {number}\n   * @private\n   */\n  private static nextQueryTag_ = 1;\n\n  /**\n   * Static accessor for query tags.\n   * @return {number}\n   * @private\n   */\n  private static getNextQueryTag_(): number {\n    return SyncTree.nextQueryTag_++;\n  }\n\n  /**\n   * A helper method to apply tagged operations\n   *\n   * @param {!Path} queryPath\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyTaggedOperation_(queryPath: Path, operation: Operation): Event[] {\n    const syncPoint = this.syncPointTree_.get(queryPath);\n    assert(syncPoint, 'Missing sync point for query tag that we\\'re tracking');\n    const writesCache = this.pendingWriteTree_.childWrites(queryPath);\n    return syncPoint.applyOperation(operation, writesCache, /*serverCache=*/null);\n  }\n\n  /**\n   * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n   *\n   * NOTES:\n   * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n\n   * - We call applyOperation() on each SyncPoint passing three things:\n   *   1. A version of the Operation that has been made relative to the SyncPoint location.\n   *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n   *   3. A snapshot Node with cached server data, if we have it.\n\n   * - We concatenate all of the events returned by each SyncPoint and return the result.\n   *\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyOperationToSyncPoints_(operation: Operation): Event[] {\n    return this.applyOperationHelper_(operation, this.syncPointTree_, /*serverCache=*/ null,\n      this.pendingWriteTree_.childWrites(Path.Empty));\n\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationHelper_(operation: Operation, syncPointTree: ImmutableTree<SyncPoint>,\n                                serverCache: Node | null, writesCache: WriteTreeRef): Event[] {\n\n    if (operation.path.isEmpty()) {\n      return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n    } else {\n      const syncPoint = syncPointTree.get(Path.Empty);\n\n      // If we don't have cached server data, see if we can get it from this SyncPoint.\n      if (serverCache == null && syncPoint != null) {\n        serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n      }\n\n      let events: Event[] = [];\n      const childName = operation.path.getFront();\n      const childOperation = operation.operationForChild(childName);\n      const childTree = syncPointTree.children.get(childName);\n      if (childTree && childOperation) {\n        const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n        const childWritesCache = writesCache.child(childName);\n        events = events.concat(\n          this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n      }\n\n      if (syncPoint) {\n        events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n      }\n\n      return events;\n    }\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationDescendantsHelper_(operation: Operation, syncPointTree: ImmutableTree<SyncPoint>,\n                                           serverCache: Node | null, writesCache: WriteTreeRef): Event[] {\n    const syncPoint = syncPointTree.get(Path.Empty);\n\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n      serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let events: Event[] = [];\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\n      const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n      const childWritesCache = writesCache.child(childName);\n      const childOperation = operation.operationForChild(childName);\n      if (childOperation) {\n        events = events.concat(\n          this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n      }\n    });\n\n    if (syncPoint) {\n      events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n    }\n\n    return events;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../utils/assert';\nimport { errorForServerCode } from './util/util';\nimport { AckUserWrite } from './operation/AckUserWrite';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { forEach, safeGet } from '../../utils/obj';\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { ListenComplete } from './operation/ListenComplete';\nimport { Merge } from './operation/Merge';\nimport { OperationSource } from './operation/Operation';\nimport { Overwrite } from './operation/Overwrite';\nimport { Path } from './util/Path';\nimport { SyncPoint } from './SyncPoint';\nimport { WriteTree } from './WriteTree';\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nvar SyncTree = (function () {\n    /**\n     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n     *   to server data.\n     */\n    function SyncTree(listenProvider_) {\n        this.listenProvider_ = listenProvider_;\n        /**\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n         * @type {!ImmutableTree.<!SyncPoint>}\n         * @private\n         */\n        this.syncPointTree_ = ImmutableTree.Empty;\n        /**\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n         * @type {!WriteTree}\n         * @private\n         */\n        this.pendingWriteTree_ = new WriteTree();\n        this.tagToQueryMap_ = {};\n        this.queryToTagMap_ = {};\n    }\n    /**\n     * Apply the data changes for a user-generated set() or transaction() call.\n     *\n     * @param {!Path} path\n     * @param {!Node} newData\n     * @param {number} writeId\n     * @param {boolean=} visible\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {\n        // Record pending write.\n        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n        if (!visible) {\n            return [];\n        }\n        else {\n            return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.User, path, newData));\n        }\n    };\n    /**\n     * Apply the data from a user-generated update() call\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @param {!number} writeId\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {\n        // Record pending merge.\n        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n        var changeTree = ImmutableTree.fromObject(changedChildren);\n        return this.applyOperationToSyncPoints_(new Merge(OperationSource.User, path, changeTree));\n    };\n    /**\n     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n     *\n     * @param {!number} writeId\n     * @param {boolean=} revert True if the given write failed and needs to be reverted\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.ackUserWrite = function (writeId, revert) {\n        if (revert === void 0) { revert = false; }\n        var write = this.pendingWriteTree_.getWrite(writeId);\n        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n        if (!needToReevaluate) {\n            return [];\n        }\n        else {\n            var affectedTree_1 = ImmutableTree.Empty;\n            if (write.snap != null) {\n                affectedTree_1 = affectedTree_1.set(Path.Empty, true);\n            }\n            else {\n                forEach(write.children, function (pathString, node) {\n                    affectedTree_1 = affectedTree_1.set(new Path(pathString), node);\n                });\n            }\n            return this.applyOperationToSyncPoints_(new AckUserWrite(write.path, affectedTree_1, revert));\n        }\n    };\n    /**\n     * Apply new server data for the specified path..\n     *\n     * @param {!Path} path\n     * @param {!Node} newData\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyServerOverwrite = function (path, newData) {\n        return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.Server, path, newData));\n    };\n    /**\n     * Apply new server data to be merged in at the specified path.\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {\n        var changeTree = ImmutableTree.fromObject(changedChildren);\n        return this.applyOperationToSyncPoints_(new Merge(OperationSource.Server, path, changeTree));\n    };\n    /**\n     * Apply a listen complete for a query\n     *\n     * @param {!Path} path\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyListenComplete = function (path) {\n        return this.applyOperationToSyncPoints_(new ListenComplete(OperationSource.Server, path));\n    };\n    /**\n     * Apply new server data for the specified tagged query.\n     *\n     * @param {!Path} path\n     * @param {!Node} snap\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey != null) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path.relativePath(queryPath, path);\n            var op = new Overwrite(OperationSource.forServerTaggedQuery(queryId), relativePath, snap);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // Query must have been removed already\n            return [];\n        }\n    };\n    /**\n     * Apply server data to be merged in for the specified tagged query.\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path.relativePath(queryPath, path);\n            var changeTree = ImmutableTree.fromObject(changedChildren);\n            var op = new Merge(OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // We've already removed the query. No big deal, ignore the update\n            return [];\n        }\n    };\n    /**\n     * Apply a listen complete for a tagged query\n     *\n     * @param {!Path} path\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path.relativePath(queryPath, path);\n            var op = new ListenComplete(OperationSource.forServerTaggedQuery(queryId), relativePath);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // We've already removed the query. No big deal, ignore the update\n            return [];\n        }\n    };\n    /**\n     * Add an event callback for the specified query.\n     *\n     * @param {!Query} query\n     * @param {!EventRegistration} eventRegistration\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {\n        var path = query.path;\n        var serverCache = null;\n        var foundAncestorDefaultView = false;\n        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n        // Consider optimizing this once there's a better understanding of what actual behavior will be.\n        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {\n            var relativePath = Path.relativePath(pathToSyncPoint, path);\n            serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n            foundAncestorDefaultView = foundAncestorDefaultView || sp.hasCompleteView();\n        });\n        var syncPoint = this.syncPointTree_.get(path);\n        if (!syncPoint) {\n            syncPoint = new SyncPoint();\n            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n        }\n        else {\n            foundAncestorDefaultView = foundAncestorDefaultView || syncPoint.hasCompleteView();\n            serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\n        }\n        var serverCacheComplete;\n        if (serverCache != null) {\n            serverCacheComplete = true;\n        }\n        else {\n            serverCacheComplete = false;\n            serverCache = ChildrenNode.EMPTY_NODE;\n            var subtree = this.syncPointTree_.subtree(path);\n            subtree.foreachChild(function (childName, childSyncPoint) {\n                var completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\n                if (completeCache) {\n                    serverCache = serverCache.updateImmediateChild(childName, completeCache);\n                }\n            });\n        }\n        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n            // We need to track a tag for this query\n            var queryKey = SyncTree.makeQueryKey_(query);\n            assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');\n            var tag = SyncTree.getNextQueryTag_();\n            this.queryToTagMap_[queryKey] = tag;\n            // Coerce to string to avoid sparse arrays.\n            this.tagToQueryMap_['_' + tag] = queryKey;\n        }\n        var writesCache = this.pendingWriteTree_.childWrites(path);\n        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n        if (!viewAlreadyExists && !foundAncestorDefaultView) {\n            var view = (syncPoint.viewForQuery(query));\n            events = events.concat(this.setupListener_(query, view));\n        }\n        return events;\n    };\n    /**\n     * Remove event callback(s).\n     *\n     * If query is the default query, we'll check all queries for the specified eventRegistration.\n     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n     *\n     * @param {!Query} query\n     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n     */\n    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n        var _this = this;\n        // Find the syncPoint first. Then deal with whether or not it has matching listeners\n        var path = query.path;\n        var maybeSyncPoint = this.syncPointTree_.get(path);\n        var cancelEvents = [];\n        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n        // not loadsAllData().\n        if (maybeSyncPoint && (query.queryIdentifier() === 'default' || maybeSyncPoint.viewExistsForQuery(query))) {\n            /**\n             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n             */\n            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);\n            if (maybeSyncPoint.isEmpty()) {\n                this.syncPointTree_ = this.syncPointTree_.remove(path);\n            }\n            var removed = removedAndEvents.removed;\n            cancelEvents = removedAndEvents.events;\n            // We may have just removed one of many listeners and can short-circuit this whole process\n            // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n            // properly set up.\n            //\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n            // queryId === 'default'\n            var removingDefault = -1 !== removed.findIndex(function (query) {\n                return query.getQueryParams().loadsAllData();\n            });\n            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {\n                return parentSyncPoint.hasCompleteView();\n            });\n            if (removingDefault && !covered) {\n                var subtree = this.syncPointTree_.subtree(path);\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\n                // removal\n                if (!subtree.isEmpty()) {\n                    // We need to fold over our subtree and collect the listeners to send\n                    var newViews = this.collectDistinctViewsForSubTree_(subtree);\n                    // Ok, we've collected all the listens we need. Set them up.\n                    for (var i = 0; i < newViews.length; ++i) {\n                        var view = newViews[i], newQuery = view.getQuery();\n                        var listener = this.createListenerForView_(view);\n                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);\n                    }\n                }\n                else {\n                    // There's nothing below us, so nothing we need to start listening on\n                }\n            }\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\n            if (!covered && removed.length > 0 && !cancelError) {\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n                // default. Otherwise, we need to iterate through and cancel each individual query\n                if (removingDefault) {\n                    // We don't tag default listeners\n                    var defaultTag = null;\n                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);\n                }\n                else {\n                    removed.forEach(function (queryToRemove) {\n                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];\n                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);\n                    });\n                }\n            }\n            // Now, clear all of the tags we're tracking for the removed listens\n            this.removeTags_(removed);\n        }\n        else {\n            // No-op, this listener must've been already removed\n        }\n        return cancelEvents;\n    };\n    /**\n     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n     * it, but as this is only used by transaction code, that should always be the case anyways.\n     *\n     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n     * @param {!Path} path The path to the data we want\n     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n     * @return {?Node}\n     */\n    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {\n        var includeHiddenSets = true;\n        var writeTree = this.pendingWriteTree_;\n        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {\n            var relativePath = Path.relativePath(pathSoFar, path);\n            var serverCache = syncPoint.getCompleteServerCache(relativePath);\n            if (serverCache) {\n                return serverCache;\n            }\n        });\n        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);\n    };\n    /**\n     * This collapses multiple unfiltered views into a single view, since we only need a single\n     * listener for them.\n     *\n     * @param {!ImmutableTree.<!SyncPoint>} subtree\n     * @return {!Array.<!View>}\n     * @private\n     */\n    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {\n        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n                var completeView = maybeChildSyncPoint.getCompleteView();\n                return [completeView];\n            }\n            else {\n                // No complete view here, flatten any deeper listens into an array\n                var views_1 = [];\n                if (maybeChildSyncPoint) {\n                    views_1 = maybeChildSyncPoint.getQueryViews();\n                }\n                forEach(childMap, function (key, childViews) {\n                    views_1 = views_1.concat(childViews);\n                });\n                return views_1;\n            }\n        });\n    };\n    /**\n     * @param {!Array.<!Query>} queries\n     * @private\n     */\n    SyncTree.prototype.removeTags_ = function (queries) {\n        for (var j = 0; j < queries.length; ++j) {\n            var removedQuery = queries[j];\n            if (!removedQuery.getQueryParams().loadsAllData()) {\n                // We should have a tag for this\n                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n                var removedQueryTag = this.queryToTagMap_[removedQueryKey];\n                delete this.queryToTagMap_[removedQueryKey];\n                delete this.tagToQueryMap_['_' + removedQueryTag];\n            }\n        }\n    };\n    /**\n     * Normalizes a query to a query we send the server for listening\n     * @param {!Query} query\n     * @return {!Query} The normalized query\n     * @private\n     */\n    SyncTree.queryForListening_ = function (query) {\n        if (query.getQueryParams().loadsAllData() && !query.getQueryParams().isDefault()) {\n            // We treat queries that load all data as default queries\n            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n            // from Query\n            return (query.getRef());\n        }\n        else {\n            return query;\n        }\n    };\n    /**\n     * For a given new listen, manage the de-duplication of outstanding subscriptions.\n     *\n     * @param {!Query} query\n     * @param {!View} view\n     * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n     * @private\n     */\n    SyncTree.prototype.setupListener_ = function (query, view) {\n        var path = query.path;\n        var tag = this.tagForQuery_(query);\n        var listener = this.createListenerForView_(view);\n        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);\n        var subtree = this.syncPointTree_.subtree(path);\n        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n        // may need to shadow other listens as well.\n        if (tag) {\n            assert(!subtree.value.hasCompleteView(), 'If we\\'re adding a query, it shouldn\\'t be shadowed');\n        }\n        else {\n            // Shadow everything at or below this location, this is a default listener.\n            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n                if (!relativePath.isEmpty() && maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n                    return [maybeChildSyncPoint.getCompleteView().getQuery()];\n                }\n                else {\n                    // No default listener here, flatten any deeper queries into an array\n                    var queries_1 = [];\n                    if (maybeChildSyncPoint) {\n                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));\n                    }\n                    forEach(childMap, function (key, childQueries) {\n                        queries_1 = queries_1.concat(childQueries);\n                    });\n                    return queries_1;\n                }\n            });\n            for (var i = 0; i < queriesToStop.length; ++i) {\n                var queryToStop = queriesToStop[i];\n                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));\n            }\n        }\n        return events;\n    };\n    /**\n     *\n     * @param {!View} view\n     * @return {{hashFn: function(), onComplete: function(!string, *)}}\n     * @private\n     */\n    SyncTree.prototype.createListenerForView_ = function (view) {\n        var _this = this;\n        var query = view.getQuery();\n        var tag = this.tagForQuery_(query);\n        return {\n            hashFn: function () {\n                var cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\n                return cache.hash();\n            },\n            onComplete: function (status) {\n                if (status === 'ok') {\n                    if (tag) {\n                        return _this.applyTaggedListenComplete(query.path, tag);\n                    }\n                    else {\n                        return _this.applyListenComplete(query.path);\n                    }\n                }\n                else {\n                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n                    var error = errorForServerCode(status, query);\n                    return _this.removeEventRegistration(query, /*eventRegistration*/ null, error);\n                }\n            }\n        };\n    };\n    /**\n     * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n     * @private\n     * @param {!Query} query\n     * @return {string}\n     */\n    SyncTree.makeQueryKey_ = function (query) {\n        return query.path.toString() + '$' + query.queryIdentifier();\n    };\n    /**\n     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n     * @private\n     * @param {!string} queryKey\n     * @return {{queryId: !string, path: !Path}}\n     */\n    SyncTree.parseQueryKey_ = function (queryKey) {\n        var splitIndex = queryKey.indexOf('$');\n        assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\n        return {\n            queryId: queryKey.substr(splitIndex + 1),\n            path: new Path(queryKey.substr(0, splitIndex))\n        };\n    };\n    /**\n     * Return the query associated with the given tag, if we have one\n     * @param {!number} tag\n     * @return {?string}\n     * @private\n     */\n    SyncTree.prototype.queryKeyForTag_ = function (tag) {\n        return this.tagToQueryMap_['_' + tag];\n    };\n    /**\n     * Return the tag associated with the given query.\n     * @param {!Query} query\n     * @return {?number}\n     * @private\n     */\n    SyncTree.prototype.tagForQuery_ = function (query) {\n        var queryKey = SyncTree.makeQueryKey_(query);\n        return safeGet(this.queryToTagMap_, queryKey);\n    };\n    /**\n     * Static accessor for query tags.\n     * @return {number}\n     * @private\n     */\n    SyncTree.getNextQueryTag_ = function () {\n        return SyncTree.nextQueryTag_++;\n    };\n    /**\n     * A helper method to apply tagged operations\n     *\n     * @param {!Path} queryPath\n     * @param {!Operation} operation\n     * @return {!Array.<!Event>}\n     * @private\n     */\n    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {\n        var syncPoint = this.syncPointTree_.get(queryPath);\n        assert(syncPoint, 'Missing sync point for query tag that we\\'re tracking');\n        var writesCache = this.pendingWriteTree_.childWrites(queryPath);\n        return syncPoint.applyOperation(operation, writesCache, /*serverCache=*/ null);\n    };\n    /**\n     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n     *\n     * NOTES:\n     * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n  \n     * - We call applyOperation() on each SyncPoint passing three things:\n     *   1. A version of the Operation that has been made relative to the SyncPoint location.\n     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n     *   3. A snapshot Node with cached server data, if we have it.\n  \n     * - We concatenate all of the events returned by each SyncPoint and return the result.\n     *\n     * @param {!Operation} operation\n     * @return {!Array.<!Event>}\n     * @private\n     */\n    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {\n        return this.applyOperationHelper_(operation, this.syncPointTree_, /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path.Empty));\n    };\n    /**\n     * Recursive helper for applyOperationToSyncPoints_\n     *\n     * @private\n     * @param {!Operation} operation\n     * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n     * @param {?Node} serverCache\n     * @param {!WriteTreeRef} writesCache\n     * @return {!Array.<!Event>}\n     */\n    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n        if (operation.path.isEmpty()) {\n            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n        }\n        else {\n            var syncPoint = syncPointTree.get(Path.Empty);\n            // If we don't have cached server data, see if we can get it from this SyncPoint.\n            if (serverCache == null && syncPoint != null) {\n                serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n            }\n            var events = [];\n            var childName = operation.path.getFront();\n            var childOperation = operation.operationForChild(childName);\n            var childTree = syncPointTree.children.get(childName);\n            if (childTree && childOperation) {\n                var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n                var childWritesCache = writesCache.child(childName);\n                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n            }\n            if (syncPoint) {\n                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n            }\n            return events;\n        }\n    };\n    /**\n     * Recursive helper for applyOperationToSyncPoints_\n     *\n     * @private\n     * @param {!Operation} operation\n     * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n     * @param {?Node} serverCache\n     * @param {!WriteTreeRef} writesCache\n     * @return {!Array.<!Event>}\n     */\n    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n        var _this = this;\n        var syncPoint = syncPointTree.get(Path.Empty);\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\n        if (serverCache == null && syncPoint != null) {\n            serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n        }\n        var events = [];\n        syncPointTree.children.inorderTraversal(function (childName, childTree) {\n            var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n            var childWritesCache = writesCache.child(childName);\n            var childOperation = operation.operationForChild(childName);\n            if (childOperation) {\n                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n            }\n        });\n        if (syncPoint) {\n            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n        }\n        return events;\n    };\n    return SyncTree;\n}());\nexport { SyncTree };\n/**\n * Static tracker for next query tag.\n * @type {number}\n * @private\n */\nSyncTree.nextQueryTag_ = 1;\n\n\n"]}