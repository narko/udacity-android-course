{"version":3,"sources":["src/database/core/SyncPoint.ts","database/core/SyncPoint.js"],"names":["__referenceConstructor","SyncPoint","views_","Object","defineProperty","get","set","val","enumerable","configurable","prototype","isEmpty","applyOperation","operation","writesCache","optCompleteServerCache","queryId","source","view","events_1","key","concat","addEventRegistration","query","eventRegistration","serverCache","serverCacheComplete","queryIdentifier","eventCache","calcCompleteEventCache","eventCacheComplete","calcCompleteEventChildren","EMPTY_NODE","viewCache","getInitialEvents","removeEventRegistration","cancelError","removed","cancelEvents","hadCompleteView","hasCompleteView","self_1","viewQueryId","getQuery","getQueryParams","loadsAllData","push","repo","path","events","getQueryViews","_this","values","keys","map","filter","getCompleteServerCache","viewForQuery","params","getCompleteView","viewExistsForQuery","completeView"],"mappings":"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","file":"SyncPoint.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '../../utils/assert';\nimport { isEmpty, forEach, findValue, safeGet } from '../../utils/obj';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nimport { Operation } from './operation/Operation';\nimport { WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { Node } from './snap/Node';\nimport { Path } from './util/Path';\nimport { Event } from './view/Event';\nimport { Reference, ReferenceConstructor } from '../api/Reference';\n\nlet __referenceConstructor: ReferenceConstructor;\n\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nexport class SyncPoint {\n  static set __referenceConstructor(val: ReferenceConstructor) {\n    assert(!__referenceConstructor, '__referenceConstructor has already been defined');\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  /**\n   * The Views being tracked at this location in the tree, stored as a map where the key is a\n   * queryId and the value is the View for that query.\n   *\n   * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n   *\n   * @type {!Object.<!string, !View>}\n   * @private\n   */\n  private views_: { [k: string]: View } = {};\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return isEmpty(this.views_);\n  }\n\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n  applyOperation(operation: Operation, writesCache: WriteTreeRef,\n                 optCompleteServerCache: Node | null): Event[] {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n      const view = safeGet(this.views_, queryId);\n      assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(operation, writesCache, optCompleteServerCache);\n    } else {\n      let events: Event[] = [];\n\n      forEach(this.views_, function (key: string, view: View) {\n        events = events.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\n      });\n\n      return events;\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(query: Query, eventRegistration: EventRegistration, writesCache: WriteTreeRef,\n                       serverCache: Node | null, serverCacheComplete: boolean): Event[] {\n    const queryId = query.queryIdentifier();\n    let view = safeGet(this.views_, queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      let eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\n      let eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      const viewCache = new ViewCache(\n        new CacheNode(/** @type {!Node} */ (eventCache), eventCacheComplete, false),\n        new CacheNode(/** @type {!Node} */ (serverCache), serverCacheComplete, false)\n      );\n      view = new View(query, viewCache);\n      this.views_[queryId] = view;\n    }\n\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  }\n\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  removeEventRegistration(query: Query, eventRegistration: EventRegistration | null,\n                          cancelError?: Error): { removed: Query[], events: Event[] } {\n    const queryId = query.queryIdentifier();\n    const removed: Query[] = [];\n    let cancelEvents: Event[] = [];\n    const hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      const self = this;\n      forEach(this.views_, function (viewQueryId: string, view: View) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n        if (view.isEmpty()) {\n          delete self.views_[viewQueryId];\n\n          // We'll deal with complete views later.\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      const view = safeGet(this.views_, queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n        if (view.isEmpty()) {\n          delete this.views_[queryId];\n\n          // We'll deal with complete views later.\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\n    }\n\n    return {removed: removed, events: cancelEvents};\n  }\n\n  /**\n   * @return {!Array.<!View>}\n   */\n  getQueryViews(): View[] {\n    const values = Object.keys(this.views_)\n      .map(key => this.views_[key]);\n    return values.filter(function (view) {\n      return !view.getQuery().getQueryParams().loadsAllData();\n    });\n  }\n\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    let serverCache: Node | null = null;\n    forEach(this.views_, (key: string, view: View) => {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n  viewForQuery(query: Query): View | null {\n    const params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      const queryId = query.queryIdentifier();\n      return safeGet(this.views_, queryId);\n    }\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n  viewExistsForQuery(query: Query): boolean {\n    return this.viewForQuery(query) != null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasCompleteView(): boolean {\n    return this.getCompleteView() != null;\n  }\n\n  /**\n   * @return {?View}\n   */\n  getCompleteView(): View | null {\n    const completeView = findValue(this.views_, (view: View) => view.getQuery().getQueryParams().loadsAllData());\n    return completeView || null;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '../../utils/assert';\nimport { isEmpty, forEach, findValue, safeGet } from '../../utils/obj';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nvar __referenceConstructor;\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nvar SyncPoint = (function () {\n    function SyncPoint() {\n        /**\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\n         * queryId and the value is the View for that query.\n         *\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n         *\n         * @type {!Object.<!string, !View>}\n         * @private\n         */\n        this.views_ = {};\n    }\n    Object.defineProperty(SyncPoint, \"__referenceConstructor\", {\n        get: function () {\n            assert(__referenceConstructor, 'Reference.ts has not been loaded');\n            return __referenceConstructor;\n        },\n        set: function (val) {\n            assert(!__referenceConstructor, '__referenceConstructor has already been defined');\n            __referenceConstructor = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {boolean}\n     */\n    SyncPoint.prototype.isEmpty = function () {\n        return isEmpty(this.views_);\n    };\n    /**\n     *\n     * @param {!Operation} operation\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} optCompleteServerCache\n     * @return {!Array.<!Event>}\n     */\n    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {\n        var queryId = operation.source.queryId;\n        if (queryId !== null) {\n            var view = safeGet(this.views_, queryId);\n            assert(view != null, 'SyncTree gave us an op for an invalid query.');\n            return view.applyOperation(operation, writesCache, optCompleteServerCache);\n        }\n        else {\n            var events_1 = [];\n            forEach(this.views_, function (key, view) {\n                events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\n            });\n            return events_1;\n        }\n    };\n    /**\n     * Add an event callback for the specified query.\n     *\n     * @param {!Query} query\n     * @param {!EventRegistration} eventRegistration\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache Complete server cache, if we have it.\n     * @param {boolean} serverCacheComplete\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n        var queryId = query.queryIdentifier();\n        var view = safeGet(this.views_, queryId);\n        if (!view) {\n            // TODO: make writesCache take flag for complete server node\n            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\n            var eventCacheComplete = false;\n            if (eventCache) {\n                eventCacheComplete = true;\n            }\n            else if (serverCache instanceof ChildrenNode) {\n                eventCache = writesCache.calcCompleteEventChildren(serverCache);\n                eventCacheComplete = false;\n            }\n            else {\n                eventCache = ChildrenNode.EMPTY_NODE;\n                eventCacheComplete = false;\n            }\n            var viewCache = new ViewCache(new CacheNode(/** @type {!Node} */ (eventCache), eventCacheComplete, false), new CacheNode(/** @type {!Node} */ (serverCache), serverCacheComplete, false));\n            view = new View(query, viewCache);\n            this.views_[queryId] = view;\n        }\n        // This is guaranteed to exist now, we just created anything that was missing\n        view.addEventRegistration(eventRegistration);\n        return view.getInitialEvents(eventRegistration);\n    };\n    /**\n     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n     *\n     * If query is the default query, we'll check all views for the specified eventRegistration.\n     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n     *\n     * @param {!Query} query\n     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n     */\n    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n        var queryId = query.queryIdentifier();\n        var removed = [];\n        var cancelEvents = [];\n        var hadCompleteView = this.hasCompleteView();\n        if (queryId === 'default') {\n            // When you do ref.off(...), we search all views for the registration to remove.\n            var self_1 = this;\n            forEach(this.views_, function (viewQueryId, view) {\n                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n                if (view.isEmpty()) {\n                    delete self_1.views_[viewQueryId];\n                    // We'll deal with complete views later.\n                    if (!view.getQuery().getQueryParams().loadsAllData()) {\n                        removed.push(view.getQuery());\n                    }\n                }\n            });\n        }\n        else {\n            // remove the callback from the specific view.\n            var view = safeGet(this.views_, queryId);\n            if (view) {\n                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n                if (view.isEmpty()) {\n                    delete this.views_[queryId];\n                    // We'll deal with complete views later.\n                    if (!view.getQuery().getQueryParams().loadsAllData()) {\n                        removed.push(view.getQuery());\n                    }\n                }\n            }\n        }\n        if (hadCompleteView && !this.hasCompleteView()) {\n            // We removed our last complete view.\n            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\n        }\n        return { removed: removed, events: cancelEvents };\n    };\n    /**\n     * @return {!Array.<!View>}\n     */\n    SyncPoint.prototype.getQueryViews = function () {\n        var _this = this;\n        var values = Object.keys(this.views_)\n            .map(function (key) { return _this.views_[key]; });\n        return values.filter(function (view) {\n            return !view.getQuery().getQueryParams().loadsAllData();\n        });\n    };\n    /**\n     *\n     * @param {!Path} path The path to the desired complete snapshot\n     * @return {?Node} A complete cache, if it exists\n     */\n    SyncPoint.prototype.getCompleteServerCache = function (path) {\n        var serverCache = null;\n        forEach(this.views_, function (key, view) {\n            serverCache = serverCache || view.getCompleteServerCache(path);\n        });\n        return serverCache;\n    };\n    /**\n     * @param {!Query} query\n     * @return {?View}\n     */\n    SyncPoint.prototype.viewForQuery = function (query) {\n        var params = query.getQueryParams();\n        if (params.loadsAllData()) {\n            return this.getCompleteView();\n        }\n        else {\n            var queryId = query.queryIdentifier();\n            return safeGet(this.views_, queryId);\n        }\n    };\n    /**\n     * @param {!Query} query\n     * @return {boolean}\n     */\n    SyncPoint.prototype.viewExistsForQuery = function (query) {\n        return this.viewForQuery(query) != null;\n    };\n    /**\n     * @return {boolean}\n     */\n    SyncPoint.prototype.hasCompleteView = function () {\n        return this.getCompleteView() != null;\n    };\n    /**\n     * @return {?View}\n     */\n    SyncPoint.prototype.getCompleteView = function () {\n        var completeView = findValue(this.views_, function (view) { return view.getQuery().getQueryParams().loadsAllData(); });\n        return completeView || null;\n    };\n    return SyncPoint;\n}());\nexport { SyncPoint };\n\n\n"]}