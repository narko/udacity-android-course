{"version":3,"sources":["database/src/database/core/view/ChildChangeAccumulator.ts","database/core/view/ChildChangeAccumulator.js"],"names":["ChildChangeAccumulator","changeMap_","prototype","trackChildChange","change","type","childKey","childName","CHILD_ADDED","CHILD_CHANGED","CHILD_REMOVED","oldChange","oldType","childChangedChange","snapshotNode","childRemovedChange","oldSnap","childAddedChange","getChanges"],"mappings":";;;;;;;AAgBA;;AACA;;AACA;;AAEA;;;AAGA,IAAAA,yBAAA,YAAA;AAAA,aAAAA,sBAAA,GAAA;AACU,aAAAC,UAAA,GAAsC,EAAtC;AAwCT;AAtCC;;;AAGAD,2BAAAE,SAAA,CAAAC,gBAAA,GAAA,UAAiBC,MAAjB,EAA+B;AAC7B,YAAMC,OAAOD,OAAOC,IAApB;AACA,YAAMC,WAAmCF,OAAOG,SAAhD;AACA,4BAAOF,QAAQ,eAAOG,WAAf,IACLH,QAAQ,eAAOI,aADV,IAELJ,QAAQ,eAAOK,aAFjB,EAEgC,2CAFhC;AAGA,4BAAOJ,aAAa,WAApB,EAAiC,iDAAjC;AACA,YAAMK,YAAY,kBAAQ,KAAKV,UAAb,EAAyBK,QAAzB,CAAlB;AACA,YAAIK,SAAJ,EAAe;AACb,gBAAMC,UAAUD,UAAUN,IAA1B;AACA,gBAAIA,QAAQ,eAAOG,WAAf,IAA8BI,WAAW,eAAOF,aAApD,EAAmE;AACjE,qBAAKT,UAAL,CAAgBK,QAAhB,IAA4B,eAAOO,kBAAP,CAA0BP,QAA1B,EAAoCF,OAAOU,YAA3C,EAAyDH,UAAUG,YAAnE,CAA5B;AACD,aAFD,MAEO,IAAIT,QAAQ,eAAOK,aAAf,IAAgCE,WAAW,eAAOJ,WAAtD,EAAmE;AACxE,uBAAO,KAAKP,UAAL,CAAgBK,QAAhB,CAAP;AACD,aAFM,MAEA,IAAID,QAAQ,eAAOK,aAAf,IAAgCE,WAAW,eAAOH,aAAtD,EAAqE;AAC1E,qBAAKR,UAAL,CAAgBK,QAAhB,IAA4B,eAAOS,kBAAP,CAA0BT,QAA1B,EAAoCK,UAAUK,OAA9C,CAA5B;AACD,aAFM,MAEA,IAAIX,QAAQ,eAAOI,aAAf,IAAgCG,WAAW,eAAOJ,WAAtD,EAAmE;AACxE,qBAAKP,UAAL,CAAgBK,QAAhB,IAA4B,eAAOW,gBAAP,CAAwBX,QAAxB,EAAkCF,OAAOU,YAAzC,CAA5B;AACD,aAFM,MAEA,IAAIT,QAAQ,eAAOI,aAAf,IAAgCG,WAAW,eAAOH,aAAtD,EAAqE;AAC1E,qBAAKR,UAAL,CAAgBK,QAAhB,IAA4B,eAAOO,kBAAP,CAA0BP,QAA1B,EAAoCF,OAAOU,YAA3C,EAAyDH,UAAUK,OAAnE,CAA5B;AACD,aAFM,MAEA;AACL,sBAAM,4BAAe,qCAAqCZ,MAArC,GAA8C,kBAA9C,GAAmEO,SAAlF,CAAN;AACD;AACF,SAfD,MAeO;AACL,iBAAKV,UAAL,CAAgBK,QAAhB,IAA4BF,MAA5B;AACD;AACF,KA1BD;AA6BA;;;AAGAJ,2BAAAE,SAAA,CAAAgB,UAAA,GAAA,YAAA;AACE,eAAO,oBAAU,KAAKjB,UAAf,CAAP;AACD,KAFD;AAGF,WAAAD,sBAAA;AAzCA,CAAA,EAAA,C,CAvBA;;;;;;;;;;;;;;;QCqESA,sB,GAAAA,sB","file":"ChildChangeAccumulator.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { getValues, safeGet } from '../../../utils/obj';\nimport { Change } from './Change';\nimport { assert, assertionError } from '../../../utils/assert';\n\n/**\n * @constructor\n */\nexport class ChildChangeAccumulator {\n  private changeMap_: { [k: string]: Change } = {};\n\n  /**\n   * @param {!Change} change\n   */\n  trackChildChange(change: Change) {\n    const type = change.type;\n    const childKey = /** @type {!string} */ (change.childName);\n    assert(type == Change.CHILD_ADDED ||\n      type == Change.CHILD_CHANGED ||\n      type == Change.CHILD_REMOVED, 'Only child changes supported for tracking');\n    assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');\n    const oldChange = safeGet(this.changeMap_, childKey) as Change;\n    if (oldChange) {\n      const oldType = oldChange.type;\n      if (type == Change.CHILD_ADDED && oldType == Change.CHILD_REMOVED) {\n        this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);\n      } else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_ADDED) {\n        delete this.changeMap_[childKey];\n      } else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_CHANGED) {\n        this.changeMap_[childKey] = Change.childRemovedChange(childKey, oldChange.oldSnap);\n      } else if (type == Change.CHILD_CHANGED && oldType == Change.CHILD_ADDED) {\n        this.changeMap_[childKey] = Change.childAddedChange(childKey, change.snapshotNode);\n      } else if (type == Change.CHILD_CHANGED && oldType == Change.CHILD_CHANGED) {\n        this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);\n      } else {\n        throw assertionError('Illegal combination of changes: ' + change + ' occurred after ' + oldChange);\n      }\n    } else {\n      this.changeMap_[childKey] = change;\n    }\n  }\n\n\n  /**\n   * @return {!Array.<!Change>}\n   */\n  getChanges(): Change[] {\n    return getValues(this.changeMap_);\n  }\n}\n\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { getValues, safeGet } from '../../../utils/obj';\nimport { Change } from './Change';\nimport { assert, assertionError } from '../../../utils/assert';\n/**\n * @constructor\n */\nvar ChildChangeAccumulator = (function () {\n    function ChildChangeAccumulator() {\n        this.changeMap_ = {};\n    }\n    /**\n     * @param {!Change} change\n     */\n    ChildChangeAccumulator.prototype.trackChildChange = function (change) {\n        var type = change.type;\n        var childKey = (change.childName);\n        assert(type == Change.CHILD_ADDED ||\n            type == Change.CHILD_CHANGED ||\n            type == Change.CHILD_REMOVED, 'Only child changes supported for tracking');\n        assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');\n        var oldChange = safeGet(this.changeMap_, childKey);\n        if (oldChange) {\n            var oldType = oldChange.type;\n            if (type == Change.CHILD_ADDED && oldType == Change.CHILD_REMOVED) {\n                this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);\n            }\n            else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_ADDED) {\n                delete this.changeMap_[childKey];\n            }\n            else if (type == Change.CHILD_REMOVED && oldType == Change.CHILD_CHANGED) {\n                this.changeMap_[childKey] = Change.childRemovedChange(childKey, oldChange.oldSnap);\n            }\n            else if (type == Change.CHILD_CHANGED && oldType == Change.CHILD_ADDED) {\n                this.changeMap_[childKey] = Change.childAddedChange(childKey, change.snapshotNode);\n            }\n            else if (type == Change.CHILD_CHANGED && oldType == Change.CHILD_CHANGED) {\n                this.changeMap_[childKey] = Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);\n            }\n            else {\n                throw assertionError('Illegal combination of changes: ' + change + ' occurred after ' + oldChange);\n            }\n        }\n        else {\n            this.changeMap_[childKey] = change;\n        }\n    };\n    /**\n     * @return {!Array.<!Change>}\n     */\n    ChildChangeAccumulator.prototype.getChanges = function () {\n        return getValues(this.changeMap_);\n    };\n    return ChildChangeAccumulator;\n}());\nexport { ChildChangeAccumulator };\n\n\n"]}