{"version":3,"sources":["database/core/src/database/core/view/filter/IndexedFilter.ts","database/core/view/filter/IndexedFilter.js"],"names":["IndexedFilter","index_","prototype","updateChild","snap","key","newChild","affectedPath","source","optChangeAccumulator","isIndexed","oldChild","getImmediateChild","getChild","equals","isEmpty","hasChild","trackChildChange","childRemovedChange","isLeafNode","childAddedChange","childChangedChange","updateImmediateChild","withIndex","updateFullNode","oldSnap","newSnap","forEachChild","childNode","updatePriority","newPriority","EMPTY_NODE","filtersNodes","getIndexedFilter","getIndex"],"mappings":"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","file":"IndexedFilter.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from \"../../../../utils/assert\";\nimport { Change } from \"../Change\";\nimport { ChildrenNode } from \"../../snap/ChildrenNode\";\nimport { PRIORITY_INDEX } from \"../../snap/indexes/PriorityIndex\";\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {\n  }\n\n  updateChild(snap: Node, key: string, newChild: Node, affectedPath: Path,\n              source: CompleteChildSource,\n              optChangeAccumulator: ChildChangeAccumulator | null): Node {\n    assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, oldChild));\n        } else {\n          assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(Change.childAddedChange(key, newChild));\n      } else {\n        optChangeAccumulator.trackChildChange(Change.childChangedChange(key, newChild, oldChild));\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(oldSnap: Node, newSnap: Node,\n                 optChangeAccumulator: ChildChangeAccumulator | null): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, childNode));\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(Change.childChangedChange(key, childNode, oldChild));\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(Change.childAddedChange(key, childNode));\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  };\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from \"../../../../utils/assert\";\nimport { Change } from \"../Change\";\nimport { ChildrenNode } from \"../../snap/ChildrenNode\";\nimport { PRIORITY_INDEX } from \"../../snap/indexes/PriorityIndex\";\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nvar IndexedFilter = (function () {\n    function IndexedFilter(index_) {\n        this.index_ = index_;\n    }\n    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n        var oldChild = snap.getImmediateChild(key);\n        // Check if anything actually changed.\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n            // to avoid treating these cases as \"nothing changed.\"\n            if (oldChild.isEmpty() == newChild.isEmpty()) {\n                // Nothing changed.\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n                return snap;\n            }\n        }\n        if (optChangeAccumulator != null) {\n            if (newChild.isEmpty()) {\n                if (snap.hasChild(key)) {\n                    optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, oldChild));\n                }\n                else {\n                    assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n                }\n            }\n            else if (oldChild.isEmpty()) {\n                optChangeAccumulator.trackChildChange(Change.childAddedChange(key, newChild));\n            }\n            else {\n                optChangeAccumulator.trackChildChange(Change.childChangedChange(key, newChild, oldChild));\n            }\n        }\n        if (snap.isLeafNode() && newChild.isEmpty()) {\n            return snap;\n        }\n        else {\n            // Make sure the node is indexed\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n        }\n    };\n    ;\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n        if (optChangeAccumulator != null) {\n            if (!oldSnap.isLeafNode()) {\n                oldSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n                    if (!newSnap.hasChild(key)) {\n                        optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, childNode));\n                    }\n                });\n            }\n            if (!newSnap.isLeafNode()) {\n                newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\n                    if (oldSnap.hasChild(key)) {\n                        var oldChild = oldSnap.getImmediateChild(key);\n                        if (!oldChild.equals(childNode)) {\n                            optChangeAccumulator.trackChildChange(Change.childChangedChange(key, childNode, oldChild));\n                        }\n                    }\n                    else {\n                        optChangeAccumulator.trackChildChange(Change.childAddedChange(key, childNode));\n                    }\n                });\n            }\n        }\n        return newSnap.withIndex(this.index_);\n    };\n    ;\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n        if (oldSnap.isEmpty()) {\n            return ChildrenNode.EMPTY_NODE;\n        }\n        else {\n            return oldSnap.updatePriority(newPriority);\n        }\n    };\n    ;\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.filtersNodes = function () {\n        return false;\n    };\n    ;\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.getIndexedFilter = function () {\n        return this;\n    };\n    ;\n    /**\n     * @inheritDoc\n     */\n    IndexedFilter.prototype.getIndex = function () {\n        return this.index_;\n    };\n    ;\n    return IndexedFilter;\n}());\nexport { IndexedFilter };\n\n\n"]}