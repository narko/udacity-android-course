{"version":3,"sources":["database/src/database/core/view/ViewProcessor.ts","database/core/view/ViewProcessor.js"],"names":["ProcessorResult","viewCache","changes","ViewProcessor","filter_","prototype","assertIndexed","getEventCache","getNode","isIndexed","getIndex","getServerCache","applyOperation","oldViewCache","operation","writesCache","completeCache","accumulator","newViewCache","filterServerNode","type","OVERWRITE","overwrite","source","fromUser","applyUserOverwrite_","path","snap","fromServer","tagged","isFiltered","isEmpty","applyServerOverwrite_","MERGE","merge","applyUserMerge_","children","applyServerMerge_","ACK_USER_WRITE","ackUserWrite","revert","ackUserWrite_","affectedTree","revertUserWrite_","LISTEN_COMPLETE","listenComplete_","getChanges","maybeAddValueEvent_","eventSnap","isFullyInitialized","isLeafOrEmpty","isLeafNode","oldCompleteSnap","getCompleteEventSnap","length","equals","getPriority","push","valueChange","generateEventCacheAfterServerEvent_","changePath","oldEventSnap","shadowingWrite","newEventCache","serverNode","serverCache","getCompleteServerSnap","completeChildren","EMPTY_NODE","completeEventChildren","calcCompleteEventChildren","updateFullNode","completeNode","calcCompleteEventCache","childKey","getFront","getLength","oldEventNode","updatedPriority","calcEventCacheAfterServerOverwrite","updatePriority","childChangePath","popFront","newEventChild","isCompleteForChild","eventChildUpdate","getImmediateChild","updateChild","calcCompleteChild","updateEventSnap","filtersNodes","changedSnap","oldServerSnap","newServerCache","serverFilter","getIndexedFilter","newServerNode","isCompleteForPath","childNode","newChildNode","updateServerSnap","oldChild","newChild","getCompleteChild","getBack","getChild","parent","newEventSnap","cacheHasChild_","changedChildren","_this","curViewCache","foreach","relativePath","writePath","child","applyMerge_","node","viewMergeTree","Empty","setTree","inorderTraversal","childTree","hasChild","serverChild","childMergeTree","isUnknownDeepMerge","value","ackPath","changedChildren_1","forEachChild","name","set","changedChildren_2","mergePath","serverCachePath","oldServerNode","completeServerCache","complete","oldEventCache","newNode","serverChildren"],"mappings":"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","file":"ViewProcessor.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '../../../utils/assert';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport { WriteTreeCompleteChildSource, NO_COMPLETE_CHILD_SOURCE, CompleteChildSource } from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(public readonly viewCache: ViewCache,\n              public readonly changes: Change[]) {\n  }\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n    assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed');\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(oldViewCache: ViewCache, operation: Operation,\n                 writesCache: WriteTreeRef, completeCache: Node | null): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap,\n          writesCache, completeCache, accumulator);\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode = overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache,\n          completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache,\n          completeCache, accumulator);\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache,\n          filterServerNode, accumulator);\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache,\n          completeCache, accumulator);\n      } else {\n        newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(oldViewCache: ViewCache, newViewCache: ViewCache, accumulator: Change[]) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty && !eventSnap.getNode().equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n        !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n        accumulator.push(Change.valueChange(\n          /** @type {!Node} */ (newViewCache.getCompleteEventSnap())));\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(viewCache: ViewCache, changePath: Path,\n                                              writesCache: WriteTreeRef, source: CompleteChildSource,\n                                              accumulator: ChildChangeAccumulator): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data');\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren = (serverCache instanceof ChildrenNode) ? serverCache :\n            ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren,\n            accumulator);\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(changePath.getLength() == 1, 'Can\\'t have a priority with additional path components');\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(),\n              serverNode);\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,\n                eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath,\n              source, accumulator);\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes());\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(oldViewCache: ViewCache, changePath: Path, changedSnap: Node,\n                        writesCache: WriteTreeRef, completeCache: Node | null, filterServerNode: boolean,\n                        accumulator: ChildChangeAccumulator): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n      const childKey = changePath.getFront();\n      if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n      } else {\n        newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath,\n          NO_COMPLETE_CHILD_SOURCE, null);\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(oldViewCache: ViewCache, changePath: Path, changedSnap: Node, writesCache: WriteTreeRef,\n                      completeCache: Node | null, accumulator: ChildChangeAccumulator): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n      newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n        newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered());\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath,\n            source, accumulator);\n          newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes());\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(viewCache: ViewCache, childKey: string): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(viewCache: ViewCache, path: Path, changedChildren: ImmutableTree<Node>, writesCache: WriteTreeRef,\n                          serverCache: Node | null, accumulator: ChildChangeAccumulator): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache,\n          serverCache, accumulator);\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache,\n          serverCache, accumulator);\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function (relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(viewCache: ViewCache, path: Path, changedChildren: ImmutableTree<Node>,\n                            writesCache: WriteTreeRef, serverCache: Node | null, filterServerNode: boolean,\n                            accumulator: ChildChangeAccumulator): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild,\n          writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey)\n        && (childMergeTree.value == null);\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache,\n          serverCache, filterServerNode, accumulator);\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(viewCache: ViewCache, ackPath: Path, affectedTree: ImmutableTree<boolean>, writesCache: WriteTreeRef,\n                        completeCache: Node | null, accumulator: ChildChangeAccumulator): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) || serverCache.isCompleteForPath(ackPath)) {\n        return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath),\n          writesCache, completeCache, filterServerNode, accumulator);\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(viewCache, ackPath, changedChildren, writesCache, completeCache,\n          filterServerNode, accumulator);\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function (mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n        }\n      });\n      return this.applyServerMerge_(viewCache, ackPath, changedChildren, writesCache, completeCache,\n        filterServerNode, accumulator);\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(viewCache: ViewCache, path: Path, writesCache: WriteTreeRef,\n                          accumulator: ChildChangeAccumulator): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n    return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache,\n      NO_COMPLETE_CHILD_SOURCE, accumulator);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(viewCache: ViewCache, path: Path, writesCache: WriteTreeRef, completeServerCache: Node | null,\n                           accumulator: ChildChangeAccumulator): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node');\n          newNode = writesCache.calcCompleteEventChildren(serverChildren as ChildrenNode);\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n        if (newChild == null && viewCache.getServerCache().isCompleteForChild(childKey)) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source,\n            accumulator);\n        } else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(),\n            source, accumulator);\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n          }\n        }\n      }\n      complete = viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n    }\n  }\n}\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '../../../utils/assert';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport { WriteTreeCompleteChildSource, NO_COMPLETE_CHILD_SOURCE } from './CompleteChildSource';\n/**\n * @constructor\n * @struct\n */\nvar ProcessorResult = (function () {\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Array.<!Change>} changes\n     */\n    function ProcessorResult(viewCache, changes) {\n        this.viewCache = viewCache;\n        this.changes = changes;\n    }\n    return ProcessorResult;\n}());\nexport { ProcessorResult };\n/**\n * @constructor\n */\nvar ViewProcessor = (function () {\n    /**\n     * @param {!NodeFilter} filter_\n     */\n    function ViewProcessor(filter_) {\n        this.filter_ = filter_;\n    }\n    /**\n     * @param {!ViewCache} viewCache\n     */\n    ViewProcessor.prototype.assertIndexed = function (viewCache) {\n        assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n        assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Operation} operation\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @return {!ProcessorResult}\n     */\n    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n        var accumulator = new ChildChangeAccumulator();\n        var newViewCache, filterServerNode;\n        if (operation.type === OperationType.OVERWRITE) {\n            var overwrite = operation;\n            if (overwrite.source.fromUser) {\n                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n            }\n            else {\n                assert(overwrite.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered  and the\n                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n                // again\n                filterServerNode = overwrite.source.tagged ||\n                    (oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty());\n                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.MERGE) {\n            var merge = operation;\n            if (merge.source.fromUser) {\n                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n            }\n            else {\n                assert(merge.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered\n                filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.ACK_USER_WRITE) {\n            var ackUserWrite = operation;\n            if (!ackUserWrite.revert) {\n                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n            }\n            else {\n                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n            }\n        }\n        else if (operation.type === OperationType.LISTEN_COMPLETE) {\n            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n        }\n        else {\n            throw assertionError('Unknown operation type: ' + operation.type);\n        }\n        var changes = accumulator.getChanges();\n        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n        return new ProcessorResult(newViewCache, changes);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!ViewCache} newViewCache\n     * @param {!Array.<!Change>} accumulator\n     * @private\n     */\n    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n        var eventSnap = newViewCache.getEventCache();\n        if (eventSnap.isFullyInitialized()) {\n            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n            if (accumulator.length > 0 ||\n                !oldViewCache.getEventCache().isFullyInitialized() ||\n                (isLeafOrEmpty && !eventSnap.getNode().equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n                !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n                accumulator.push(Change.valueChange(\n                /** @type {!Node} */ (newViewCache.getCompleteEventSnap())));\n            }\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} changePath\n     * @param {!WriteTreeRef} writesCache\n     * @param {!CompleteChildSource} source\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n        var oldEventSnap = viewCache.getEventCache();\n        if (writesCache.shadowingWrite(changePath) != null) {\n            // we have a shadowing write, ignore changes\n            return viewCache;\n        }\n        else {\n            var newEventCache = void 0, serverNode = void 0;\n            if (changePath.isEmpty()) {\n                // TODO: figure out how this plays with \"sliding ack windows\"\n                assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n                if (viewCache.getServerCache().isFiltered()) {\n                    // We need to special case this, because we need to only apply writes to complete children, or\n                    // we might end up raising events for incomplete children. If the server data is filtered deep\n                    // writes cannot be guaranteed to be complete\n                    var serverCache = viewCache.getCompleteServerSnap();\n                    var completeChildren = (serverCache instanceof ChildrenNode) ? serverCache :\n                        ChildrenNode.EMPTY_NODE;\n                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n                }\n                else {\n                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n                }\n            }\n            else {\n                var childKey = changePath.getFront();\n                if (childKey == '.priority') {\n                    assert(changePath.getLength() == 1, 'Can\\'t have a priority with additional path components');\n                    var oldEventNode = oldEventSnap.getNode();\n                    serverNode = viewCache.getServerCache().getNode();\n                    // we might have overwrites for this priority\n                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n                    if (updatedPriority != null) {\n                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n                    }\n                    else {\n                        // priority didn't change, keep old node\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n                else {\n                    var childChangePath = changePath.popFront();\n                    // update child\n                    var newEventChild = void 0;\n                    if (oldEventSnap.isCompleteForChild(childKey)) {\n                        serverNode = viewCache.getServerCache().getNode();\n                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n                        if (eventChildUpdate != null) {\n                            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n                        }\n                        else {\n                            // Nothing changed, just keep the old child\n                            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                        }\n                    }\n                    else {\n                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                    }\n                    if (newEventChild != null) {\n                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                    }\n                    else {\n                        // no complete child available or no change\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n            }\n            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n        }\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n        var oldServerSnap = oldViewCache.getServerCache();\n        var newServerCache;\n        var serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();\n        if (changePath.isEmpty()) {\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n        }\n        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n            var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) {\n                // We don't update incomplete nodes with updates intended for other listeners\n                return oldViewCache;\n            }\n            var childChangePath = changePath.popFront();\n            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n            var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n            if (childKey == '.priority') {\n                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n            }\n            else {\n                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\n            }\n        }\n        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n        var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n        var oldEventSnap = oldViewCache.getEventCache();\n        var newViewCache, newEventCache;\n        var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n        if (changePath.isEmpty()) {\n            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (childKey === '.priority') {\n                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n            }\n            else {\n                var childChangePath = changePath.popFront();\n                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                var newChild = void 0;\n                if (childChangePath.isEmpty()) {\n                    // Child overwrite, we can replace the child\n                    newChild = changedSnap;\n                }\n                else {\n                    var childNode = source.getCompleteChild(childKey);\n                    if (childNode != null) {\n                        if (childChangePath.getBack() === '.priority' &&\n                            childNode.getChild(childChangePath.parent()).isEmpty()) {\n                            // This is a priority update on an empty node. If this node exists on the server, the\n                            // server will send down the priority in the update, so ignore for now\n                            newChild = childNode;\n                        }\n                        else {\n                            newChild = childNode.updateChild(childChangePath, changedSnap);\n                        }\n                    }\n                    else {\n                        // There is no complete child node available\n                        newChild = ChildrenNode.EMPTY_NODE;\n                    }\n                }\n                if (!oldChild.equals(newChild)) {\n                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n                }\n                else {\n                    newViewCache = oldViewCache;\n                }\n            }\n        }\n        return newViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {string} childKey\n     * @return {boolean}\n     * @private\n     */\n    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n        return viewCache.getEventCache().isCompleteForChild(childKey);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n        var _this = this;\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!Node} node\n     * @param {ImmutableTree.<!Node>} merge\n     * @return {!Node}\n     * @private\n     */\n    ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n        merge.foreach(function (relativePath, childNode) {\n            node = node.updateChild(relativePath, childNode);\n        });\n        return node;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n        var _this = this;\n        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n        // wait for the complete data update coming soon.\n        if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) {\n            return viewCache;\n        }\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        var viewMergeTree;\n        if (path.isEmpty()) {\n            viewMergeTree = changedChildren;\n        }\n        else {\n            viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n        }\n        var serverNode = viewCache.getServerCache().getNode();\n        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n            if (serverNode.hasChild(childKey)) {\n                var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey)\n                && (childMergeTree.value == null);\n            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n                var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childMergeTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} ackPath\n     * @param {!ImmutableTree<!boolean>} affectedTree\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n        if (writesCache.shadowingWrite(ackPath) != null) {\n            return viewCache;\n        }\n        // Only filter server node if it is currently filtered\n        var filterServerNode = viewCache.getServerCache().isFiltered();\n        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n        // now that it won't be shadowed.\n        var serverCache = viewCache.getServerCache();\n        if (affectedTree.value != null) {\n            // This is an overwrite.\n            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) || serverCache.isCompleteForPath(ackPath)) {\n                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else if (ackPath.isEmpty()) {\n                // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n                // should just re-apply whatever we have in our cache as a merge.\n                var changedChildren_1 = ImmutableTree.Empty;\n                serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) {\n                    changedChildren_1 = changedChildren_1.set(new Path(name), node);\n                });\n                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else {\n                return viewCache;\n            }\n        }\n        else {\n            // This is a merge.\n            var changedChildren_2 = ImmutableTree.Empty;\n            affectedTree.foreach(function (mergePath, value) {\n                var serverCachePath = ackPath.child(mergePath);\n                if (serverCache.isCompleteForPath(serverCachePath)) {\n                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n                }\n            });\n            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n        var oldServerNode = viewCache.getServerCache();\n        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeServerCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n        var complete;\n        if (writesCache.shadowingWrite(path) != null) {\n            return viewCache;\n        }\n        else {\n            var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n            var oldEventCache = viewCache.getEventCache().getNode();\n            var newEventCache = void 0;\n            if (path.isEmpty() || path.getFront() === '.priority') {\n                var newNode = void 0;\n                if (viewCache.getServerCache().isFullyInitialized()) {\n                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                }\n                else {\n                    var serverChildren = viewCache.getServerCache().getNode();\n                    assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');\n                    newNode = writesCache.calcCompleteEventChildren(serverChildren);\n                }\n                newNode = newNode;\n                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n            }\n            else {\n                var childKey = path.getFront();\n                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                if (newChild == null && viewCache.getServerCache().isCompleteForChild(childKey)) {\n                    newChild = oldEventCache.getImmediateChild(childKey);\n                }\n                if (newChild != null) {\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n                }\n                else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n                    // No complete child available, delete the existing one, if any\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n                }\n                else {\n                    newEventCache = oldEventCache;\n                }\n                if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {\n                    // We might have reverted all child writes. Maybe the old event was a leaf node\n                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    if (complete.isLeafNode()) {\n                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n                    }\n                }\n            }\n            complete = viewCache.getServerCache().isFullyInitialized() ||\n                writesCache.shadowingWrite(Path.Empty) != null;\n            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n        }\n    };\n    return ViewProcessor;\n}());\nexport { ViewProcessor };\n\n\n"]}