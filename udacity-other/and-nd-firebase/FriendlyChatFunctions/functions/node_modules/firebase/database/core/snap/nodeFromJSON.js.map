{"version":3,"sources":["database/src/database/core/snap/nodeFromJSON.ts"],"names":["nodeFromJSON","USE_HINZE","json","priority","EMPTY_NODE","jsonLeaf","Array","children_1","childrenHavePriority_1","hinzeJsonObj_1","key","child","substring","childNode","isEmpty","getPriority","push","length","childSet","namedNode","name","sortedChildSet","getCompare","Default","node_1","jsonObj_1","childData","isLeafNode","updateImmediateChild","updatePriority"],"mappings":"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","file":"nodeFromJSON.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { ChildrenNode } from './ChildrenNode';\nimport { LeafNode } from './LeafNode';\nimport { NamedNode, Node } from './Node';\nimport { forEach, contains } from '../../../utils/obj';\nimport { assert } from '../../../utils/assert';\nimport { buildChildSet } from './childSet';\nimport { NAME_COMPARATOR, NAME_ONLY_COMPARATOR } from './comparators';\nimport { IndexMap } from './IndexMap';\nimport { PRIORITY_INDEX, setNodeFromJSON } from './indexes/PriorityIndex';\nimport { SortedMap } from '../util/SortedMap';\n\nconst USE_HINZE = true;\n\n/**\n * Constructs a snapshot node representing the passed JSON and returns it.\n * @param {*} json JSON to create a node for.\n * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the\n * passed JSON contains a .priority property.\n * @return {!Node}\n */\nexport function nodeFromJSON(json: any | null,\n                             priority: string | number | null = null): Node {\n  if (json === null) {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  if (typeof json === 'object' && '.priority' in json) {\n    priority = json['.priority'];\n  }\n\n  assert(\n    priority === null ||\n    typeof priority === 'string' ||\n    typeof priority === 'number' ||\n    (typeof priority === 'object' && '.sv' in (priority as object)),\n    'Invalid priority type found: ' + (typeof priority)\n  );\n\n  if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\n    json = json['.value'];\n  }\n\n  // Valid leaf nodes include non-objects or server-value wrapper objects\n  if (typeof json !== 'object' || '.sv' in json) {\n    const jsonLeaf = json as string | number | boolean | object;\n    return new LeafNode(jsonLeaf, nodeFromJSON(priority));\n  }\n\n  if (!(json instanceof Array) && USE_HINZE) {\n    const children: NamedNode[] = [];\n    let childrenHavePriority = false;\n    const hinzeJsonObj: { [k: string]: any } = json as object;\n    forEach(hinzeJsonObj, (key: string, child: any) => {\n      if (typeof key !== 'string' || key.substring(0, 1) !== '.') { // Ignore metadata nodes\n        const childNode = nodeFromJSON(hinzeJsonObj[key]);\n        if (!childNode.isEmpty()) {\n          childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();\n          children.push(new NamedNode(key, childNode));\n        }\n      }\n    });\n\n    if (children.length == 0) {\n      return ChildrenNode.EMPTY_NODE;\n    }\n\n    const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR,\n      (namedNode) => namedNode.name, NAME_COMPARATOR) as SortedMap<string, Node>;\n    if (childrenHavePriority) {\n      const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\n      return new ChildrenNode(childSet, nodeFromJSON(priority),\n        new IndexMap({'.priority': sortedChildSet}, {'.priority': PRIORITY_INDEX}));\n    } else {\n      return new ChildrenNode(childSet, nodeFromJSON(priority),\n        IndexMap.Default);\n    }\n  } else {\n    let node: Node = ChildrenNode.EMPTY_NODE;\n    const jsonObj = json as object;\n    forEach(jsonObj, (key: string, childData: any) => {\n      if (contains(jsonObj, key)) {\n        if (key.substring(0, 1) !== '.') { // ignore metadata nodes.\n          const childNode = nodeFromJSON(childData);\n          if (childNode.isLeafNode() || !childNode.isEmpty())\n            node = node.updateImmediateChild(key, childNode);\n        }\n      }\n    });\n\n    return node.updatePriority(nodeFromJSON(priority));\n  }\n}\n\nsetNodeFromJSON(nodeFromJSON);"]}