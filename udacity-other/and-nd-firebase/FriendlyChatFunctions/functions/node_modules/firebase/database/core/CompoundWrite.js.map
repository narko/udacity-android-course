{"version":3,"sources":["src/database/core/CompoundWrite.ts","database/core/CompoundWrite.js"],"names":["CompoundWrite","writeTree_","prototype","addWrite","path","node","isEmpty","rootmost","findRootMostValueAndPath","rootMostPath","value","relativePath","updateChild","set","subtree","newWriteTree","setTree","addWrites","updates","newWrite","childKey","child","removeWrite","Empty","hasCompleteWrite","getCompleteNode","get","getChild","getCompleteChildren","children","isLeafNode","forEachChild","childName","childNode","push","inorderTraversal","childTree","childCompoundWrite","shadowingNode","apply","applySubtreeWrite_","writeTree","priorityWrite_1"],"mappings":"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","file":"CompoundWrite.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { ImmutableTree } from \"./util/ImmutableTree\";\nimport { Path } from \"./util/Path\";\nimport { forEach } from \"../../utils/obj\";\nimport { Node, NamedNode } from \"./snap/Node\";\nimport { PRIORITY_INDEX } from \"./snap/indexes/PriorityIndex\";\nimport { assert } from \"../../utils/assert\";\nimport { ChildrenNode } from './snap/ChildrenNode';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {};\n  /**\n   * @type {!CompoundWrite}\n   */\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    forEach(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_.get(rootmost.path).getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  getCompleteChildren(): Array<NamedNode> {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(childName, childNode) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  private static applySubtreeWrite_ = function(relativePath: Path, writeTree: ImmutableTree<Node>, node: Node): Node {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      let priorityWrite = null;\n      writeTree.children.inorderTraversal(function(childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\n          priorityWrite = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n      }\n      return node;\n    }\n  }\n}\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { ImmutableTree } from \"./util/ImmutableTree\";\nimport { Path } from \"./util/Path\";\nimport { forEach } from \"../../utils/obj\";\nimport { NamedNode } from \"./snap/Node\";\nimport { PRIORITY_INDEX } from \"./snap/indexes/PriorityIndex\";\nimport { assert } from \"../../utils/assert\";\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nvar CompoundWrite = (function () {\n    function CompoundWrite(writeTree_) {\n        this.writeTree_ = writeTree_;\n    }\n    ;\n    /**\n     * @param {!Path} path\n     * @param {!Node} node\n     * @return {!CompoundWrite}\n     */\n    CompoundWrite.prototype.addWrite = function (path, node) {\n        if (path.isEmpty()) {\n            return new CompoundWrite(new ImmutableTree(node));\n        }\n        else {\n            var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n            if (rootmost != null) {\n                var rootMostPath = rootmost.path;\n                var value = rootmost.value;\n                var relativePath = Path.relativePath(rootMostPath, path);\n                value = value.updateChild(relativePath, node);\n                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n            }\n            else {\n                var subtree = new ImmutableTree(node);\n                var newWriteTree = this.writeTree_.setTree(path, subtree);\n                return new CompoundWrite(newWriteTree);\n            }\n        }\n    };\n    /**\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} updates\n     * @return {!CompoundWrite}\n     */\n    CompoundWrite.prototype.addWrites = function (path, updates) {\n        var newWrite = this;\n        forEach(updates, function (childKey, node) {\n            newWrite = newWrite.addWrite(path.child(childKey), node);\n        });\n        return newWrite;\n    };\n    /**\n     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n     * location, which must be removed by calling this method with that path.\n     *\n     * @param {!Path} path The path at which a write and all deeper writes should be removed\n     * @return {!CompoundWrite} The new CompoundWrite with the removed path\n     */\n    CompoundWrite.prototype.removeWrite = function (path) {\n        if (path.isEmpty()) {\n            return CompoundWrite.Empty;\n        }\n        else {\n            var newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n            return new CompoundWrite(newWriteTree);\n        }\n    };\n    /**\n     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n     * considered \"complete\".\n     *\n     * @param {!Path} path The path to check for\n     * @return {boolean} Whether there is a complete write at that path\n     */\n    CompoundWrite.prototype.hasCompleteWrite = function (path) {\n        return this.getCompleteNode(path) != null;\n    };\n    /**\n     * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n     * writes from deeper paths, but will return child nodes from a more shallow path.\n     *\n     * @param {!Path} path The path to get a complete write\n     * @return {?Node} The node if complete at that path, or null otherwise.\n     */\n    CompoundWrite.prototype.getCompleteNode = function (path) {\n        var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n        if (rootmost != null) {\n            return this.writeTree_.get(rootmost.path).getChild(Path.relativePath(rootmost.path, path));\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Returns all children that are guaranteed to be a complete overwrite.\n     *\n     * @return {!Array.<NamedNode>} A list of all complete children.\n     */\n    CompoundWrite.prototype.getCompleteChildren = function () {\n        var children = [];\n        var node = this.writeTree_.value;\n        if (node != null) {\n            // If it's a leaf node, it has no children; so nothing to do.\n            if (!node.isLeafNode()) {\n                node.forEachChild(PRIORITY_INDEX, function (childName, childNode) {\n                    children.push(new NamedNode(childName, childNode));\n                });\n            }\n        }\n        else {\n            this.writeTree_.children.inorderTraversal(function (childName, childTree) {\n                if (childTree.value != null) {\n                    children.push(new NamedNode(childName, childTree.value));\n                }\n            });\n        }\n        return children;\n    };\n    /**\n     * @param {!Path} path\n     * @return {!CompoundWrite}\n     */\n    CompoundWrite.prototype.childCompoundWrite = function (path) {\n        if (path.isEmpty()) {\n            return this;\n        }\n        else {\n            var shadowingNode = this.getCompleteNode(path);\n            if (shadowingNode != null) {\n                return new CompoundWrite(new ImmutableTree(shadowingNode));\n            }\n            else {\n                return new CompoundWrite(this.writeTree_.subtree(path));\n            }\n        }\n    };\n    /**\n     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n     * @return {boolean} Whether this CompoundWrite is empty\n     */\n    CompoundWrite.prototype.isEmpty = function () {\n        return this.writeTree_.isEmpty();\n    };\n    /**\n     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n     * node\n     * @param {!Node} node The node to apply this CompoundWrite to\n     * @return {!Node} The node with all writes applied\n     */\n    CompoundWrite.prototype.apply = function (node) {\n        return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n    };\n    return CompoundWrite;\n}());\nexport { CompoundWrite };\n/**\n * @type {!CompoundWrite}\n */\nCompoundWrite.Empty = new CompoundWrite(new ImmutableTree(null));\n/**\n * @param {!Path} relativePath\n * @param {!ImmutableTree.<!Node>} writeTree\n * @param {!Node} node\n * @return {!Node}\n * @private\n */\nCompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n        // Since there a write is always a leaf, we're done here\n        return node.updateChild(relativePath, writeTree.value);\n    }\n    else {\n        var priorityWrite_1 = null;\n        writeTree.children.inorderTraversal(function (childKey, childTree) {\n            if (childKey === '.priority') {\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n                // to apply priorities to empty nodes that are later filled\n                assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\n                priorityWrite_1 = childTree.value;\n            }\n            else {\n                node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);\n            }\n        });\n        // If there was a priority write, we only apply it if the node is not empty\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {\n            node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);\n        }\n        return node;\n    }\n};\n\n\n"]}