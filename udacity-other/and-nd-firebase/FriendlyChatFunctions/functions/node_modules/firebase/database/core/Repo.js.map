{"version":3,"sources":["src/database/core/Repo.ts","database/core/Repo.js"],"names":["INTERRUPT_REASON","Repo","repoInfo_","forceRestClient","app","_this","dataUpdateCount","statsListener_","eventQueue_","nextWriteId_","interceptServerDataCallback_","onDisconnect_","persistentConnection_","authTokenProvider","stats_","getCollection","server_","onDataUpdate_","bind","setTimeout","onConnectStatus_","authOverride","options","Error","e","onServerInfoUpdate_","addTokenChangeListener","token","refreshAuthToken","statsReporter_","getOrCreateReporter","transactions_init_","infoData_","infoSyncTree_","startListening","query","tag","currentHashFn","onComplete","infoEvents","node","getNode","path","isEmpty","applyServerOverwrite","stopListening","updateInfo_","serverSyncTree_","listen","status","data","events","raiseEventsForChangedPath","unlisten","prototype","toString","secure","host","name","namespace","serverTime","offsetNode","offset","val","Date","getTime","generateServerValues","pathString","isMerge","taggedChildren","raw","applyTaggedQueryMerge","taggedSnap","applyTaggedQueryOverwrite","changedChildren","applyServerMerge","snap","affectedPath","length","rerunTransactions_","interceptServerData_","callback","connectStatus","runOnDisconnectEvents_","updates","value","key","newNode","updateSnapshot","getNextWriteId_","setWithPriority","newVal","newPriority","log_","priority","serverValues","newNodeUnresolved","writeId","applyUserOverwrite","queueEvents","put","errorReason","success","clearEvents","ackUserWrite","callOnCompleteCallback","abortTransactions_","update","childrenToMerge","empty","changedKey","changedValue","writeId_1","applyUserMerge","merge","changedPath","child","resolvedOnDisconnectTree","forEachTree","Empty","concat","onDisconnectCancel","forget","onDisconnectSet","onDisconnectPut","remember","onDisconnectSetWithPriority","onDisconnectUpdate","onDisconnectMerge","childName","childNode","newChildNode","addEventCallbackForQuery","eventRegistration","getFront","addEventRegistration","raiseEventsAtPath","removeEventCallbackForQuery","removeEventRegistration","interrupt","resume","stats","showDelta","console","get","longestName","Object","keys","reduce","previousValue","currentValue","Math","max","stat","i","log","statsIncrementCounter","metric","incrementCounter","includeStat","var_args","_i","arguments","prefix","id","apply","code","toUpperCase","message","error","defineProperty","__database","enumerable","configurable"],"mappings":"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","file":"Repo.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '../../utils/json';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '../../utils/obj';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '../../app/firebase_app';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_: ((a: string, b: any) => void) | null = null;\n  private __database: Database;\n\n  // A list of data pieces and paths to be set when this client disconnects.\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @type {?PersistentConnection}\n   */\n  persistentConnection_: PersistentConnection | null = null;\n\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  constructor(private repoInfo_: RepoInfo, forceRestClient: boolean, public app: FirebaseApp) {\n    /** @type {!AuthTokenProvider} */\n    const authTokenProvider = new AuthTokenProvider(app);\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider);\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride);\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener((token) => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_));\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(query.path, node);\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host;\n  }\n\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(new Path('.info/serverTimeOffset'));\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      'timestamp': this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  private onDataUpdate_(pathString: string, data: any, isMerge: boolean, tag: number | null) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) => nodeFromJSON(raw));\n        events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) => nodeFromJSON(raw));\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (value: any, key: string) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  /**\n   * @return {!number}\n   * @private\n   */\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  setWithPriority(path: Path, newVal: any,\n                  newPriority: number | string | null,\n                  onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    this.log_('set', {path: path.toString(), value: newVal, priority: newPriority});\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/true), (status, errorReason) => {\n      const success = status === 'ok';\n      if (!success) {\n        warn('set at ' + path + ' failed: ' + status);\n      }\n\n      const clearEvents = this.serverSyncTree_.ackUserWrite(writeId, !success);\n      this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  update(path: Path, childrenToMerge: { [k: string]: any },\n         onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    this.log_('update', {path: path.toString(), value: childrenToMerge});\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    forEach(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId);\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('update at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(writeId, !success);\n        const affectedPath = (clearEvents.length > 0) ? this.rerunTransactions_(path) : path;\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      });\n\n      forEach(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log('update() called with empty data.  Don\\'t do anything.');\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(this.onDisconnect_, serverValues);\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(this.serverSyncTree_.applyServerOverwrite(path, snap));\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectCancel(path: Path, onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSet(path: Path, value: any, onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/true), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.remember(path, newNode);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSetWithPriority(path: Path, value: any, priority: any, onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/true), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.remember(path, newNode);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectUpdate(path: Path, childrenToMerge: { [k: string]: any },\n                     onComplete: ((status: Error | null, errorReason?: string) => void) | null) {\n    if (isEmpty(childrenToMerge)) {\n      log('onDisconnect().update() called with empty data.  Don\\'t do anything.');\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => {\n      if (status === 'ok') {\n        forEach(childrenToMerge, (childName: string, childNode: any) => {\n          const newChildNode = nodeFromJSON(childNode);\n          this.onDisconnect_.remember(path.child(childName), newChildNode);\n        });\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  removeEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined')\n      return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) => Math.max(currentValue.length, previousValue), 0);\n\n    forEach(stats, (stat: string, value: any) => {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++)\n        stat += ' ';\n      console.log(stat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  callOnCompleteCallback(callback: ((status: Error | null, errorReason?: string) => void) | null,\n                         status: string, errorReason?: string | null) {\n    if (callback) {\n      exceptionGuard(function () {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason)\n            message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { generateWithValues, resolveDeferredValueSnapshot, resolveDeferredValueTree } from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '../../utils/json';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '../../utils/obj';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { Database } from '../api/Database';\nvar INTERRUPT_REASON = 'repo_interrupt';\n/**\n * A connection to a single data repository.\n */\nvar Repo = (function () {\n    /**\n     * @param {!RepoInfo} repoInfo_\n     * @param {boolean} forceRestClient\n     * @param {!FirebaseApp} app\n     */\n    function Repo(repoInfo_, forceRestClient, app) {\n        var _this = this;\n        this.repoInfo_ = repoInfo_;\n        this.app = app;\n        this.dataUpdateCount = 0;\n        this.statsListener_ = null;\n        this.eventQueue_ = new EventQueue();\n        this.nextWriteId_ = 1;\n        this.interceptServerDataCallback_ = null;\n        // A list of data pieces and paths to be set when this client disconnects.\n        this.onDisconnect_ = new SparseSnapshotTree();\n        /**\n         * TODO: This should be @private but it's used by test_access.js and internal.js\n         * @type {?PersistentConnection}\n         */\n        this.persistentConnection_ = null;\n        /** @type {!AuthTokenProvider} */\n        var authTokenProvider = new AuthTokenProvider(app);\n        this.stats_ = StatsManager.getCollection(repoInfo_);\n        if (forceRestClient || beingCrawled()) {\n            this.server_ = new ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);\n            // Minor hack: Fire onConnect immediately, since there's no actual connection.\n            setTimeout(this.onConnectStatus_.bind(this, true), 0);\n        }\n        else {\n            var authOverride = app.options['databaseAuthVariableOverride'];\n            // Validate authOverride\n            if (typeof authOverride !== 'undefined' && authOverride !== null) {\n                if (typeof authOverride !== 'object') {\n                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n                }\n                try {\n                    stringify(authOverride);\n                }\n                catch (e) {\n                    throw new Error('Invalid authOverride provided: ' + e);\n                }\n            }\n            this.persistentConnection_ = new PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\n            this.server_ = this.persistentConnection_;\n        }\n        authTokenProvider.addTokenChangeListener(function (token) {\n            _this.server_.refreshAuthToken(token);\n        });\n        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n        this.statsReporter_ = StatsManager.getOrCreateReporter(repoInfo_, function () { return new StatsReporter(_this.stats_, _this.server_); });\n        this.transactions_init_();\n        // Used for .info.\n        this.infoData_ = new SnapshotHolder();\n        this.infoSyncTree_ = new SyncTree({\n            startListening: function (query, tag, currentHashFn, onComplete) {\n                var infoEvents = [];\n                var node = _this.infoData_.getNode(query.path);\n                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n                // on initial data...\n                if (!node.isEmpty()) {\n                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\n                    setTimeout(function () {\n                        onComplete('ok');\n                    }, 0);\n                }\n                return infoEvents;\n            },\n            stopListening: function () { }\n        });\n        this.updateInfo_('connected', false);\n        this.serverSyncTree_ = new SyncTree({\n            startListening: function (query, tag, currentHashFn, onComplete) {\n                _this.server_.listen(query, currentHashFn, tag, function (status, data) {\n                    var events = onComplete(status, data);\n                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n                });\n                // No synchronous events for network-backed sync trees\n                return [];\n            },\n            stopListening: function (query, tag) {\n                _this.server_.unlisten(query, tag);\n            }\n        });\n    }\n    /**\n     * @return {string}  The URL corresponding to the root of this Firebase.\n     */\n    Repo.prototype.toString = function () {\n        return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host;\n    };\n    /**\n     * @return {!string} The namespace represented by the repo.\n     */\n    Repo.prototype.name = function () {\n        return this.repoInfo_.namespace;\n    };\n    /**\n     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n     */\n    Repo.prototype.serverTime = function () {\n        var offsetNode = this.infoData_.getNode(new Path('.info/serverTimeOffset'));\n        var offset = offsetNode.val() || 0;\n        return new Date().getTime() + offset;\n    };\n    /**\n     * Generate ServerValues using some variables from the repo object.\n     * @return {!Object}\n     */\n    Repo.prototype.generateServerValues = function () {\n        return generateWithValues({\n            'timestamp': this.serverTime()\n        });\n    };\n    /**\n     * Called by realtime when we get new messages from the server.\n     *\n     * @private\n     * @param {string} pathString\n     * @param {*} data\n     * @param {boolean} isMerge\n     * @param {?number} tag\n     */\n    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\n        // For testing.\n        this.dataUpdateCount++;\n        var path = new Path(pathString);\n        data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;\n        var events = [];\n        if (tag) {\n            if (isMerge) {\n                var taggedChildren = map(data, function (raw) { return nodeFromJSON(raw); });\n                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n            }\n            else {\n                var taggedSnap = nodeFromJSON(data);\n                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n            }\n        }\n        else if (isMerge) {\n            var changedChildren = map(data, function (raw) { return nodeFromJSON(raw); });\n            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n        }\n        else {\n            var snap = nodeFromJSON(data);\n            events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n        }\n        var affectedPath = path;\n        if (events.length > 0) {\n            // Since we have a listener outstanding for each transaction, receiving any events\n            // is a proxy for some change having occurred.\n            affectedPath = this.rerunTransactions_(path);\n        }\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n    };\n    /**\n     * TODO: This should be @private but it's used by test_access.js and internal.js\n     * @param {?function(!string, *):*} callback\n     * @private\n     */\n    Repo.prototype.interceptServerData_ = function (callback) {\n        this.interceptServerDataCallback_ = callback;\n    };\n    /**\n     * @param {!boolean} connectStatus\n     * @private\n     */\n    Repo.prototype.onConnectStatus_ = function (connectStatus) {\n        this.updateInfo_('connected', connectStatus);\n        if (connectStatus === false) {\n            this.runOnDisconnectEvents_();\n        }\n    };\n    /**\n     * @param {!Object} updates\n     * @private\n     */\n    Repo.prototype.onServerInfoUpdate_ = function (updates) {\n        var _this = this;\n        each(updates, function (value, key) {\n            _this.updateInfo_(key, value);\n        });\n    };\n    /**\n     *\n     * @param {!string} pathString\n     * @param {*} value\n     * @private\n     */\n    Repo.prototype.updateInfo_ = function (pathString, value) {\n        var path = new Path('/.info/' + pathString);\n        var newNode = nodeFromJSON(value);\n        this.infoData_.updateSnapshot(path, newNode);\n        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n    };\n    /**\n     * @return {!number}\n     * @private\n     */\n    Repo.prototype.getNextWriteId_ = function () {\n        return this.nextWriteId_++;\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} newVal\n     * @param {number|string|null} newPriority\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\n        var _this = this;\n        this.log_('set', { path: path.toString(), value: newVal, priority: newPriority });\n        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n        // (b) store unresolved paths on JSON parse\n        var serverValues = this.generateServerValues();\n        var newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n        var writeId = this.getNextWriteId_();\n        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n        this.eventQueue_.queueEvents(events);\n        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {\n            var success = status === 'ok';\n            if (!success) {\n                warn('set at ' + path + ' failed: ' + status);\n            }\n            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\n            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n        var affectedPath = this.abortTransactions_(path);\n        this.rerunTransactions_(affectedPath);\n        // We queued the events above, so just flush the queue here\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n    };\n    /**\n     * @param {!Path} path\n     * @param {!Object} childrenToMerge\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.update = function (path, childrenToMerge, onComplete) {\n        var _this = this;\n        this.log_('update', { path: path.toString(), value: childrenToMerge });\n        // Start with our existing data and merge each child into it.\n        var empty = true;\n        var serverValues = this.generateServerValues();\n        var changedChildren = {};\n        forEach(childrenToMerge, function (changedKey, changedValue) {\n            empty = false;\n            var newNodeUnresolved = nodeFromJSON(changedValue);\n            changedChildren[changedKey] = resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n        });\n        if (!empty) {\n            var writeId_1 = this.getNextWriteId_();\n            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\n            this.eventQueue_.queueEvents(events);\n            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\n                var success = status === 'ok';\n                if (!success) {\n                    warn('update at ' + path + ' failed: ' + status);\n                }\n                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\n                var affectedPath = (clearEvents.length > 0) ? _this.rerunTransactions_(path) : path;\n                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n                _this.callOnCompleteCallback(onComplete, status, errorReason);\n            });\n            forEach(childrenToMerge, function (changedPath) {\n                var affectedPath = _this.abortTransactions_(path.child(changedPath));\n                _this.rerunTransactions_(affectedPath);\n            });\n            // We queued the events above, so just flush the queue here\n            this.eventQueue_.raiseEventsForChangedPath(path, []);\n        }\n        else {\n            log('update() called with empty data.  Don\\'t do anything.');\n            this.callOnCompleteCallback(onComplete, 'ok');\n        }\n    };\n    /**\n     * Applies all of the changes stored up in the onDisconnect_ tree.\n     * @private\n     */\n    Repo.prototype.runOnDisconnectEvents_ = function () {\n        var _this = this;\n        this.log_('onDisconnectEvents');\n        var serverValues = this.generateServerValues();\n        var resolvedOnDisconnectTree = resolveDeferredValueTree(this.onDisconnect_, serverValues);\n        var events = [];\n        resolvedOnDisconnectTree.forEachTree(Path.Empty, function (path, snap) {\n            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\n            var affectedPath = _this.abortTransactions_(path);\n            _this.rerunTransactions_(affectedPath);\n        });\n        this.onDisconnect_ = new SparseSnapshotTree();\n        this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n    };\n    /**\n     * @param {!Path} path\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectCancel = function (path, onComplete) {\n        var _this = this;\n        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.forget(path);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} value\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\n        var _this = this;\n        var newNode = nodeFromJSON(value);\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.remember(path, newNode);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} value\n     * @param {*} priority\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\n        var _this = this;\n        var newNode = nodeFromJSON(value, priority);\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\n            if (status === 'ok') {\n                _this.onDisconnect_.remember(path, newNode);\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Path} path\n     * @param {*} childrenToMerge\n     * @param {?function(?Error, *=)} onComplete\n     */\n    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\n        var _this = this;\n        if (isEmpty(childrenToMerge)) {\n            log('onDisconnect().update() called with empty data.  Don\\'t do anything.');\n            this.callOnCompleteCallback(onComplete, 'ok');\n            return;\n        }\n        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\n            if (status === 'ok') {\n                forEach(childrenToMerge, function (childName, childNode) {\n                    var newChildNode = nodeFromJSON(childNode);\n                    _this.onDisconnect_.remember(path.child(childName), newChildNode);\n                });\n            }\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\n        });\n    };\n    /**\n     * @param {!Query} query\n     * @param {!EventRegistration} eventRegistration\n     */\n    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\n        var events;\n        if (query.path.getFront() === '.info') {\n            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n        }\n        else {\n            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n        }\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\n    };\n    /**\n     * @param {!Query} query\n     * @param {?EventRegistration} eventRegistration\n     */\n    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\n        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n        // a little bit by handling the return values anyways.\n        var events;\n        if (query.path.getFront() === '.info') {\n            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n        }\n        else {\n            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n        }\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\n    };\n    Repo.prototype.interrupt = function () {\n        if (this.persistentConnection_) {\n            this.persistentConnection_.interrupt(INTERRUPT_REASON);\n        }\n    };\n    Repo.prototype.resume = function () {\n        if (this.persistentConnection_) {\n            this.persistentConnection_.resume(INTERRUPT_REASON);\n        }\n    };\n    Repo.prototype.stats = function (showDelta) {\n        if (showDelta === void 0) { showDelta = false; }\n        if (typeof console === 'undefined')\n            return;\n        var stats;\n        if (showDelta) {\n            if (!this.statsListener_)\n                this.statsListener_ = new StatsListener(this.stats_);\n            stats = this.statsListener_.get();\n        }\n        else {\n            stats = this.stats_.get();\n        }\n        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) { return Math.max(currentValue.length, previousValue); }, 0);\n        forEach(stats, function (stat, value) {\n            // pad stat names to be the same length (plus 2 extra spaces).\n            for (var i = stat.length; i < longestName + 2; i++)\n                stat += ' ';\n            console.log(stat + value);\n        });\n    };\n    Repo.prototype.statsIncrementCounter = function (metric) {\n        this.stats_.incrementCounter(metric);\n        this.statsReporter_.includeStat(metric);\n    };\n    /**\n     * @param {...*} var_args\n     * @private\n     */\n    Repo.prototype.log_ = function () {\n        var var_args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            var_args[_i] = arguments[_i];\n        }\n        var prefix = '';\n        if (this.persistentConnection_) {\n            prefix = this.persistentConnection_.id + ':';\n        }\n        log.apply(void 0, [prefix].concat(var_args));\n    };\n    /**\n     * @param {?function(?Error, *=)} callback\n     * @param {!string} status\n     * @param {?string=} errorReason\n     */\n    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\n        if (callback) {\n            exceptionGuard(function () {\n                if (status == 'ok') {\n                    callback(null);\n                }\n                else {\n                    var code = (status || 'error').toUpperCase();\n                    var message = code;\n                    if (errorReason)\n                        message += ': ' + errorReason;\n                    var error = new Error(message);\n                    error.code = code;\n                    callback(error);\n                }\n            });\n        }\n    };\n    Object.defineProperty(Repo.prototype, \"database\", {\n        get: function () {\n            return this.__database || (this.__database = new Database(this));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Repo;\n}());\nexport { Repo };\n\n\n"]}