{"version":3,"sources":["src/database/core/ReadonlyRestClient.ts","database/core/ReadonlyRestClient.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","ReadonlyRestClient","_super","repoInfo_","onDataUpdate_","authTokenProvider_","_this","call","log_","listens_","reportStats","stats","Error","getListenId_","query","tag","undefined","getQueryParams","isDefault","path","toString","listen","currentHashFn","onComplete","pathString","queryIdentifier","listenId","thisListen","queryStringParamaters","toRestQueryStringParameters","restRequest_","error","result","data","status_1","unlisten","refreshAuthToken","token","queryStringParameters","callback","getToken","then","authTokenData","authToken","accessToken","url","secure","host","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","res","e","open","send"],"mappings":"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","file":"ReadonlyRestClient.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '../../utils/json';\nimport { safeGet } from '../../utils/obj';\nimport { querystring } from '../../utils/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: {\n    [k: string]: any;\n  }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(query.getQueryParams().isDefault(), 'should have a tag if it\\'s not a default query.');\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(private repoInfo_: RepoInfo,\n              private onDataUpdate_: (a: string, b: any, c: boolean, d: number | null) => void,\n              private authTokenProvider_: AuthTokenProvider) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(query: Query, currentHashFn: () => string, tag: number | null, onComplete: (a: string, b: any) => void) {\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();\n\n    this.restRequest_(pathString + '.json', queryStringParamaters, (error, result) => {\n      let data = result;\n\n      if (error === 404) {\n        data = null;\n        error = null;\n      }\n\n      if (error === null) {\n        this.onDataUpdate_(pathString, data, /*isMerge=*/false, tag);\n      }\n\n      if (safeGet(this.listens_, listenId) === thisListen) {\n        let status;\n        if (!error) {\n          status = 'ok';\n        } else if (error == 401) {\n          status = 'permission_denied';\n        } else {\n          status = 'rest_error:' + error;\n        }\n\n        onComplete(status, null);\n      }\n    });\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(pathString: string, queryStringParameters: { [k: string]: any } = {},\n                       callback: ((a: number | null, b?: any) => void) | null) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_.getToken(/*forceRefresh=*/false).then((authTokenData) => {\n      const authToken = authTokenData && authTokenData.accessToken;\n      if (authToken) {\n        queryStringParameters['auth'] = authToken;\n      }\n\n      const url = (this.repoInfo_.secure ? 'https://' : 'http://') +\n        this.repoInfo_.host +\n        pathString +\n        '?' +\n        querystring(queryStringParameters);\n\n      this.log_('Sending REST request for ' + url);\n      const xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = () => {\n        if (callback && xhr.readyState === 4) {\n          this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n          let res = null;\n          if (xhr.status >= 200 && xhr.status < 300) {\n            try {\n              res = jsonEval(xhr.responseText);\n            } catch (e) {\n              warn('Failed to parse JSON response for ' + url + ': ' + xhr.responseText);\n            }\n            callback(null, res);\n          } else {\n            // 401 and 404 are expected.\n            if (xhr.status !== 401 && xhr.status !== 404) {\n              warn('Got unsuccessful REST response for ' + url + ' Status: ' + xhr.status);\n            }\n            callback(xhr.status);\n          }\n          callback = null;\n        }\n      };\n\n      xhr.open('GET', url, /*asynchronous=*/true);\n      xhr.send();\n    });\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../../utils/assert';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '../../utils/json';\nimport { safeGet } from '../../utils/obj';\nimport { querystring } from '../../utils/util';\nimport { ServerActions } from './ServerActions';\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nvar ReadonlyRestClient = (function (_super) {\n    __extends(ReadonlyRestClient, _super);\n    /**\n     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n     * @param {AuthTokenProvider} authTokenProvider_\n     * @implements {ServerActions}\n     */\n    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\n        var _this = _super.call(this) || this;\n        _this.repoInfo_ = repoInfo_;\n        _this.onDataUpdate_ = onDataUpdate_;\n        _this.authTokenProvider_ = authTokenProvider_;\n        /** @private {function(...[*])} */\n        _this.log_ = logWrapper('p:rest:');\n        /**\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n         * that's been removed. :-/\n         *\n         * @private {!Object.<string, !Object>}\n         */\n        _this.listens_ = {};\n        return _this;\n    }\n    ReadonlyRestClient.prototype.reportStats = function (stats) {\n        throw new Error('Method not implemented.');\n    };\n    /**\n     * @param {!Query} query\n     * @param {?number=} tag\n     * @return {string}\n     * @private\n     */\n    ReadonlyRestClient.getListenId_ = function (query, tag) {\n        if (tag !== undefined) {\n            return 'tag$' + tag;\n        }\n        else {\n            assert(query.getQueryParams().isDefault(), 'should have a tag if it\\'s not a default query.');\n            return query.path.toString();\n        }\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n        var _this = this;\n        var pathString = query.path.toString();\n        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());\n        // Mark this listener so we can tell if it's removed.\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\n        var thisListen = {};\n        this.listens_[listenId] = thisListen;\n        var queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();\n        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {\n            var data = result;\n            if (error === 404) {\n                data = null;\n                error = null;\n            }\n            if (error === null) {\n                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n            }\n            if (safeGet(_this.listens_, listenId) === thisListen) {\n                var status_1;\n                if (!error) {\n                    status_1 = 'ok';\n                }\n                else if (error == 401) {\n                    status_1 = 'permission_denied';\n                }\n                else {\n                    status_1 = 'rest_error:' + error;\n                }\n                onComplete(status_1, null);\n            }\n        });\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.unlisten = function (query, tag) {\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\n        delete this.listens_[listenId];\n    };\n    /** @inheritDoc */\n    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {\n        // no-op since we just always call getToken.\n    };\n    /**\n     * Performs a REST request to the given path, with the provided query string parameters,\n     * and any auth credentials we have.\n     *\n     * @param {!string} pathString\n     * @param {!Object.<string, *>} queryStringParameters\n     * @param {?function(?number, *=)} callback\n     * @private\n     */\n    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\n        var _this = this;\n        if (queryStringParameters === void 0) { queryStringParameters = {}; }\n        queryStringParameters['format'] = 'export';\n        this.authTokenProvider_.getToken(/*forceRefresh=*/ false).then(function (authTokenData) {\n            var authToken = authTokenData && authTokenData.accessToken;\n            if (authToken) {\n                queryStringParameters['auth'] = authToken;\n            }\n            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +\n                _this.repoInfo_.host +\n                pathString +\n                '?' +\n                querystring(queryStringParameters);\n            _this.log_('Sending REST request for ' + url);\n            var xhr = new XMLHttpRequest();\n            xhr.onreadystatechange = function () {\n                if (callback && xhr.readyState === 4) {\n                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n                    var res = null;\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        try {\n                            res = jsonEval(xhr.responseText);\n                        }\n                        catch (e) {\n                            warn('Failed to parse JSON response for ' + url + ': ' + xhr.responseText);\n                        }\n                        callback(null, res);\n                    }\n                    else {\n                        // 401 and 404 are expected.\n                        if (xhr.status !== 401 && xhr.status !== 404) {\n                            warn('Got unsuccessful REST response for ' + url + ' Status: ' + xhr.status);\n                        }\n                        callback(xhr.status);\n                    }\n                    callback = null;\n                }\n            };\n            xhr.open('GET', url, /*asynchronous=*/ true);\n            xhr.send();\n        });\n    };\n    return ReadonlyRestClient;\n}(ServerActions));\nexport { ReadonlyRestClient };\n\n\n"]}