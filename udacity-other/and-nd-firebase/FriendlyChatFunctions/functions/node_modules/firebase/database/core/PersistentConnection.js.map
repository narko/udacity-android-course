{"version":3,"sources":["src/database/core/PersistentConnection.ts","database/core/PersistentConnection.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","RECONNECT_MIN_DELAY","RECONNECT_MAX_DELAY_DEFAULT","RECONNECT_MAX_DELAY_FOR_ADMINS","RECONNECT_DELAY_MULTIPLIER","RECONNECT_DELAY_RESET_TIMEOUT","SERVER_KILL_INTERRUPT_REASON","INVALID_AUTH_TOKEN_THRESHOLD","PersistentConnection","_super","repoInfo_","onDataUpdate_","onConnectStatus_","onServerInfoUpdate_","authTokenProvider_","authOverride_","_this","call","id","nextPersistentConnectionId_","log_","interruptReasons_","listens_","outstandingPuts_","outstandingPutCount_","onDisconnectRequestQueue_","connected_","reconnectDelay_","maxReconnectDelay_","securityDebugCallback_","lastSessionId","establishConnectionTimer_","visible_","requestCBHash_","requestNumber_","realtime_","authToken_","forceTokenRefresh_","invalidAuthTokenCount_","firstConnection_","lastConnectionAttemptTime_","lastConnectionEstablishedTime_","Error","scheduleConnect_","getInstance","on","onVisible_","host","indexOf","onOnline_","sendRequest","action","body","onResponse","curReqNum","msg","listen","query","currentHashFn","tag","onComplete","queryId","queryIdentifier","pathString","path","toString","getQueryParams","isDefault","loadsAllData","listenSpec","hashFn","sendListen_","req","queryObject","message","payload","status","warnOnListenWarnings_","currentListenSpec","removeListen_","warnings","isArray","indexSpec","getIndex","indexPath","refreshAuthToken","token","tryAuth","reduceReconnectDelayIfAdminCredential_","credential","isFirebaseSecret","length","token_1","authMethod","requestData","res","data","onAuthRevoked_","unlisten","sendUnlisten_","queryObj","onDisconnectPut","sendOnDisconnect_","push","onDisconnectMerge","onDisconnectCancel","request","response","setTimeout","Math","floor","put","hash","putInternal","merge","undefined","index","sendPut_","queued","reportStats","stats","result","errorReason","onDataMessage_","reqNum","onDataPush_","onListenRevoked_","onSecurityDebugPacket_","onReady_","timestamp","sessionId","Date","getTime","handleTimestamp_","sendConnectStats_","restoreState_","timeout","clearTimeout","establishConnection_","visible","online","close","onRealtimeDisconnect_","cancelSentTransactions_","shouldReconnect_","timeSinceLastConnectSucceeded","timeSinceLastConnectAttempt","reconnectDelay","max","random","min","onDataMessage_1","bind","onReady_1","onDisconnect_1","connId_1","nextConnectionId_","self_1","lastSessionId_1","canceled_1","connection_1","closeFn_1","sendRequestFn","forceRefresh","getToken","then","accessToken","reason","interrupt","error","NODE_ADMIN","resume","delta","i","map","q","join","normalizedPathString","statusCode","explanation","notifyForInvalidToken","console","log","replace","queries","key","shift","clientName","NODE_CLIENT","SDK_VERSION","currentlyOnline"],"mappings":"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","file":"PersistentConnection.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport firebase from '../../app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '../../utils/obj';\nimport { stringify } from '../../utils/json';\nimport { assert } from '../../utils/assert';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '../../utils/jwt';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '../../utils/constants';\nimport {\n  isMobileCordova,\n  isReactNative,\n  isNodeSdk\n} from '../../utils/environment';\nimport { ServerActions } from './ServerActions';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { RepoInfo } from './RepoInfo';\nimport { Query } from '../api/Query';\n\nconst RECONNECT_MIN_DELAY = 1000;\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000;   // 5 minutes in milliseconds (Case: 1858)\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nconst INVALID_AUTH_TOKEN_THRESHOLD = 3;\n\ninterface ListenSpec {\n  onComplete(s: string, p?: any): void;\n\n  hashFn(): string;\n\n  query: Query;\n  tag: number | null;\n}\n\ninterface OnDisconnectRequest {\n  pathString: string;\n  action: string;\n  data: any;\n  onComplete?: (a: string, b: string) => void;\n}\n\ninterface OutstandingPut {\n  action: string;\n  request: Object;\n  queued?: boolean;\n  onComplete: (a: string, b?: string) => void;\n}\n\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nexport class PersistentConnection extends ServerActions {\n  // Used for diagnostic logging.\n  id = PersistentConnection.nextPersistentConnectionId_++;\n  private log_ = logWrapper('p:' + this.id + ':');\n\n  /** @private {Object} */\n  private interruptReasons_: { [reason: string]: boolean } = {};\n  private listens_: { [path: string]: { [queryId: string]: ListenSpec } } = {};\n  private outstandingPuts_: OutstandingPut[] = [];\n  private outstandingPutCount_ = 0;\n  private onDisconnectRequestQueue_: OnDisconnectRequest[] = [];\n  private connected_ = false;\n  private reconnectDelay_ = RECONNECT_MIN_DELAY;\n  private maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n  private securityDebugCallback_: ((a: Object) => void) | null = null;\n  lastSessionId: string | null = null;\n\n  /** @private {number|null} */\n  private establishConnectionTimer_: number | null = null;\n\n  /** @private {boolean} */\n  private visible_: boolean = false;\n\n  // Before we get connected, we keep a queue of pending messages to send.\n  private requestCBHash_: { [k: number]: (a: any) => void } = {};\n  private requestNumber_ = 0;\n\n  /** @private {?{\n   *   sendRequest(Object),\n   *   close()\n   * }} */\n  private realtime_: { sendRequest(a: Object): void, close(): void } | null = null;\n\n  /** @private {string|null} */\n  private authToken_: string | null = null;\n  private forceTokenRefresh_ = false;\n  private invalidAuthTokenCount_ = 0;\n\n  private firstConnection_ = true;\n  private lastConnectionAttemptTime_: number | null = null;\n  private lastConnectionEstablishedTime_: number | null = null;\n\n\n  /**\n   * @private\n   */\n  private static nextPersistentConnectionId_ = 0;\n\n  /**\n   * Counter for number of connections created. Mainly used for tagging in the logs\n   * @type {number}\n   * @private\n   */\n  private static nextConnectionId_ = 0;\n\n  /**\n   * @implements {ServerActions}\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param onConnectStatus_\n   * @param onServerInfoUpdate_\n   * @param authTokenProvider_\n   * @param authOverride_\n   */\n  constructor(private repoInfo_: RepoInfo,\n              private onDataUpdate_: (a: string, b: any, c: boolean, d: number | null) => void,\n              private onConnectStatus_: (a: boolean) => void,\n              private onServerInfoUpdate_: (a: any) => void,\n              private authTokenProvider_: AuthTokenProvider,\n              private authOverride_?: Object | null) {\n    super();\n\n    if (authOverride_ && !isNodeSdk()) {\n      throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\n    }\n    this.scheduleConnect_(0);\n\n    VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\n\n    if (repoInfo_.host.indexOf('fblocal') === -1) {\n      OnlineMonitor.getInstance().on('online', this.onOnline_, this);\n    }\n  }\n\n  /**\n   * @param {!string} action\n   * @param {*} body\n   * @param {function(*)=} onResponse\n   * @protected\n   */\n  protected sendRequest(action: string, body: any, onResponse?: (a: any) => void) {\n    const curReqNum = ++this.requestNumber_;\n\n    const msg = {'r': curReqNum, 'a': action, 'b': body};\n    this.log_(stringify(msg));\n    assert(this.connected_, 'sendRequest call when we\\'re not connected not allowed.');\n    this.realtime_.sendRequest(msg);\n    if (onResponse) {\n      this.requestCBHash_[curReqNum] = onResponse;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listen(query: Query, currentHashFn: () => string, tag: number | null, onComplete: (a: string, b: any) => void) {\n    const queryId = query.queryIdentifier();\n    const pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + queryId);\n    this.listens_[pathString] = this.listens_[pathString] || {};\n    assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(),\n      'listen() called for non-default but complete query');\n    assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');\n    const listenSpec: ListenSpec = {\n      onComplete: onComplete,\n      hashFn: currentHashFn,\n      query: query,\n      tag: tag\n    };\n    this.listens_[pathString][queryId] = listenSpec;\n\n    if (this.connected_) {\n      this.sendListen_(listenSpec);\n    }\n  }\n\n  /**\n   * @param {!{onComplete(),\n   *           hashFn():!string,\n   *           query: !Query,\n   *           tag: ?number}} listenSpec\n   * @private\n   */\n  private sendListen_(listenSpec: ListenSpec) {\n    const query = listenSpec.query;\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n    this.log_('Listen on ' + pathString + ' for ' + queryId);\n    const req: { [k: string]: any } = {/*path*/ 'p': pathString};\n\n    const action = 'q';\n\n    // Only bother to send query if it's non-default.\n    if (listenSpec.tag) {\n      req['q'] = query.queryObject();\n      req['t'] = listenSpec.tag;\n    }\n\n    req[/*hash*/'h'] = listenSpec.hashFn();\n\n    this.sendRequest(action, req, (message: { [k: string]: any }) => {\n      const payload: any = message[/*data*/ 'd'];\n      const status: string = message[/*status*/ 's'];\n\n      // print warnings in any case...\n      PersistentConnection.warnOnListenWarnings_(payload, query);\n\n      const currentListenSpec = this.listens_[pathString] && this.listens_[pathString][queryId];\n      // only trigger actions if the listen hasn't been removed and readded\n      if (currentListenSpec === listenSpec) {\n        this.log_('listen response', message);\n\n        if (status !== 'ok') {\n          this.removeListen_(pathString, queryId);\n        }\n\n        if (listenSpec.onComplete) {\n          listenSpec.onComplete(status, payload);\n        }\n      }\n    });\n  }\n\n  /**\n   * @param {*} payload\n   * @param {!Query} query\n   * @private\n   */\n  private static warnOnListenWarnings_(payload: any, query: Query) {\n    if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n      const warnings = safeGet(payload, 'w');\n      if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n        const indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n        const indexPath = query.path.toString();\n        warn('Using an unspecified index. Consider adding ' + indexSpec + ' at ' + indexPath +\n          ' to your security rules for better performance');\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  refreshAuthToken(token: string) {\n    this.authToken_ = token;\n    this.log_('Auth token refreshed');\n    if (this.authToken_) {\n      this.tryAuth();\n    } else {\n      //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n      //the credential so we dont become authenticated next time we connect.\n      if (this.connected_) {\n        this.sendRequest('unauth', {}, () => { });\n      }\n    }\n\n    this.reduceReconnectDelayIfAdminCredential_(token);\n  }\n\n  /**\n   * @param {!string} credential\n   * @private\n   */\n  private reduceReconnectDelayIfAdminCredential_(credential: string) {\n    // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n    // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n    const isFirebaseSecret = credential && credential.length === 40;\n    if (isFirebaseSecret || isAdmin(credential)) {\n      this.log_('Admin auth credential detected.  Reducing max reconnect time.');\n      this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n    }\n  }\n\n  /**\n   * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n   * a auth revoked (the connection is closed).\n   */\n  tryAuth() {\n    if (this.connected_ && this.authToken_) {\n      const token = this.authToken_;\n      const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\n      const requestData: { [k: string]: any } = {'cred': token};\n      if (this.authOverride_ === null) {\n        requestData['noauth'] = true;\n      } else if (typeof this.authOverride_ === 'object') {\n        requestData['authvar'] = this.authOverride_;\n      }\n      this.sendRequest(authMethod, requestData, (res: { [k: string]: any }) => {\n        const status: string = res[/*status*/ 's'];\n        const data: string = res[/*data*/ 'd'] || 'error';\n\n        if (this.authToken_ === token) {\n          if (status === 'ok') {\n            this.invalidAuthTokenCount_ = 0;\n          } else {\n            // Triggers reconnect and force refresh for auth token\n            this.onAuthRevoked_(status, data);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  unlisten(query: Query, tag: number | null) {\n    const pathString = query.path.toString();\n    const queryId = query.queryIdentifier();\n\n    this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n\n    assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(),\n      'unlisten() called for non-default but complete query');\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && this.connected_) {\n      this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n    }\n  }\n\n  private sendUnlisten_(pathString: string, queryId: string, queryObj: Object, tag: number | null) {\n    this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n\n    const req: { [k: string]: any } = {/*path*/ 'p': pathString};\n    const action = 'n';\n    // Only bother sending queryId if it's non-default.\n    if (tag) {\n      req['q'] = queryObj;\n      req['t'] = tag;\n    }\n\n    this.sendRequest(action, req);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectPut(pathString: string, data: any, onComplete?: (a: string, b: string) => void) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('o', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'o',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectMerge(pathString: string, data: any, onComplete?: (a: string, b: string) => void) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('om', pathString, data, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'om',\n        data,\n        onComplete\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  onDisconnectCancel(pathString: string, onComplete?: (a: string, b: string) => void) {\n    if (this.connected_) {\n      this.sendOnDisconnect_('oc', pathString, null, onComplete);\n    } else {\n      this.onDisconnectRequestQueue_.push({\n        pathString,\n        action: 'oc',\n        data: null,\n        onComplete\n      });\n    }\n  }\n\n  private sendOnDisconnect_(action: string, pathString: string, data: any, onComplete: (a: string, b: string) => void) {\n    const request = {/*path*/ 'p': pathString, /*data*/ 'd': data};\n    this.log_('onDisconnect ' + action, request);\n    this.sendRequest(action, request, (response: { [k: string]: any }) => {\n      if (onComplete) {\n        setTimeout(function () {\n          onComplete(response[/*status*/ 's'], response[/* data */'d']);\n        }, Math.floor(0));\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  put(pathString: string, data: any, onComplete?: (a: string, b: string) => void, hash?: string) {\n    this.putInternal('p', pathString, data, onComplete, hash);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  merge(pathString: string, data: any, onComplete: (a: string, b: string | null) => void, hash?: string) {\n    this.putInternal('m', pathString, data, onComplete, hash);\n  }\n\n  putInternal(action: string, pathString: string, data: any,\n              onComplete: (a: string, b: string | null) => void, hash?: string) {\n    const request: { [k: string]: any } = {/*path*/ 'p': pathString, /*data*/ 'd': data};\n\n    if (hash !== undefined)\n      request[/*hash*/ 'h'] = hash;\n\n    // TODO: Only keep track of the most recent put for a given path?\n    this.outstandingPuts_.push({\n      action,\n      request,\n      onComplete\n    });\n\n    this.outstandingPutCount_++;\n    const index = this.outstandingPuts_.length - 1;\n\n    if (this.connected_) {\n      this.sendPut_(index);\n    } else {\n      this.log_('Buffering put: ' + pathString);\n    }\n  }\n\n  private sendPut_(index: number) {\n    const action = this.outstandingPuts_[index].action;\n    const request = this.outstandingPuts_[index].request;\n    const onComplete = this.outstandingPuts_[index].onComplete;\n    this.outstandingPuts_[index].queued = this.connected_;\n\n    this.sendRequest(action, request, (message: { [k: string]: any }) => {\n      this.log_(action + ' response', message);\n\n      delete this.outstandingPuts_[index];\n      this.outstandingPutCount_--;\n\n      // Clean up array occasionally.\n      if (this.outstandingPutCount_ === 0) {\n        this.outstandingPuts_ = [];\n      }\n\n      if (onComplete)\n        onComplete(message[/*status*/ 's'], message[/* data */ 'd']);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  reportStats(stats: { [k: string]: any }) {\n    // If we're not connected, we just drop the stats.\n    if (this.connected_) {\n      const request = {/*counters*/ 'c': stats};\n      this.log_('reportStats', request);\n\n      this.sendRequest(/*stats*/ 's', request, (result) => {\n        const status = result[/*status*/ 's'];\n        if (status !== 'ok') {\n          const errorReason = result[/* data */ 'd'];\n          this.log_('reportStats', 'Error sending stats: ' + errorReason);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {*} message\n   * @private\n   */\n  private onDataMessage_(message: { [k: string]: any }) {\n    if ('r' in message) {\n      // this is a response\n      this.log_('from server: ' + stringify(message));\n      const reqNum = message['r'];\n      const onResponse = this.requestCBHash_[reqNum];\n      if (onResponse) {\n        delete this.requestCBHash_[reqNum];\n        onResponse(message[/*body*/ 'b']);\n      }\n    } else if ('error' in message) {\n      throw 'A server-side error has occurred: ' + message['error'];\n    } else if ('a' in message) {\n      // a and b are action and body, respectively\n      this.onDataPush_(message['a'], message['b']);\n    }\n  }\n\n  private onDataPush_(action: string, body: { [k: string]: any }) {\n    this.log_('handleServerMessage', action, body);\n    if (action === 'd')\n      this.onDataUpdate_(body[/*path*/ 'p'], body[/*data*/ 'd'], /*isMerge*/false, body['t']);\n    else if (action === 'm')\n      this.onDataUpdate_(body[/*path*/ 'p'], body[/*data*/ 'd'], /*isMerge=*/true, body['t']);\n    else if (action === 'c')\n      this.onListenRevoked_(body[/*path*/ 'p'], body[/*query*/ 'q']);\n    else if (action === 'ac')\n      this.onAuthRevoked_(body[/*status code*/ 's'], body[/* explanation */ 'd']);\n    else if (action === 'sd')\n      this.onSecurityDebugPacket_(body);\n    else\n      error('Unrecognized action received from server: ' + stringify(action) +\n        '\\nAre you using the latest client?');\n  }\n\n  private onReady_(timestamp: number, sessionId: string) {\n    this.log_('connection ready');\n    this.connected_ = true;\n    this.lastConnectionEstablishedTime_ = new Date().getTime();\n    this.handleTimestamp_(timestamp);\n    this.lastSessionId = sessionId;\n    if (this.firstConnection_) {\n      this.sendConnectStats_();\n    }\n    this.restoreState_();\n    this.firstConnection_ = false;\n    this.onConnectStatus_(true);\n  }\n\n  private scheduleConnect_(timeout: number) {\n    assert(!this.realtime_, 'Scheduling a connect when we\\'re already connected/ing?');\n\n    if (this.establishConnectionTimer_) {\n      clearTimeout(this.establishConnectionTimer_);\n    }\n\n    // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n    // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n\n    this.establishConnectionTimer_ = setTimeout(() => {\n      this.establishConnectionTimer_ = null;\n      this.establishConnection_();\n    }, Math.floor(timeout)) as any;\n  }\n\n  /**\n   * @param {boolean} visible\n   * @private\n   */\n  private onVisible_(visible: boolean) {\n    // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n    if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n      this.log_('Window became visible.  Reducing delay.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n    this.visible_ = visible;\n  }\n\n  private onOnline_(online: boolean) {\n    if (online) {\n      this.log_('Browser went online.');\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    } else {\n      this.log_('Browser went offline.  Killing connection.');\n      if (this.realtime_) {\n        this.realtime_.close();\n      }\n    }\n  }\n\n  private onRealtimeDisconnect_() {\n    this.log_('data client disconnected');\n    this.connected_ = false;\n    this.realtime_ = null;\n\n    // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n    this.cancelSentTransactions_();\n\n    // Clear out the pending requests.\n    this.requestCBHash_ = {};\n\n    if (this.shouldReconnect_()) {\n      if (!this.visible_) {\n        this.log_('Window isn\\'t visible.  Delaying reconnect.');\n        this.reconnectDelay_ = this.maxReconnectDelay_;\n        this.lastConnectionAttemptTime_ = new Date().getTime();\n      } else if (this.lastConnectionEstablishedTime_) {\n        // If we've been connected long enough, reset reconnect delay to minimum.\n        const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n        if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n          this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        this.lastConnectionEstablishedTime_ = null;\n      }\n\n      const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n      let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n      reconnectDelay = Math.random() * reconnectDelay;\n\n      this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n      this.scheduleConnect_(reconnectDelay);\n\n      // Adjust reconnect delay for next time.\n      this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n    }\n    this.onConnectStatus_(false);\n  }\n\n  private establishConnection_() {\n    if (this.shouldReconnect_()) {\n      this.log_('Making a connection attempt');\n      this.lastConnectionAttemptTime_ = new Date().getTime();\n      this.lastConnectionEstablishedTime_ = null;\n      const onDataMessage = this.onDataMessage_.bind(this);\n      const onReady = this.onReady_.bind(this);\n      const onDisconnect = this.onRealtimeDisconnect_.bind(this);\n      const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\n      const self = this;\n      const lastSessionId = this.lastSessionId;\n      let canceled = false;\n      let connection: Connection | null = null;\n      const closeFn = function () {\n        if (connection) {\n          connection.close();\n        } else {\n          canceled = true;\n          onDisconnect();\n        }\n      };\n      const sendRequestFn = function (msg: Object) {\n        assert(connection, 'sendRequest call when we\\'re not connected not allowed.');\n        connection.sendRequest(msg);\n      };\n\n      this.realtime_ = {\n        close: closeFn,\n        sendRequest: sendRequestFn\n      };\n\n      const forceRefresh = this.forceTokenRefresh_;\n      this.forceTokenRefresh_ = false;\n\n      // First fetch auth token, and establish connection after fetching the token was successful\n      this.authTokenProvider_.getToken(forceRefresh).then(function (result) {\n        if (!canceled) {\n          log('getToken() completed. Creating connection.');\n          self.authToken_ = result && result.accessToken;\n          connection = new Connection(connId, self.repoInfo_,\n            onDataMessage,\n            onReady,\n            onDisconnect, /* onKill= */ function (reason) {\n              warn(reason + ' (' + self.repoInfo_.toString() + ')');\n              self.interrupt(SERVER_KILL_INTERRUPT_REASON);\n            },\n            lastSessionId);\n        } else {\n          log('getToken() completed but was canceled');\n        }\n      }).then(null, function (error) {\n        self.log_('Failed to get token: ' + error);\n        if (!canceled) {\n          if (CONSTANTS.NODE_ADMIN) {\n            // This may be a critical error for the Admin Node.js SDK, so log a warning.\n            // But getToken() may also just have temporarily failed, so we still want to\n            // continue retrying.\n            warn(error);\n          }\n          closeFn();\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  interrupt(reason: string) {\n    log('Interrupting connection for reason: ' + reason);\n    this.interruptReasons_[reason] = true;\n    if (this.realtime_) {\n      this.realtime_.close();\n    } else {\n      if (this.establishConnectionTimer_) {\n        clearTimeout(this.establishConnectionTimer_);\n        this.establishConnectionTimer_ = null;\n      }\n      if (this.connected_) {\n        this.onRealtimeDisconnect_();\n      }\n    }\n  }\n\n  /**\n   * @param {string} reason\n   */\n  resume(reason: string) {\n    log('Resuming connection for reason: ' + reason);\n    delete this.interruptReasons_[reason];\n    if (isEmpty(this.interruptReasons_)) {\n      this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n      if (!this.realtime_) {\n        this.scheduleConnect_(0);\n      }\n    }\n  }\n\n  private handleTimestamp_(timestamp: number) {\n    const delta = timestamp - new Date().getTime();\n    this.onServerInfoUpdate_({'serverTimeOffset': delta});\n  }\n\n  private cancelSentTransactions_() {\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      const put = this.outstandingPuts_[i];\n      if (put && /*hash*/'h' in put.request && put.queued) {\n        if (put.onComplete)\n          put.onComplete('disconnect');\n\n        delete this.outstandingPuts_[i];\n        this.outstandingPutCount_--;\n      }\n    }\n\n    // Clean up array occasionally.\n    if (this.outstandingPutCount_ === 0)\n      this.outstandingPuts_ = [];\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {Array.<*>=} query\n   * @private\n   */\n  private onListenRevoked_(pathString: string, query?: any[]) {\n    // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n    let queryId;\n    if (!query) {\n      queryId = 'default';\n    } else {\n      queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\n    }\n    const listen = this.removeListen_(pathString, queryId);\n    if (listen && listen.onComplete)\n      listen.onComplete('permission_denied');\n  }\n\n  /**\n   * @param {!string} pathString\n   * @param {!string} queryId\n   * @return {{queries:Array.<Query>, onComplete:function(string)}}\n   * @private\n   */\n  private removeListen_(pathString: string, queryId: string): ListenSpec {\n    const normalizedPathString = new Path(pathString).toString(); // normalize path.\n    let listen;\n    if (this.listens_[normalizedPathString] !== undefined) {\n      listen = this.listens_[normalizedPathString][queryId];\n      delete this.listens_[normalizedPathString][queryId];\n      if (getCount(this.listens_[normalizedPathString]) === 0) {\n        delete this.listens_[normalizedPathString];\n      }\n    } else {\n      // all listens for this path has already been removed\n      listen = undefined;\n    }\n    return listen;\n  }\n\n  private onAuthRevoked_(statusCode: string, explanation: string) {\n    log('Auth token revoked: ' + statusCode + '/' + explanation);\n    this.authToken_ = null;\n    this.forceTokenRefresh_ = true;\n    this.realtime_.close();\n    if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n      // We'll wait a couple times before logging the warning / increasing the\n      // retry period since oauth tokens will report as \"invalid\" if they're\n      // just expired. Plus there may be transient issues that resolve themselves.\n      this.invalidAuthTokenCount_++;\n      if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n        // Set a long reconnect delay because recovery is unlikely\n        this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n\n        // Notify the auth token provider that the token is invalid, which will log\n        // a warning\n        this.authTokenProvider_.notifyForInvalidToken();\n      }\n    }\n  }\n\n  private onSecurityDebugPacket_(body: { [k: string]: any }) {\n    if (this.securityDebugCallback_) {\n      this.securityDebugCallback_(body);\n    } else {\n      if ('msg' in body && typeof console !== 'undefined') {\n        console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n      }\n    }\n  }\n\n  private restoreState_() {\n    //Re-authenticate ourselves if we have a credential stored.\n    this.tryAuth();\n\n    // Puts depend on having received the corresponding data update from the server before they complete, so we must\n    // make sure to send listens before puts.\n    forEach(this.listens_, (pathString: string, queries: Object) => {\n      forEach(queries, (key: string, listenSpec: ListenSpec) => {\n        this.sendListen_(listenSpec);\n      });\n    });\n\n    for (let i = 0; i < this.outstandingPuts_.length; i++) {\n      if (this.outstandingPuts_[i])\n        this.sendPut_(i);\n    }\n\n    while (this.onDisconnectRequestQueue_.length) {\n      const request = this.onDisconnectRequestQueue_.shift();\n      this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n    }\n  }\n\n  /**\n   * Sends client stats for first connection\n   * @private\n   */\n  private sendConnectStats_() {\n    const stats: { [k: string]: number } = {};\n\n    let clientName = 'js';\n    if (CONSTANTS.NODE_ADMIN) {\n      clientName = 'admin_node';\n    } else if (CONSTANTS.NODE_CLIENT) {\n      clientName = 'node';\n    }\n\n    stats['sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')] = 1;\n\n    if (isMobileCordova()) {\n      stats['framework.cordova'] = 1;\n    }\n    else if (isReactNative()) {\n      stats['framework.reactnative'] = 1;\n    }\n    this.reportStats(stats);\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  private shouldReconnect_(): boolean {\n    const online = OnlineMonitor.getInstance().currentlyOnline();\n    return isEmpty(this.interruptReasons_) && online;\n  }\n}\n\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport firebase from '../../app';\nimport { forEach, contains, isEmpty, getCount, safeGet } from '../../utils/obj';\nimport { stringify } from '../../utils/json';\nimport { assert } from '../../utils/assert';\nimport { error, log, logWrapper, warn, ObjectToUniqueKey } from './util/util';\nimport { Path } from './util/Path';\nimport { VisibilityMonitor } from './util/VisibilityMonitor';\nimport { OnlineMonitor } from './util/OnlineMonitor';\nimport { isAdmin, isValidFormat } from '../../utils/jwt';\nimport { Connection } from '../realtime/Connection';\nimport { CONSTANTS } from '../../utils/constants';\nimport { isMobileCordova, isReactNative, isNodeSdk } from '../../utils/environment';\nimport { ServerActions } from './ServerActions';\nvar RECONNECT_MIN_DELAY = 1000;\nvar RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\nvar RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\nvar RECONNECT_DELAY_MULTIPLIER = 1.3;\nvar RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\nvar SERVER_KILL_INTERRUPT_REASON = 'server_kill';\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\nvar INVALID_AUTH_TOKEN_THRESHOLD = 3;\n/**\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\n *\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\n * in quotes to make sure the closure compiler does not minify them.\n */\nvar PersistentConnection = (function (_super) {\n    __extends(PersistentConnection, _super);\n    /**\n     * @implements {ServerActions}\n     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n     * @param onConnectStatus_\n     * @param onServerInfoUpdate_\n     * @param authTokenProvider_\n     * @param authOverride_\n     */\n    function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {\n        var _this = _super.call(this) || this;\n        _this.repoInfo_ = repoInfo_;\n        _this.onDataUpdate_ = onDataUpdate_;\n        _this.onConnectStatus_ = onConnectStatus_;\n        _this.onServerInfoUpdate_ = onServerInfoUpdate_;\n        _this.authTokenProvider_ = authTokenProvider_;\n        _this.authOverride_ = authOverride_;\n        // Used for diagnostic logging.\n        _this.id = PersistentConnection.nextPersistentConnectionId_++;\n        _this.log_ = logWrapper('p:' + _this.id + ':');\n        /** @private {Object} */\n        _this.interruptReasons_ = {};\n        _this.listens_ = {};\n        _this.outstandingPuts_ = [];\n        _this.outstandingPutCount_ = 0;\n        _this.onDisconnectRequestQueue_ = [];\n        _this.connected_ = false;\n        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\n        _this.securityDebugCallback_ = null;\n        _this.lastSessionId = null;\n        /** @private {number|null} */\n        _this.establishConnectionTimer_ = null;\n        /** @private {boolean} */\n        _this.visible_ = false;\n        // Before we get connected, we keep a queue of pending messages to send.\n        _this.requestCBHash_ = {};\n        _this.requestNumber_ = 0;\n        /** @private {?{\n         *   sendRequest(Object),\n         *   close()\n         * }} */\n        _this.realtime_ = null;\n        /** @private {string|null} */\n        _this.authToken_ = null;\n        _this.forceTokenRefresh_ = false;\n        _this.invalidAuthTokenCount_ = 0;\n        _this.firstConnection_ = true;\n        _this.lastConnectionAttemptTime_ = null;\n        _this.lastConnectionEstablishedTime_ = null;\n        if (authOverride_ && !isNodeSdk()) {\n            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\n        }\n        _this.scheduleConnect_(0);\n        VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);\n        if (repoInfo_.host.indexOf('fblocal') === -1) {\n            OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);\n        }\n        return _this;\n    }\n    /**\n     * @param {!string} action\n     * @param {*} body\n     * @param {function(*)=} onResponse\n     * @protected\n     */\n    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {\n        var curReqNum = ++this.requestNumber_;\n        var msg = { 'r': curReqNum, 'a': action, 'b': body };\n        this.log_(stringify(msg));\n        assert(this.connected_, 'sendRequest call when we\\'re not connected not allowed.');\n        this.realtime_.sendRequest(msg);\n        if (onResponse) {\n            this.requestCBHash_[curReqNum] = onResponse;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n        var queryId = query.queryIdentifier();\n        var pathString = query.path.toString();\n        this.log_('Listen called for ' + pathString + ' ' + queryId);\n        this.listens_[pathString] = this.listens_[pathString] || {};\n        assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');\n        assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');\n        var listenSpec = {\n            onComplete: onComplete,\n            hashFn: currentHashFn,\n            query: query,\n            tag: tag\n        };\n        this.listens_[pathString][queryId] = listenSpec;\n        if (this.connected_) {\n            this.sendListen_(listenSpec);\n        }\n    };\n    /**\n     * @param {!{onComplete(),\n     *           hashFn():!string,\n     *           query: !Query,\n     *           tag: ?number}} listenSpec\n     * @private\n     */\n    PersistentConnection.prototype.sendListen_ = function (listenSpec) {\n        var _this = this;\n        var query = listenSpec.query;\n        var pathString = query.path.toString();\n        var queryId = query.queryIdentifier();\n        this.log_('Listen on ' + pathString + ' for ' + queryId);\n        var req = { /*path*/ 'p': pathString };\n        var action = 'q';\n        // Only bother to send query if it's non-default.\n        if (listenSpec.tag) {\n            req['q'] = query.queryObject();\n            req['t'] = listenSpec.tag;\n        }\n        req['h'] = listenSpec.hashFn();\n        this.sendRequest(action, req, function (message) {\n            var payload = message['d'];\n            var status = message['s'];\n            // print warnings in any case...\n            PersistentConnection.warnOnListenWarnings_(payload, query);\n            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];\n            // only trigger actions if the listen hasn't been removed and readded\n            if (currentListenSpec === listenSpec) {\n                _this.log_('listen response', message);\n                if (status !== 'ok') {\n                    _this.removeListen_(pathString, queryId);\n                }\n                if (listenSpec.onComplete) {\n                    listenSpec.onComplete(status, payload);\n                }\n            }\n        });\n    };\n    /**\n     * @param {*} payload\n     * @param {!Query} query\n     * @private\n     */\n    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {\n        if (payload && typeof payload === 'object' && contains(payload, 'w')) {\n            var warnings = safeGet(payload, 'w');\n            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\n                var indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\n                var indexPath = query.path.toString();\n                warn('Using an unspecified index. Consider adding ' + indexSpec + ' at ' + indexPath +\n                    ' to your security rules for better performance');\n            }\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.refreshAuthToken = function (token) {\n        this.authToken_ = token;\n        this.log_('Auth token refreshed');\n        if (this.authToken_) {\n            this.tryAuth();\n        }\n        else {\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\n            //the credential so we dont become authenticated next time we connect.\n            if (this.connected_) {\n                this.sendRequest('unauth', {}, function () { });\n            }\n        }\n        this.reduceReconnectDelayIfAdminCredential_(token);\n    };\n    /**\n     * @param {!string} credential\n     * @private\n     */\n    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\n        var isFirebaseSecret = credential && credential.length === 40;\n        if (isFirebaseSecret || isAdmin(credential)) {\n            this.log_('Admin auth credential detected.  Reducing max reconnect time.');\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n        }\n    };\n    /**\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\n     * a auth revoked (the connection is closed).\n     */\n    PersistentConnection.prototype.tryAuth = function () {\n        var _this = this;\n        if (this.connected_ && this.authToken_) {\n            var token_1 = this.authToken_;\n            var authMethod = isValidFormat(token_1) ? 'auth' : 'gauth';\n            var requestData = { 'cred': token_1 };\n            if (this.authOverride_ === null) {\n                requestData['noauth'] = true;\n            }\n            else if (typeof this.authOverride_ === 'object') {\n                requestData['authvar'] = this.authOverride_;\n            }\n            this.sendRequest(authMethod, requestData, function (res) {\n                var status = res['s'];\n                var data = res['d'] || 'error';\n                if (_this.authToken_ === token_1) {\n                    if (status === 'ok') {\n                        _this.invalidAuthTokenCount_ = 0;\n                    }\n                    else {\n                        // Triggers reconnect and force refresh for auth token\n                        _this.onAuthRevoked_(status, data);\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.unlisten = function (query, tag) {\n        var pathString = query.path.toString();\n        var queryId = query.queryIdentifier();\n        this.log_('Unlisten called for ' + pathString + ' ' + queryId);\n        assert(query.getQueryParams().isDefault() || !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');\n        var listen = this.removeListen_(pathString, queryId);\n        if (listen && this.connected_) {\n            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\n        }\n    };\n    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {\n        this.log_('Unlisten on ' + pathString + ' for ' + queryId);\n        var req = { /*path*/ 'p': pathString };\n        var action = 'n';\n        // Only bother sending queryId if it's non-default.\n        if (tag) {\n            req['q'] = queryObj;\n            req['t'] = tag;\n        }\n        this.sendRequest(action, req);\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('o', pathString, data, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'o',\n                data: data,\n                onComplete: onComplete\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('om', pathString, data, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'om',\n                data: data,\n                onComplete: onComplete\n            });\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {\n        if (this.connected_) {\n            this.sendOnDisconnect_('oc', pathString, null, onComplete);\n        }\n        else {\n            this.onDisconnectRequestQueue_.push({\n                pathString: pathString,\n                action: 'oc',\n                data: null,\n                onComplete: onComplete\n            });\n        }\n    };\n    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {\n        var request = { /*path*/ 'p': pathString, /*data*/ 'd': data };\n        this.log_('onDisconnect ' + action, request);\n        this.sendRequest(action, request, function (response) {\n            if (onComplete) {\n                setTimeout(function () {\n                    onComplete(response['s'], response['d']);\n                }, Math.floor(0));\n            }\n        });\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\n        this.putInternal('p', pathString, data, onComplete, hash);\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {\n        this.putInternal('m', pathString, data, onComplete, hash);\n    };\n    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {\n        var request = { /*path*/ 'p': pathString, /*data*/ 'd': data };\n        if (hash !== undefined)\n            request['h'] = hash;\n        // TODO: Only keep track of the most recent put for a given path?\n        this.outstandingPuts_.push({\n            action: action,\n            request: request,\n            onComplete: onComplete\n        });\n        this.outstandingPutCount_++;\n        var index = this.outstandingPuts_.length - 1;\n        if (this.connected_) {\n            this.sendPut_(index);\n        }\n        else {\n            this.log_('Buffering put: ' + pathString);\n        }\n    };\n    PersistentConnection.prototype.sendPut_ = function (index) {\n        var _this = this;\n        var action = this.outstandingPuts_[index].action;\n        var request = this.outstandingPuts_[index].request;\n        var onComplete = this.outstandingPuts_[index].onComplete;\n        this.outstandingPuts_[index].queued = this.connected_;\n        this.sendRequest(action, request, function (message) {\n            _this.log_(action + ' response', message);\n            delete _this.outstandingPuts_[index];\n            _this.outstandingPutCount_--;\n            // Clean up array occasionally.\n            if (_this.outstandingPutCount_ === 0) {\n                _this.outstandingPuts_ = [];\n            }\n            if (onComplete)\n                onComplete(message['s'], message['d']);\n        });\n    };\n    /**\n     * @inheritDoc\n     */\n    PersistentConnection.prototype.reportStats = function (stats) {\n        var _this = this;\n        // If we're not connected, we just drop the stats.\n        if (this.connected_) {\n            var request = { /*counters*/ 'c': stats };\n            this.log_('reportStats', request);\n            this.sendRequest(/*stats*/ 's', request, function (result) {\n                var status = result['s'];\n                if (status !== 'ok') {\n                    var errorReason = result['d'];\n                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);\n                }\n            });\n        }\n    };\n    /**\n     * @param {*} message\n     * @private\n     */\n    PersistentConnection.prototype.onDataMessage_ = function (message) {\n        if ('r' in message) {\n            // this is a response\n            this.log_('from server: ' + stringify(message));\n            var reqNum = message['r'];\n            var onResponse = this.requestCBHash_[reqNum];\n            if (onResponse) {\n                delete this.requestCBHash_[reqNum];\n                onResponse(message['b']);\n            }\n        }\n        else if ('error' in message) {\n            throw 'A server-side error has occurred: ' + message['error'];\n        }\n        else if ('a' in message) {\n            // a and b are action and body, respectively\n            this.onDataPush_(message['a'], message['b']);\n        }\n    };\n    PersistentConnection.prototype.onDataPush_ = function (action, body) {\n        this.log_('handleServerMessage', action, body);\n        if (action === 'd')\n            this.onDataUpdate_(body['p'], body['d'], /*isMerge*/ false, body['t']);\n        else if (action === 'm')\n            this.onDataUpdate_(body['p'], body['d'], /*isMerge=*/ true, body['t']);\n        else if (action === 'c')\n            this.onListenRevoked_(body['p'], body['q']);\n        else if (action === 'ac')\n            this.onAuthRevoked_(body['s'], body['d']);\n        else if (action === 'sd')\n            this.onSecurityDebugPacket_(body);\n        else\n            error('Unrecognized action received from server: ' + stringify(action) +\n                '\\nAre you using the latest client?');\n    };\n    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {\n        this.log_('connection ready');\n        this.connected_ = true;\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\n        this.handleTimestamp_(timestamp);\n        this.lastSessionId = sessionId;\n        if (this.firstConnection_) {\n            this.sendConnectStats_();\n        }\n        this.restoreState_();\n        this.firstConnection_ = false;\n        this.onConnectStatus_(true);\n    };\n    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {\n        var _this = this;\n        assert(!this.realtime_, 'Scheduling a connect when we\\'re already connected/ing?');\n        if (this.establishConnectionTimer_) {\n            clearTimeout(this.establishConnectionTimer_);\n        }\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\n        this.establishConnectionTimer_ = setTimeout(function () {\n            _this.establishConnectionTimer_ = null;\n            _this.establishConnection_();\n        }, Math.floor(timeout));\n    };\n    /**\n     * @param {boolean} visible\n     * @private\n     */\n    PersistentConnection.prototype.onVisible_ = function (visible) {\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\n        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {\n            this.log_('Window became visible.  Reducing delay.');\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        this.visible_ = visible;\n    };\n    PersistentConnection.prototype.onOnline_ = function (online) {\n        if (online) {\n            this.log_('Browser went online.');\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n        else {\n            this.log_('Browser went offline.  Killing connection.');\n            if (this.realtime_) {\n                this.realtime_.close();\n            }\n        }\n    };\n    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {\n        this.log_('data client disconnected');\n        this.connected_ = false;\n        this.realtime_ = null;\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\n        this.cancelSentTransactions_();\n        // Clear out the pending requests.\n        this.requestCBHash_ = {};\n        if (this.shouldReconnect_()) {\n            if (!this.visible_) {\n                this.log_('Window isn\\'t visible.  Delaying reconnect.');\n                this.reconnectDelay_ = this.maxReconnectDelay_;\n                this.lastConnectionAttemptTime_ = new Date().getTime();\n            }\n            else if (this.lastConnectionEstablishedTime_) {\n                // If we've been connected long enough, reset reconnect delay to minimum.\n                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n                this.lastConnectionEstablishedTime_ = null;\n            }\n            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\n            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\n            reconnectDelay = Math.random() * reconnectDelay;\n            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\n            this.scheduleConnect_(reconnectDelay);\n            // Adjust reconnect delay for next time.\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\n        }\n        this.onConnectStatus_(false);\n    };\n    PersistentConnection.prototype.establishConnection_ = function () {\n        if (this.shouldReconnect_()) {\n            this.log_('Making a connection attempt');\n            this.lastConnectionAttemptTime_ = new Date().getTime();\n            this.lastConnectionEstablishedTime_ = null;\n            var onDataMessage_1 = this.onDataMessage_.bind(this);\n            var onReady_1 = this.onReady_.bind(this);\n            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);\n            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;\n            var self_1 = this;\n            var lastSessionId_1 = this.lastSessionId;\n            var canceled_1 = false;\n            var connection_1 = null;\n            var closeFn_1 = function () {\n                if (connection_1) {\n                    connection_1.close();\n                }\n                else {\n                    canceled_1 = true;\n                    onDisconnect_1();\n                }\n            };\n            var sendRequestFn = function (msg) {\n                assert(connection_1, 'sendRequest call when we\\'re not connected not allowed.');\n                connection_1.sendRequest(msg);\n            };\n            this.realtime_ = {\n                close: closeFn_1,\n                sendRequest: sendRequestFn\n            };\n            var forceRefresh = this.forceTokenRefresh_;\n            this.forceTokenRefresh_ = false;\n            // First fetch auth token, and establish connection after fetching the token was successful\n            this.authTokenProvider_.getToken(forceRefresh).then(function (result) {\n                if (!canceled_1) {\n                    log('getToken() completed. Creating connection.');\n                    self_1.authToken_ = result && result.accessToken;\n                    connection_1 = new Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, /* onKill= */ function (reason) {\n                        warn(reason + ' (' + self_1.repoInfo_.toString() + ')');\n                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);\n                    }, lastSessionId_1);\n                }\n                else {\n                    log('getToken() completed but was canceled');\n                }\n            }).then(null, function (error) {\n                self_1.log_('Failed to get token: ' + error);\n                if (!canceled_1) {\n                    if (CONSTANTS.NODE_ADMIN) {\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\n                        // But getToken() may also just have temporarily failed, so we still want to\n                        // continue retrying.\n                        warn(error);\n                    }\n                    closeFn_1();\n                }\n            });\n        }\n    };\n    /**\n     * @param {string} reason\n     */\n    PersistentConnection.prototype.interrupt = function (reason) {\n        log('Interrupting connection for reason: ' + reason);\n        this.interruptReasons_[reason] = true;\n        if (this.realtime_) {\n            this.realtime_.close();\n        }\n        else {\n            if (this.establishConnectionTimer_) {\n                clearTimeout(this.establishConnectionTimer_);\n                this.establishConnectionTimer_ = null;\n            }\n            if (this.connected_) {\n                this.onRealtimeDisconnect_();\n            }\n        }\n    };\n    /**\n     * @param {string} reason\n     */\n    PersistentConnection.prototype.resume = function (reason) {\n        log('Resuming connection for reason: ' + reason);\n        delete this.interruptReasons_[reason];\n        if (isEmpty(this.interruptReasons_)) {\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\n            if (!this.realtime_) {\n                this.scheduleConnect_(0);\n            }\n        }\n    };\n    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {\n        var delta = timestamp - new Date().getTime();\n        this.onServerInfoUpdate_({ 'serverTimeOffset': delta });\n    };\n    PersistentConnection.prototype.cancelSentTransactions_ = function () {\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\n            var put = this.outstandingPuts_[i];\n            if (put && 'h' in put.request && put.queued) {\n                if (put.onComplete)\n                    put.onComplete('disconnect');\n                delete this.outstandingPuts_[i];\n                this.outstandingPutCount_--;\n            }\n        }\n        // Clean up array occasionally.\n        if (this.outstandingPutCount_ === 0)\n            this.outstandingPuts_ = [];\n    };\n    /**\n     * @param {!string} pathString\n     * @param {Array.<*>=} query\n     * @private\n     */\n    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\n        var queryId;\n        if (!query) {\n            queryId = 'default';\n        }\n        else {\n            queryId = query.map(function (q) { return ObjectToUniqueKey(q); }).join('$');\n        }\n        var listen = this.removeListen_(pathString, queryId);\n        if (listen && listen.onComplete)\n            listen.onComplete('permission_denied');\n    };\n    /**\n     * @param {!string} pathString\n     * @param {!string} queryId\n     * @return {{queries:Array.<Query>, onComplete:function(string)}}\n     * @private\n     */\n    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {\n        var normalizedPathString = new Path(pathString).toString(); // normalize path.\n        var listen;\n        if (this.listens_[normalizedPathString] !== undefined) {\n            listen = this.listens_[normalizedPathString][queryId];\n            delete this.listens_[normalizedPathString][queryId];\n            if (getCount(this.listens_[normalizedPathString]) === 0) {\n                delete this.listens_[normalizedPathString];\n            }\n        }\n        else {\n            // all listens for this path has already been removed\n            listen = undefined;\n        }\n        return listen;\n    };\n    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {\n        log('Auth token revoked: ' + statusCode + '/' + explanation);\n        this.authToken_ = null;\n        this.forceTokenRefresh_ = true;\n        this.realtime_.close();\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\n            // We'll wait a couple times before logging the warning / increasing the\n            // retry period since oauth tokens will report as \"invalid\" if they're\n            // just expired. Plus there may be transient issues that resolve themselves.\n            this.invalidAuthTokenCount_++;\n            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\n                // Set a long reconnect delay because recovery is unlikely\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\n                // Notify the auth token provider that the token is invalid, which will log\n                // a warning\n                this.authTokenProvider_.notifyForInvalidToken();\n            }\n        }\n    };\n    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {\n        if (this.securityDebugCallback_) {\n            this.securityDebugCallback_(body);\n        }\n        else {\n            if ('msg' in body && typeof console !== 'undefined') {\n                console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\n            }\n        }\n    };\n    PersistentConnection.prototype.restoreState_ = function () {\n        var _this = this;\n        //Re-authenticate ourselves if we have a credential stored.\n        this.tryAuth();\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\n        // make sure to send listens before puts.\n        forEach(this.listens_, function (pathString, queries) {\n            forEach(queries, function (key, listenSpec) {\n                _this.sendListen_(listenSpec);\n            });\n        });\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\n            if (this.outstandingPuts_[i])\n                this.sendPut_(i);\n        }\n        while (this.onDisconnectRequestQueue_.length) {\n            var request = this.onDisconnectRequestQueue_.shift();\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\n        }\n    };\n    /**\n     * Sends client stats for first connection\n     * @private\n     */\n    PersistentConnection.prototype.sendConnectStats_ = function () {\n        var stats = {};\n        var clientName = 'js';\n        if (CONSTANTS.NODE_ADMIN) {\n            clientName = 'admin_node';\n        }\n        else if (CONSTANTS.NODE_CLIENT) {\n            clientName = 'node';\n        }\n        stats['sdk.' + clientName + '.' + firebase.SDK_VERSION.replace(/\\./g, '-')] = 1;\n        if (isMobileCordova()) {\n            stats['framework.cordova'] = 1;\n        }\n        else if (isReactNative()) {\n            stats['framework.reactnative'] = 1;\n        }\n        this.reportStats(stats);\n    };\n    /**\n     * @return {boolean}\n     * @private\n     */\n    PersistentConnection.prototype.shouldReconnect_ = function () {\n        var online = OnlineMonitor.getInstance().currentlyOnline();\n        return isEmpty(this.interruptReasons_) && online;\n    };\n    return PersistentConnection;\n}(ServerActions));\nexport { PersistentConnection };\n/**\n * @private\n */\nPersistentConnection.nextPersistentConnectionId_ = 0;\n/**\n * Counter for number of connections created. Mainly used for tagging in the logs\n * @type {number}\n * @private\n */\nPersistentConnection.nextConnectionId_ = 0;\n\n\n"]}