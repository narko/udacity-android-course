{"version":3,"sources":["src/database/api/Query.ts","database/api/Query.js"],"names":["__referenceConstructor","Query","repo","path","queryParams_","orderByCalled_","Object","defineProperty","get","set","val","enumerable","configurable","validateQueryEndpoints_","params","startNode","endNode","hasStart","getIndexStartValue","hasEnd","getIndexEndValue","getIndex","tooManyArgsError","wrongArgTypeError","startName","getIndexStartName","Error","endName","getIndexEndName","validateLimit_","hasLimit","hasAnchoredLimit","prototype","validateNoPreviousOrderByCall_","fnName","getQueryParams","getRef","arguments","length","on","eventType","callback","cancelCallbackOrContext","context","ret","getCancelAndContextArgs_","onValueEvent","cancel","callbacks","onChildEvent","cancelCallback","container","addEventCallbackForQuery","off","valueCallback","removeEventCallbackForQuery","once","userCallback","cancelOrContext","_this","firstCall","deferred","promise","onceCallback","snapshot","bind","resolve","err","reject","limitToFirst","limit","Math","floor","limitToLast","orderByChild","parsedPath","isEmpty","index","newParams","orderBy","orderByKey","orderByPriority","orderByValue","startAt","value","name","undefined","endAt","equalTo","toString","toUrlEncodedString","toJSON","queryObject","getQueryObject","queryIdentifier","obj","id","isEqual","other","error","sameRepo","samePath","equals","sameQueryIdentifier"],"mappings":"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","file":"Query.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { assert } from '../../utils/assert';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey,\n} from '../core/util/validation';\nimport { errorPrefix, validateArgCount, validateCallback, validateContextObject } from '../../utils/validation';\nimport { ValueEventRegistration, ChildEventRegistration, EventRegistration } from '../core/view/EventRegistration';\nimport { Deferred, attachDummyErrorHandler } from '../../utils/promise';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new(repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string): any\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(public repo: Repo, public path: Path, private queryParams_: QueryParams, private orderByCalled_: boolean) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof(startNode) !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof(endNode) !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    }\n    else if (params.getIndex() === PRIORITY_INDEX) {\n      if ((startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))) {\n        throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\n          'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n      }\n    } else {\n      assert((params.getIndex() instanceof PathIndex) ||\n        (params.getIndex() === VALUE_INDEX), 'unknown index type.');\n      if ((startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')) {\n        throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n          'an object.');\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n      throw new Error(\n        'Query: Can\\'t combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.'\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + ': You can\\'t combine multiple orderBy calls.');\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return (new Query.__referenceConstructor(this.repo, this.path) as Reference);\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(eventType: string, callback: SnapshotCallback,\n     cancelCallbackOrContext?: ((a: Error) => any) | Object, context?: Object): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(callback: (a: DataSnapshot) => void, cancelCallback: ((a: Error) => void) | null, context: Object | null) {\n    const container = new ValueEventRegistration(callback, cancelCallback || null, context || null);\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(callbacks: { [k: string]: SnapshotCallback },\n               cancelCallback: ((a: Error) => any) | null, context: Object | null) {\n    const container = new ChildEventRegistration(callbacks, cancelCallback, context);\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(eventType?: string, callback?: SnapshotCallback, context?: Object) {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(valueCallback, null, context || null);\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(eventType: string, \n       userCallback?: SnapshotCallback,\n       cancelOrContext?: ((a: Error) => void) | Object,\n       context?: Object): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred();\n    attachDummyErrorHandler(deferred.promise);\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(eventType, onceCallback, /*cancel=*/ (err) => {\n      this.off(eventType, onceCallback);\n\n      if (ret.cancel)\n        ret.cancel.bind(ret.context)(err);\n      deferred.reject(err);\n    });\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +\n        'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToLast: First argument must be a positive integer.');\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +\n        'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit),\n      this.orderByCalled_);\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n    } else if (path === '$priority') {\n      throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n    } else if (path === '$value') {\n      throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(value: number | string | boolean | null = null, name?: string | null): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +\n        'or equalTo).');\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(value: number | string | boolean | null = null, name?: string | null): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +\n        'equalTo).');\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +\n        'equalTo).');\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +\n        'equalTo).');\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return (id === '{}') ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = (this.repo === other.repo);\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier = (this.queryIdentifier() === other.queryIdentifier());\n\n    return (sameRepo && samePath && sameQueryIdentifier);\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(fnName: string, cancelOrContext?: ((a: Error) => void) | Object,\n                                          context?: Object): { cancel: ((a: Error) => void) | null, context: Object | null } {\n    const ret: { cancel: ((a: Error) => void) | null, context: Object | null } = {cancel: null, context: null};\n    if (cancelOrContext && context) {\n      ret.cancel = (cancelOrContext as (a: Error) => void);\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) { // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) { // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(errorPrefix(fnName, 3, true) +\n          ' must either be a cancel callback or a context object.');\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { assert } from '../../utils/assert';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport { isValidPriority, validateEventType, validatePathString, validateFirebaseDataArg, validateKey, } from '../core/util/validation';\nimport { errorPrefix, validateArgCount, validateCallback, validateContextObject } from '../../utils/validation';\nimport { ValueEventRegistration, ChildEventRegistration } from '../core/view/EventRegistration';\nimport { Deferred, attachDummyErrorHandler } from '../../utils/promise';\nvar __referenceConstructor;\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nvar Query = (function () {\n    function Query(repo, path, queryParams_, orderByCalled_) {\n        this.repo = repo;\n        this.path = path;\n        this.queryParams_ = queryParams_;\n        this.orderByCalled_ = orderByCalled_;\n    }\n    Object.defineProperty(Query, \"__referenceConstructor\", {\n        get: function () {\n            assert(__referenceConstructor, 'Reference.ts has not been loaded');\n            return __referenceConstructor;\n        },\n        set: function (val) {\n            __referenceConstructor = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Validates start/end values for queries.\n     * @param {!QueryParams} params\n     * @private\n     */\n    Query.validateQueryEndpoints_ = function (params) {\n        var startNode = null;\n        var endNode = null;\n        if (params.hasStart()) {\n            startNode = params.getIndexStartValue();\n        }\n        if (params.hasEnd()) {\n            endNode = params.getIndexEndValue();\n        }\n        if (params.getIndex() === KEY_INDEX) {\n            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\n                'startAt(), endAt(), or equalTo().';\n            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n                'or equalTo() must be a string.';\n            if (params.hasStart()) {\n                var startName = params.getIndexStartName();\n                if (startName != MIN_NAME) {\n                    throw new Error(tooManyArgsError);\n                }\n                else if (typeof (startNode) !== 'string') {\n                    throw new Error(wrongArgTypeError);\n                }\n            }\n            if (params.hasEnd()) {\n                var endName = params.getIndexEndName();\n                if (endName != MAX_NAME) {\n                    throw new Error(tooManyArgsError);\n                }\n                else if (typeof (endNode) !== 'string') {\n                    throw new Error(wrongArgTypeError);\n                }\n            }\n        }\n        else if (params.getIndex() === PRIORITY_INDEX) {\n            if ((startNode != null && !isValidPriority(startNode)) ||\n                (endNode != null && !isValidPriority(endNode))) {\n                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\n                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n            }\n        }\n        else {\n            assert((params.getIndex() instanceof PathIndex) ||\n                (params.getIndex() === VALUE_INDEX), 'unknown index type.');\n            if ((startNode != null && typeof startNode === 'object') ||\n                (endNode != null && typeof endNode === 'object')) {\n                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n                    'an object.');\n            }\n        }\n    };\n    /**\n     * Validates that limit* has been called with the correct combination of parameters\n     * @param {!QueryParams} params\n     * @private\n     */\n    Query.validateLimit_ = function (params) {\n        if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n            throw new Error('Query: Can\\'t combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.');\n        }\n    };\n    /**\n     * Validates that no other order by call has been made\n     * @param {!string} fnName\n     * @private\n     */\n    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\n        if (this.orderByCalled_ === true) {\n            throw new Error(fnName + ': You can\\'t combine multiple orderBy calls.');\n        }\n    };\n    /**\n     * @return {!QueryParams}\n     */\n    Query.prototype.getQueryParams = function () {\n        return this.queryParams_;\n    };\n    /**\n     * @return {!Reference}\n     */\n    Query.prototype.getRef = function () {\n        validateArgCount('Query.ref', 0, 0, arguments.length);\n        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n        // method gets called.\n        return new Query.__referenceConstructor(this.repo, this.path);\n    };\n    /**\n     * @param {!string} eventType\n     * @param {!function(DataSnapshot, string=)} callback\n     * @param {(function(Error)|Object)=} cancelCallbackOrContext\n     * @param {Object=} context\n     * @return {!function(DataSnapshot, string=)}\n     */\n    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\n        validateArgCount('Query.on', 2, 4, arguments.length);\n        validateEventType('Query.on', 1, eventType, false);\n        validateCallback('Query.on', 2, callback, false);\n        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n        if (eventType === 'value') {\n            this.onValueEvent(callback, ret.cancel, ret.context);\n        }\n        else {\n            var callbacks = {};\n            callbacks[eventType] = callback;\n            this.onChildEvent(callbacks, ret.cancel, ret.context);\n        }\n        return callback;\n    };\n    /**\n     * @param {!function(!DataSnapshot)} callback\n     * @param {?function(Error)} cancelCallback\n     * @param {?Object} context\n     * @protected\n     */\n    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\n        var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);\n        this.repo.addEventCallbackForQuery(this, container);\n    };\n    /**\n     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n     * @param {?function(Error)} cancelCallback\n     * @param {?Object} context\n     * @protected\n     */\n    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\n        var container = new ChildEventRegistration(callbacks, cancelCallback, context);\n        this.repo.addEventCallbackForQuery(this, container);\n    };\n    /**\n     * @param {string=} eventType\n     * @param {(function(!DataSnapshot, ?string=))=} callback\n     * @param {Object=} context\n     */\n    Query.prototype.off = function (eventType, callback, context) {\n        validateArgCount('Query.off', 0, 3, arguments.length);\n        validateEventType('Query.off', 1, eventType, true);\n        validateCallback('Query.off', 2, callback, true);\n        validateContextObject('Query.off', 3, context, true);\n        var container = null;\n        var callbacks = null;\n        if (eventType === 'value') {\n            var valueCallback = callback || null;\n            container = new ValueEventRegistration(valueCallback, null, context || null);\n        }\n        else if (eventType) {\n            if (callback) {\n                callbacks = {};\n                callbacks[eventType] = callback;\n            }\n            container = new ChildEventRegistration(callbacks, null, context || null);\n        }\n        this.repo.removeEventCallbackForQuery(this, container);\n    };\n    /**\n     * Attaches a listener, waits for the first event, and then removes the listener\n     * @param {!string} eventType\n     * @param {!function(!DataSnapshot, string=)} userCallback\n     * @param cancelOrContext\n     * @param context\n     * @return {!firebase.Promise}\n     */\n    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {\n        var _this = this;\n        validateArgCount('Query.once', 1, 4, arguments.length);\n        validateEventType('Query.once', 1, eventType, false);\n        validateCallback('Query.once', 2, userCallback, true);\n        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);\n        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n        // against the Promise specification.\n        var firstCall = true;\n        var deferred = new Deferred();\n        attachDummyErrorHandler(deferred.promise);\n        var onceCallback = function (snapshot) {\n            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n            // triggers multiple events (e.g. child_added or child_changed).\n            if (firstCall) {\n                firstCall = false;\n                _this.off(eventType, onceCallback);\n                if (userCallback) {\n                    userCallback.bind(ret.context)(snapshot);\n                }\n                deferred.resolve(snapshot);\n            }\n        };\n        this.on(eventType, onceCallback, /*cancel=*/ function (err) {\n            _this.off(eventType, onceCallback);\n            if (ret.cancel)\n                ret.cancel.bind(ret.context)(err);\n            deferred.reject(err);\n        });\n        return deferred.promise;\n    };\n    /**\n     * Set a limit and anchor it to the start of the window.\n     * @param {!number} limit\n     * @return {!Query}\n     */\n    Query.prototype.limitToFirst = function (limit) {\n        validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n        if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n            throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n        }\n        if (this.queryParams_.hasLimit()) {\n            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +\n                'limitToFirst, or limitToLast).');\n        }\n        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n    };\n    /**\n     * Set a limit and anchor it to the end of the window.\n     * @param {!number} limit\n     * @return {!Query}\n     */\n    Query.prototype.limitToLast = function (limit) {\n        validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n        if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n            throw new Error('Query.limitToLast: First argument must be a positive integer.');\n        }\n        if (this.queryParams_.hasLimit()) {\n            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +\n                'limitToFirst, or limitToLast).');\n        }\n        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\n    };\n    /**\n     * Given a child path, return a new query ordered by the specified grandchild path.\n     * @param {!string} path\n     * @return {!Query}\n     */\n    Query.prototype.orderByChild = function (path) {\n        validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n        if (path === '$key') {\n            throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n        }\n        else if (path === '$priority') {\n            throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n        }\n        else if (path === '$value') {\n            throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n        }\n        validatePathString('Query.orderByChild', 1, path, false);\n        this.validateNoPreviousOrderByCall_('Query.orderByChild');\n        var parsedPath = new Path(path);\n        if (parsedPath.isEmpty()) {\n            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n        }\n        var index = new PathIndex(parsedPath);\n        var newParams = this.queryParams_.orderBy(index);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the KeyIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByKey = function () {\n        validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByKey');\n        var newParams = this.queryParams_.orderBy(KEY_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the PriorityIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByPriority = function () {\n        validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n        var newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * Return a new query ordered by the ValueIndex\n     * @return {!Query}\n     */\n    Query.prototype.orderByValue = function () {\n        validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n        this.validateNoPreviousOrderByCall_('Query.orderByValue');\n        var newParams = this.queryParams_.orderBy(VALUE_INDEX);\n        Query.validateQueryEndpoints_(newParams);\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n    };\n    /**\n     * @param {number|string|boolean|null} value\n     * @param {?string=} name\n     * @return {!Query}\n     */\n    Query.prototype.startAt = function (value, name) {\n        if (value === void 0) { value = null; }\n        validateArgCount('Query.startAt', 0, 2, arguments.length);\n        validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n        validateKey('Query.startAt', 2, name, true);\n        var newParams = this.queryParams_.startAt(value, name);\n        Query.validateLimit_(newParams);\n        Query.validateQueryEndpoints_(newParams);\n        if (this.queryParams_.hasStart()) {\n            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +\n                'or equalTo).');\n        }\n        // Calling with no params tells us to start at the beginning.\n        if (value === undefined) {\n            value = null;\n            name = null;\n        }\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n    };\n    /**\n     * @param {number|string|boolean|null} value\n     * @param {?string=} name\n     * @return {!Query}\n     */\n    Query.prototype.endAt = function (value, name) {\n        if (value === void 0) { value = null; }\n        validateArgCount('Query.endAt', 0, 2, arguments.length);\n        validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n        validateKey('Query.endAt', 2, name, true);\n        var newParams = this.queryParams_.endAt(value, name);\n        Query.validateLimit_(newParams);\n        Query.validateQueryEndpoints_(newParams);\n        if (this.queryParams_.hasEnd()) {\n            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +\n                'equalTo).');\n        }\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n    };\n    /**\n     * Load the selection of children with exactly the specified value, and, optionally,\n     * the specified name.\n     * @param {number|string|boolean|null} value\n     * @param {string=} name\n     * @return {!Query}\n     */\n    Query.prototype.equalTo = function (value, name) {\n        validateArgCount('Query.equalTo', 1, 2, arguments.length);\n        validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n        validateKey('Query.equalTo', 2, name, true);\n        if (this.queryParams_.hasStart()) {\n            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +\n                'equalTo).');\n        }\n        if (this.queryParams_.hasEnd()) {\n            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +\n                'equalTo).');\n        }\n        return this.startAt(value, name).endAt(value, name);\n    };\n    /**\n     * @return {!string} URL for this location.\n     */\n    Query.prototype.toString = function () {\n        validateArgCount('Query.toString', 0, 0, arguments.length);\n        return this.repo.toString() + this.path.toUrlEncodedString();\n    };\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n    // for end-users.\n    Query.prototype.toJSON = function () {\n        // An optional spacer argument is unnecessary for a string.\n        validateArgCount('Query.toJSON', 0, 1, arguments.length);\n        return this.toString();\n    };\n    /**\n     * An object representation of the query parameters used by this Query.\n     * @return {!Object}\n     */\n    Query.prototype.queryObject = function () {\n        return this.queryParams_.getQueryObject();\n    };\n    /**\n     * @return {!string}\n     */\n    Query.prototype.queryIdentifier = function () {\n        var obj = this.queryObject();\n        var id = ObjectToUniqueKey(obj);\n        return (id === '{}') ? 'default' : id;\n    };\n    /**\n     * Return true if this query and the provided query are equivalent; otherwise, return false.\n     * @param {Query} other\n     * @return {boolean}\n     */\n    Query.prototype.isEqual = function (other) {\n        validateArgCount('Query.isEqual', 1, 1, arguments.length);\n        if (!(other instanceof Query)) {\n            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n            throw new Error(error);\n        }\n        var sameRepo = (this.repo === other.repo);\n        var samePath = this.path.equals(other.path);\n        var sameQueryIdentifier = (this.queryIdentifier() === other.queryIdentifier());\n        return (sameRepo && samePath && sameQueryIdentifier);\n    };\n    /**\n     * Helper used by .on and .once to extract the context and or cancel arguments.\n     * @param {!string} fnName The function name (on or once)\n     * @param {(function(Error)|Object)=} cancelOrContext\n     * @param {Object=} context\n     * @return {{cancel: ?function(Error), context: ?Object}}\n     * @private\n     */\n    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\n        var ret = { cancel: null, context: null };\n        if (cancelOrContext && context) {\n            ret.cancel = cancelOrContext;\n            validateCallback(fnName, 3, ret.cancel, true);\n            ret.context = context;\n            validateContextObject(fnName, 4, ret.context, true);\n        }\n        else if (cancelOrContext) {\n            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n                ret.context = cancelOrContext;\n            }\n            else if (typeof cancelOrContext === 'function') {\n                ret.cancel = cancelOrContext;\n            }\n            else {\n                throw new Error(errorPrefix(fnName, 3, true) +\n                    ' must either be a cancel callback or a context object.');\n            }\n        }\n        return ret;\n    };\n    Object.defineProperty(Query.prototype, \"ref\", {\n        get: function () {\n            return this.getRef();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Query;\n}());\nexport { Query };\n\n\n"]}