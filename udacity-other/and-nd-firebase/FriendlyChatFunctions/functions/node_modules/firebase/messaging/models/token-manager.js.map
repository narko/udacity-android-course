{"version":3,"sources":["src/messaging/models/token-manager.ts","messaging/models/token-manager.js"],"names":["FCM_TOKEN_DETAILS_DB","FCM_TOKEN_OBJ_STORE","FCM_TOKEN_DETAILS_DB_VERSION","TokenManager","errorFactory_","map","openDbPromise_","prototype","openDatabase_","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","error","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","keyPath","createIndex","unique","closeDatabase","_this","then","close","getTokenDetailsFromToken","fcmToken","transaction","index","get","getTokenDetailsFromSWScope_","swScope","scopeRequest","getAllTokenDetailsForSenderId_","senderId","senderIdTokens","cursorRequest","openCursor","cursor","value","push","continue","subscribeToFCM","subscription","pushSet","p256dh","auth","fcmSubscribeBody","endpoint","headers","Headers","append","subscribeOptions","method","body","fetch","ENDPOINT","response","json","fcmTokenResponse","message","create","codes","TOKEN_SUBSCRIBE_FAILED","TOKEN_SUBSCRIBE_NO_TOKEN","TOKEN_SUBSCRIBE_NO_PUSH_SET","isSameSubscription_","masterTokenDetails","saveTokenDetails_","swRegistration","fcmPushSet","details","scope","put","getSavedToken","ServiceWorkerRegistration","SW_REGISTRATION_EXPECTED","length","BAD_SENDER_ID","allTokenDetails","findIndex","tokenDetails","pushManager","getSubscription","catch","err","GET_SUBSCRIPTION_FAILED","createToken","fcmTokenDetails","subscribe","SUBSCRIPTION_OPTIONS","sub","deleteToken","token","INVALID_DELETE_TOKEN","DELETE_TOKEN_NOT_FOUND","delete","FAILED_TO_DELETE_TOKEN"],"mappings":"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","file":"token-manager.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\n\nimport {ErrorFactory} from '../../app/errors';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nconst FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nconst FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nconst FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nexport default class TokenManager {\n\n  private errorFactory_: ErrorFactory<string>;\n  private openDbPromise_: Promise<IDBDatabase>;\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n  openDatabase_() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise((resolve, reject) => {\n      const request = indexedDB.open(FCM_TOKEN_DETAILS_DB,\n        FCM_TOKEN_DETAILS_DB_VERSION);\n      request.onerror = event => {\n        reject((<IDBRequest> event.target).error);\n      };\n      request.onsuccess = event => {\n        resolve((<IDBRequest> event.target).result);\n      };\n      request.onupgradeneeded = event => {\n        var db = (<IDBRequest> event.target).result;\n\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n\n    return this.openDbPromise_;\n  }\n\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n  closeDatabase() {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(db => {\n        db.close();\n        this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n  getTokenDetailsFromToken(fcmToken) {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const index = objectStore.index('fcmToken');\n        const request = index.get(fcmToken);\n        request.onerror = function(event) {\n          reject((<IDBRequest> event.target).error);\n        };\n        request.onsuccess = function(event) {\n          resolve((<IDBRequest> event.target).result);\n        };\n      });\n    });\n  }\n\n  getTokenDetailsFromSWScope_(swScope) {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const scopeRequest = objectStore.get(swScope);\n        scopeRequest.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n\n        scopeRequest.onsuccess = event => {\n          resolve((<IDBRequest> event.target).result);\n        };\n      });\n    });\n  }\n\n  getAllTokenDetailsForSenderId_(senderId): Promise<Array<Object>> {\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise<Array<Object>>((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n\n        const senderIdTokens = [];\n\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n\n        cursorRequest.onsuccess = event => {\n          const cursor = (<IDBRequest> event.target).result;\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  subscribeToFCM(senderId, subscription, pushSet?): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody = `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (pushSet) {\n      fcmSubscribeBody += `&pushSet=${pushSet}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions)\n    .then(response => response.json())\n    .then(response => {\n      const fcmTokenResponse = response;\n      if (fcmTokenResponse['error']) {\n        const message = fcmTokenResponse['error']['message'];\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED,\n          {'message': message});\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        'token': fcmTokenResponse['token'],\n        'pushSet': fcmTokenResponse['pushSet']\n      };\n    });\n  }\n\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n  isSameSubscription_(subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (subscription.endpoint === masterTokenDetails['endpoint'] &&\n      arrayBufferToBase64(subscription['getKey']('auth')) ===\n        masterTokenDetails['auth'] &&\n      arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n        masterTokenDetails['p256dh']);\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n  saveTokenDetails_(senderId, swRegistration,\n    subscription, fcmToken, fcmPushSet) {\n    const details = {\n      'swScope': swRegistration.scope,\n      'endpoint': subscription.endpoint,\n      'auth': arrayBufferToBase64(subscription['getKey']('auth')),\n      'p256dh': arrayBufferToBase64(subscription['getKey']('p256dh')),\n      'fcmToken': fcmToken,\n      'fcmPushSet': fcmPushSet,\n      'fcmSenderId': senderId\n    };\n\n    return this.openDatabase_()\n    .then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        const request = objectStore.put(details);\n        request.onerror = event => {\n          reject((<IDBRequest> event.target).error);\n        };\n        request.onsuccess = event => {\n          resolve();\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n  getSavedToken(senderId, swRegistration) {\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.BAD_SENDER_ID));\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId)\n    .then(allTokenDetails => {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n\n      const index = allTokenDetails.findIndex(tokenDetails => {\n        return (swRegistration.scope === tokenDetails['swScope'] &&\n          senderId === tokenDetails['fcmSenderId']);\n      });\n\n      if (index === -1) {\n        return;\n      }\n\n      return allTokenDetails[index];\n    })\n    .then(tokenDetails => {\n      if (!tokenDetails) {\n        return;\n      }\n\n      return swRegistration.pushManager.getSubscription()\n      .catch(err => {\n        throw this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      })\n      .then(subscription => {\n        if (subscription &&\n          this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new FCM token.\n   */\n  createToken(senderId, swRegistration): Promise<String> {\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.BAD_SENDER_ID));\n    }\n\n    if (!(swRegistration  instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(\n        Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    // Check for existing subscription first\n    let subscription;\n    let fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription()\n    .then(subscription => {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe(\n        FCMDetails.SUBSCRIPTION_OPTIONS);\n    })\n    .then(sub => {\n      subscription = sub;\n      return this.subscribeToFCM(senderId, subscription)\n    })\n    .then(tokenDetails => {\n      fcmTokenDetails = tokenDetails;\n      return this.saveTokenDetails_(senderId, swRegistration, subscription,\n          fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    })\n    .then(() => fcmTokenDetails['token']);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n  deleteToken(token) {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n\n    return this.getTokenDetailsFromToken(token)\n    .then(details => {\n      if (!details) {\n        throw this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return  this.openDatabase_()\n      .then(db => {\n        return new Promise((resolve, reject) => {\n          const transaction = db.transaction([FCM_TOKEN_OBJ_STORE],\n              'readwrite');\n          const objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          const request = objectStore.delete(details['swScope']);\n          request.onerror = event => {\n            reject((<IDBRequest> event.target).error);\n          };\n          request.onsuccess = event => {\n            if ((<IDBRequest> event.target).result === 0) {\n              reject(this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n'use strict';\nimport { ErrorFactory } from '../../app/errors';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_DETAILS_DB = 'fcm_token_details_db';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\nvar TokenManager = (function () {\n    function TokenManager() {\n        this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n        this.openDbPromise_ = null;\n    }\n    /**\n     * Get the indexedDB as a promsie.\n     * @private\n     * @return {Promise<IDBDatabase>} The IndexedDB database\n     */\n    TokenManager.prototype.openDatabase_ = function () {\n        if (this.openDbPromise_) {\n            return this.openDbPromise_;\n        }\n        this.openDbPromise_ = new Promise(function (resolve, reject) {\n            var request = indexedDB.open(FCM_TOKEN_DETAILS_DB, FCM_TOKEN_DETAILS_DB_VERSION);\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onsuccess = function (event) {\n                resolve(event.target.result);\n            };\n            request.onupgradeneeded = function (event) {\n                var db = event.target.result;\n                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n                    keyPath: 'swScope'\n                });\n                // Make sure the sender ID can be searched\n                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n                    unique: false\n                });\n                objectStore.createIndex('fcmToken', 'fcmToken', {\n                    unique: true\n                });\n            };\n        });\n        return this.openDbPromise_;\n    };\n    /**\n     * Close the currently open database.\n     * @return {Promise<?>} Returns the result of the promise chain.\n     */\n    TokenManager.prototype.closeDatabase = function () {\n        var _this = this;\n        if (this.openDbPromise_) {\n            return this.openDbPromise_.then(function (db) {\n                db.close();\n                _this.openDbPromise_ = null;\n            });\n        }\n        return Promise.resolve();\n    };\n    /**\n     * Given a token, this method will look up the details in indexedDB.\n     * @public\n     * @param {string} fcmToken\n     * @return {Promise<Object>} The details associated with that token.\n     */\n    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n        return this.openDatabase_()\n            .then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var index = objectStore.index('fcmToken');\n                var request = index.get(fcmToken);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n        return this.openDatabase_()\n            .then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var scopeRequest = objectStore.get(swScope);\n                scopeRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                scopeRequest.onsuccess = function (event) {\n                    resolve(event.target.result);\n                };\n            });\n        });\n    };\n    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n        return this.openDatabase_()\n            .then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var senderIdTokens = [];\n                var cursorRequest = objectStore.openCursor();\n                cursorRequest.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                cursorRequest.onsuccess = function (event) {\n                    var cursor = event.target.result;\n                    if (cursor) {\n                        if (cursor.value['fcmSenderId'] === senderId) {\n                            senderIdTokens.push(cursor.value);\n                        }\n                        cursor.continue();\n                    }\n                    else {\n                        resolve(senderIdTokens);\n                    }\n                };\n            });\n        });\n    };\n    /**\n     * Given a PushSubscription and messagingSenderId, get an FCM token.\n     * @public\n     * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n     * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n     * @param  {string=} pushSet If defined this will swap the subscription for\n     * matching FCM token.\n     * @return {Promise<!Object>} Returns the FCM token to be used in place\n     * of the PushSubscription.\n     */\n    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n        var _this = this;\n        var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n        var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n        var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n            (\"endpoint=\" + subscription.endpoint + \"&\") +\n            (\"encryption_key=\" + p256dh + \"&\") +\n            (\"encryption_auth=\" + auth);\n        if (pushSet) {\n            fcmSubscribeBody += \"&pushSet=\" + pushSet;\n        }\n        var headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n        var subscribeOptions = {\n            method: 'POST',\n            headers: headers,\n            body: fcmSubscribeBody\n        };\n        return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)\n            .then(function (response) { return response.json(); })\n            .then(function (response) {\n            var fcmTokenResponse = response;\n            if (fcmTokenResponse['error']) {\n                var message = fcmTokenResponse['error']['message'];\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, { 'message': message });\n            }\n            if (!fcmTokenResponse['token']) {\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n            }\n            if (!fcmTokenResponse['pushSet']) {\n                throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n            }\n            return {\n                'token': fcmTokenResponse['token'],\n                'pushSet': fcmTokenResponse['pushSet']\n            };\n        });\n    };\n    /**\n     * Checks the that fields in the PushSubscription are equivalent to the\n     * details stores in the masterTokenDetails.\n     * @private\n     * @param  {PushSubscription} subscription The push subscription we expect\n     * the master token to match.\n     * @param  {Object}  masterTokenDetails The saved details we wish to compare\n     * with the PushSubscription\n     * @return {boolean} true if the subscription and token details are\n     * equivalent.\n     */\n    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n        // getKey() isn't defined in the PushSubscription externs file, hence\n        // subscription['getKey']('<key name>').\n        return (subscription.endpoint === masterTokenDetails['endpoint'] &&\n            arrayBufferToBase64(subscription['getKey']('auth')) ===\n                masterTokenDetails['auth'] &&\n            arrayBufferToBase64(subscription['getKey']('p256dh')) ===\n                masterTokenDetails['p256dh']);\n    };\n    /**\n     * Save the details for the fcm token for re-use at a later date.\n     * @private\n     * @param  {string} senderId The 'messagingSenderId' used for this project\n     * @param  {ServiceWorkerRegistration} swRegistration The service worker\n     * used to subscribe the user for web push\n     * @param  {PushSubscription} subscription The push subscription passed to\n     * FCM for the current token.\n     * @param  {string} fcmToken The FCM token currently used on this\n     * device.\n     * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n     * @return {Promise<void>}\n     */\n    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n        var details = {\n            'swScope': swRegistration.scope,\n            'endpoint': subscription.endpoint,\n            'auth': arrayBufferToBase64(subscription['getKey']('auth')),\n            'p256dh': arrayBufferToBase64(subscription['getKey']('p256dh')),\n            'fcmToken': fcmToken,\n            'fcmPushSet': fcmPushSet,\n            'fcmSenderId': senderId\n        };\n        return this.openDatabase_()\n            .then(function (db) {\n            return new Promise(function (resolve, reject) {\n                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                var request = objectStore.put(details);\n                request.onerror = function (event) {\n                    reject(event.target.error);\n                };\n                request.onsuccess = function (event) {\n                    resolve();\n                };\n            });\n        });\n    };\n    /**\n     * Returns the saved FCM Token if one is available and still valid,\n     * otherwise `null` is returned.\n     * @param {string} senderId This should be the sender ID associated with the\n     * FCM Token being retrieved.\n     * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n     * to subscribe the user to push.\n     * @return {Promise<string> | Promise} Returns the saved FCM Token if\n     * avilable and valid.\n     * @export\n     */\n    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n        }\n        return this.getAllTokenDetailsForSenderId_(senderId)\n            .then(function (allTokenDetails) {\n            if (allTokenDetails.length === 0) {\n                return;\n            }\n            var index = allTokenDetails.findIndex(function (tokenDetails) {\n                return (swRegistration.scope === tokenDetails['swScope'] &&\n                    senderId === tokenDetails['fcmSenderId']);\n            });\n            if (index === -1) {\n                return;\n            }\n            return allTokenDetails[index];\n        })\n            .then(function (tokenDetails) {\n            if (!tokenDetails) {\n                return;\n            }\n            return swRegistration.pushManager.getSubscription()\n                .catch(function (err) {\n                throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n            })\n                .then(function (subscription) {\n                if (subscription &&\n                    _this.isSameSubscription_(subscription, tokenDetails)) {\n                    return tokenDetails['fcmToken'];\n                }\n            });\n        });\n    };\n    /**\n     * Creates a new FCM token.\n     */\n    TokenManager.prototype.createToken = function (senderId, swRegistration) {\n        var _this = this;\n        if (typeof senderId !== 'string' || senderId.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n        }\n        if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n        }\n        // Check for existing subscription first\n        var subscription;\n        var fcmTokenDetails;\n        return swRegistration.pushManager.getSubscription()\n            .then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n        })\n            .then(function (sub) {\n            subscription = sub;\n            return _this.subscribeToFCM(senderId, subscription);\n        })\n            .then(function (tokenDetails) {\n            fcmTokenDetails = tokenDetails;\n            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n        })\n            .then(function () { return fcmTokenDetails['token']; });\n    };\n    /**\n     * This method deletes details of the current FCM token.\n     * It's returning a promise in case we need to move to an async\n     * method for deleting at a later date.\n     * @param {string} token Token to be deleted\n     * @return {Promise<Object>} Resolves once the FCM token details have been\n     * deleted and returns the deleted details.\n     */\n    TokenManager.prototype.deleteToken = function (token) {\n        var _this = this;\n        if (typeof token !== 'string' || token.length === 0) {\n            return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n        }\n        return this.getTokenDetailsFromToken(token)\n            .then(function (details) {\n            if (!details) {\n                throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n            }\n            return _this.openDatabase_()\n                .then(function (db) {\n                return new Promise(function (resolve, reject) {\n                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n                    var request = objectStore.delete(details['swScope']);\n                    request.onerror = function (event) {\n                        reject(event.target.error);\n                    };\n                    request.onsuccess = function (event) {\n                        if (event.target.result === 0) {\n                            reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n                            return;\n                        }\n                        resolve(details);\n                    };\n                });\n            });\n        });\n    };\n    return TokenManager;\n}());\nexport default TokenManager;\n\n\n"]}