{"version":3,"sources":["../src/storage/task.ts","storage/task.js"],"names":["fbsTaskEnums","fbsArgs","fbsArray","errors","fbsPromiseimpl","fbsRequests","typeUtils","UploadTask","ref","authWrapper","location","mappings","blob","metadata","_this","transferred_","needToFetchStatus_","needToFetchMetadata_","observers_","error_","uploadUrl_","request_","chunkMultiplier_","resolve_","reject_","ref_","authWrapper_","location_","blob_","metadata_","mappings_","resumable_","shouldDoResumable_","state_","RUNNING","errorHandler_","error","codeEquals","Code","CANCELED","completeTransitions_","transition_","ERROR","metadataErrorHandler_","promise_","make","resolve","reject","start_","then","prototype","makeProgressCallback_","sizeBefore","loaded","total","updateProgress_","size","createResumable_","fetchStatus_","fetchMetadata_","continueUpload_","oneShotUpload_","resolveToken_","callback","getAuthToken","authToken","CANCELING","PAUSING","PAUSED","requestInfo","createResumableUpload","createRequest","makeRequest","getPromise","url","getResumableUploadStatus","statusRequest","status","current","finalized","chunkSize","resumableUploadChunkSize","ResumableUploadStatus","continueResumableUpload","e","uploadRequest","newStatus","increaseMultiplier_","SUCCESS","currentSize","getMetadata","metadataRequest","multipartUpload","multipartRequest","transferred","old","notifyObservers_","state","cancel","wasPaused","canceled","Object","defineProperty","get","externalState","taskStateFromInternalTaskState","enumerable","configurable","on","type","nextOrObserver","completed","undefined","typeValidator","_p","STATE_CHANGED","nextOrObserverMessage","nextValidator","nullFunctionSpec","validator","observerValidator","looseObjectSpec","nextOrObserverValidator","p","anyDefined","isJustDef","specs","stringSpec","validate","arguments","self","makeBinder","binder","opt_complete","observer","addObserver_","removeObserver_","binderNextOrObserverValidator","binderSpecs","typeOnly","onFulfilled","onRejected","catch","push","notifyObserver_","remove","finishPromise_","observers","clone","forEach","triggered","bind","snapshot","toCall","next","complete","resume","valid","pause"],"mappings":"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","file":"task.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\n\nimport {AuthWrapper} from './implementation/authwrapper';\nimport {FbsBlob} from './implementation/blob';\nimport {FirebaseStorageError} from './implementation/error';\nimport {InternalTaskState} from './implementation/taskenums';\nimport {Metadata} from './metadata';\nimport {NextFn, ErrorFn, CompleteFn, Unsubscribe, Observer} from './implementation/observer';\nimport {Request} from './implementation/request';\nimport * as RequestExports from './implementation/request';\nimport {Subscribe} from './implementation/observer';\nimport {TaskEvent, TaskState} from './implementation/taskenums';\nimport {UploadTaskSnapshot} from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport {ArgSpec} from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport {async as fbsAsync} from './implementation/async';\nimport {errors as fbsErrors} from './implementation/error';\nimport * as errors from './implementation/error';\nimport {Location} from './implementation/location';\nimport * as fbsMetadata from './implementation/metadata';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport {RequestInfo} from './implementation/requestinfo';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\nimport {Reference} from './reference';\n\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nexport class UploadTask {\n  private ref_: Reference;\n  private authWrapper_: AuthWrapper;\n  private location_: Location;\n  private blob_: FbsBlob;\n  private metadata_: Metadata|null;\n  private mappings_: fbsMetadata.Mappings;\n  private transferred_: number = 0;\n  private needToFetchStatus_: boolean = false;\n  private needToFetchMetadata_: boolean = false;\n  private observers_: Observer<UploadTaskSnapshot>[] = [];\n  private resumable_: boolean;\n  private state_: InternalTaskState;\n  private error_: Error|null = null;\n  private uploadUrl_: string|null = null;\n  private request_: Request<any>|null = null;\n  private chunkMultiplier_: number = 1;\n  private errorHandler_: (p1: FirebaseStorageError) => void;\n  private metadataErrorHandler_: (p1: FirebaseStorageError) => void;\n  private resolve_:\n      ((p1: UploadTaskSnapshot) => void) | null = null;\n  private reject_: ((p1: Error) => void) | null = null;\n  private promise_: Promise<UploadTaskSnapshot>;\n\n  /**\n   * @param ref The firebaseStorage.Reference object this task came\n   *     from, untyped to avoid cyclic dependencies.\n   * @param blob The blob to upload.\n   */\n  constructor(\n      ref: Reference, authWrapper: AuthWrapper, location: Location,\n      mappings: fbsMetadata.Mappings, blob: FbsBlob, metadata: Metadata|null = null) {\n    this.ref_ = ref;\n    this.authWrapper_ = authWrapper;\n    this.location_ = location;\n    this.blob_ = blob;\n    this.metadata_ = metadata;\n    this.mappings_ = mappings;\n    this.resumable_ = this.shouldDoResumable_(this.blob_);\n    this.state_ = InternalTaskState.RUNNING;\n    this.errorHandler_ = (error) => {\n      this.request_ = null;\n      this.chunkMultiplier_ = 1;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.needToFetchStatus_ = true;\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.metadataErrorHandler_ = (error) => {\n      this.request_ = null;\n      if (error.codeEquals(errors.Code.CANCELED)) {\n        this.completeTransitions_();\n      } else {\n        this.error_ = error;\n        this.transition_(InternalTaskState.ERROR);\n      }\n    };\n    this.promise_ = fbsPromiseimpl.make((resolve, reject) => {\n      this.resolve_ = resolve;\n      this.reject_ = reject;\n      this.start_();\n    });\n\n    // Prevent uncaught rejections on the internal promise from bubbling out\n    // to the top level with a dummy handler.\n    this.promise_.then(null, () => {});\n  }\n\n  private makeProgressCallback_():\n      (p1: number, p2: number) => void {\n    const sizeBefore = this.transferred_;\n    return (loaded, total) => {\n      this.updateProgress_(sizeBefore + loaded);\n    };\n  }\n\n  private shouldDoResumable_(blob: FbsBlob): boolean {\n    return blob.size() > 256 * 1024;\n  }\n\n  private start_() {\n    if (this.state_ !== InternalTaskState.RUNNING) {\n      // This can happen if someone pauses us in a resume callback, for example.\n      return;\n    }\n    if (this.request_ !== null) {\n      return;\n    }\n    if (this.resumable_) {\n      if (this.uploadUrl_ === null) {\n        this.createResumable_();\n      } else {\n        if (this.needToFetchStatus_) {\n          this.fetchStatus_();\n        } else {\n          if (this.needToFetchMetadata_) {\n            // Happens if we miss the metadata on upload completion.\n            this.fetchMetadata_();\n          } else {\n            this.continueUpload_();\n          }\n        }\n      }\n    } else {\n      this.oneShotUpload_();\n    }\n  }\n\n  private resolveToken_(callback: (p1: string|null) => void) {\n    this.authWrapper_.getAuthToken().then((authToken) => {\n      switch (this.state_) {\n        case InternalTaskState.RUNNING:\n          callback(authToken);\n          break;\n        case InternalTaskState.CANCELING:\n          this.transition_(InternalTaskState.CANCELED);\n          break;\n        case InternalTaskState.PAUSING:\n          this.transition_(InternalTaskState.PAUSED);\n          break;\n        default:\n      }\n    });\n  }\n\n  // TODO(andysoto): assert false\n\n  private createResumable_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.createResumableUpload(\n          this.authWrapper_, this.location_, this.mappings_, this.blob_,\n          this.metadata_);\n      const createRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = createRequest;\n      createRequest.getPromise().then(\n          (url: string) => {\n            this.request_ = null;\n            this.uploadUrl_ = url;\n            this.needToFetchStatus_ = false;\n            this.completeTransitions_();\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private fetchStatus_() {\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = (this.uploadUrl_ as string);\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.getResumableUploadStatus(\n          this.authWrapper_, this.location_, url, this.blob_);\n      const statusRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = statusRequest;\n      statusRequest.getPromise().then(\n          (status) => {\n            status = (status as fbsRequests.ResumableUploadStatus);\n            this.request_ = null;\n            this.updateProgress_(status.current);\n            this.needToFetchStatus_ = false;\n            if (status.finalized) {\n              this.needToFetchMetadata_ = true;\n            }\n            this.completeTransitions_();\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private continueUpload_() {\n    const chunkSize =\n        fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n    const status = new fbsRequests.ResumableUploadStatus(\n        this.transferred_, this.blob_.size());\n\n    // TODO(andysoto): assert(this.uploadUrl_ !== null);\n    const url = (this.uploadUrl_ as string);\n    this.resolveToken_((authToken) => {\n    let requestInfo;\n      try {\n        requestInfo = fbsRequests.continueResumableUpload(\n            this.location_, this.authWrapper_, url, this.blob_, chunkSize,\n            this.mappings_, status, this.makeProgressCallback_());\n      } catch (e) {\n        this.error_ = e;\n        this.transition_(InternalTaskState.ERROR);\n        return;\n      }\n      const uploadRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = uploadRequest;\n      uploadRequest.getPromise().then(\n          (newStatus: fbsRequests.ResumableUploadStatus) => {\n            this.increaseMultiplier_();\n            this.request_ = null;\n            this.updateProgress_(newStatus.current);\n            if (newStatus.finalized) {\n              this.metadata_ = newStatus.metadata;\n              this.transition_(InternalTaskState.SUCCESS);\n            } else {\n              this.completeTransitions_();\n            }\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private increaseMultiplier_() {\n    const currentSize =\n        fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n\n    // Max chunk size is 32M.\n    if (currentSize < 32 * 1024 * 1024) {\n      this.chunkMultiplier_ *= 2;\n    }\n  }\n\n  private fetchMetadata_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.getMetadata(\n          this.authWrapper_, this.location_, this.mappings_);\n      const metadataRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = metadataRequest;\n      metadataRequest.getPromise().then(\n          (metadata) => {\n            this.request_ = null;\n            this.metadata_ = metadata;\n            this.transition_(InternalTaskState.SUCCESS);\n          },\n          this.metadataErrorHandler_);\n    });\n  }\n\n  private oneShotUpload_() {\n    this.resolveToken_((authToken) => {\n      const requestInfo = fbsRequests.multipartUpload(\n          this.authWrapper_, this.location_, this.mappings_, this.blob_,\n          this.metadata_);\n      const multipartRequest = this.authWrapper_.makeRequest(requestInfo, authToken);\n      this.request_ = multipartRequest;\n      multipartRequest.getPromise().then(\n          (metadata) => {\n            this.request_ = null;\n            this.metadata_ = metadata;\n            this.updateProgress_(this.blob_.size());\n            this.transition_(InternalTaskState.SUCCESS);\n          },\n          this.errorHandler_);\n    });\n  }\n\n  private updateProgress_(transferred: number) {\n    const old = this.transferred_;\n    this.transferred_ = transferred;\n\n    // A progress update can make the \"transferred\" value smaller (e.g. a\n    // partial upload not completed by server, after which the \"transferred\"\n    // value may reset to the value at the beginning of the request).\n    if (this.transferred_ !== old) {\n      this.notifyObservers_();\n    }\n  }\n\n  private transition_(state: InternalTaskState) {\n    if (this.state_ === state) {\n      return;\n    }\n    switch (state) {\n      case InternalTaskState.CANCELING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.PAUSING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING);\n        this.state_ = state;\n        if (this.request_ !== null) {\n          this.request_.cancel();\n        }\n        break;\n      case InternalTaskState.RUNNING:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.PAUSING);\n        const wasPaused = this.state_ === InternalTaskState.PAUSED;\n        this.state_ = state;\n        if (wasPaused) {\n          this.notifyObservers_();\n          this.start_();\n        }\n        break;\n      case InternalTaskState.PAUSED:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.CANCELED:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.PAUSED ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.error_ = errors.canceled();\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.ERROR:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n      case InternalTaskState.SUCCESS:\n\n        // TODO(andysoto):\n        // assert(this.state_ === InternalTaskState.RUNNING ||\n        //        this.state_ === InternalTaskState.PAUSING ||\n        //        this.state_ === InternalTaskState.CANCELING);\n        this.state_ = state;\n        this.notifyObservers_();\n        break;\n    }\n  }\n\n  private completeTransitions_() {\n    switch (this.state_) {\n      case InternalTaskState.PAUSING:\n        this.transition_(InternalTaskState.PAUSED);\n        break;\n      case InternalTaskState.CANCELING:\n        this.transition_(InternalTaskState.CANCELED);\n        break;\n      case InternalTaskState.RUNNING:\n        this.start_();\n        break;\n      default:\n\n        // TODO(andysoto): assert(false);\n        break;\n    }\n  }\n\n  get snapshot(): UploadTaskSnapshot {\n    const externalState =\n        fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n    return new UploadTaskSnapshot(\n        this.transferred_, this.blob_.size(), externalState, this.metadata_,\n        this, this.ref_);\n  }\n\n  /**\n   * Adds a callback for an event.\n   * @param type The type of event to listen for.\n   */\n  on(type: TaskEvent, nextOrObserver = undefined, error = undefined,\n     completed = undefined): Unsubscribe | Subscribe<UploadTaskSnapshot> {\n    function typeValidator(_p: any) {\n      if (type !== TaskEvent.STATE_CHANGED) {\n        throw `Expected one of the event types: [${TaskEvent.STATE_CHANGED}].`;\n      }\n    }\n    const nextOrObserverMessage =\n        'Expected a function or an Object with one of ' +\n        '`next`, `error`, `complete` properties.';\n    const nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n    const observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n\n    function nextOrObserverValidator(p: any) {\n      try {\n        nextValidator(p);\n        return;\n      } catch (e) {\n      }\n      try {\n        observerValidator(p);\n        const anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) ||\n            typeUtils.isJustDef(p['complete']);\n        if (!anyDefined) {\n          throw '';\n        }\n        return;\n      } catch (e) {\n        throw nextOrObserverMessage;\n      }\n    }\n    const specs = [\n      fbsArgs.stringSpec(typeValidator),\n      fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n      fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n    ];\n    fbsArgs.validate('on', specs, arguments);\n    const self = this;\n\n    function makeBinder(specs: ArgSpec[]|null): Subscribe<UploadTaskSnapshot> {\n      function binder(\n          nextOrObserver: NextFn<UploadTaskSnapshot> | {[name: string]: string|null} | null,\n          error?: ErrorFn | null,\n          opt_complete?: CompleteFn | null) {\n        if (specs !== null) {\n          fbsArgs.validate('on', specs, arguments);\n        }\n        const observer = new Observer(nextOrObserver, error, completed);\n        self.addObserver_(observer);\n        return () => {\n          self.removeObserver_(observer);\n        };\n      }\n      return binder;\n    }\n\n    function binderNextOrObserverValidator(p: any) {\n      if (p === null) {\n        throw nextOrObserverMessage;\n      }\n      nextOrObserverValidator(p);\n    }\n    const binderSpecs = [\n      fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n      fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n    ];\n    const typeOnly =\n        !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) ||\n          typeUtils.isJustDef(completed));\n    if (typeOnly) {\n      return makeBinder(binderSpecs);\n    } else {\n      return makeBinder(null)(nextOrObserver, error, completed);\n    }\n  }\n\n  /**\n   * This object behaves like a Promise, and resolves with its snapshot data\n   * when the upload completes.\n   *     The fulfillment callback. Promise chaining works as normal.\n   * @param onRejected The rejection callback.\n   */\n  then<U>(onFulfilled?: ((value: UploadTaskSnapshot) => U | PromiseLike<U>) | null, onRejected?: ((error: any) => U | PromiseLike<U>) | null): Promise<U> {\n      return this.promise_.then<U>(\n        (onFulfilled as (value: UploadTaskSnapshot) => U | PromiseLike<U>),\n        (onRejected as ((error: any) => PromiseLike<U>) | null));\n  }\n\n  /**\n   * Equivalent to calling `then(null, onRejected)`.\n   */\n  catch<T>(onRejected: (p1: Error) => T | PromiseLike<T>): Promise<T> {\n    return this.then(null, onRejected);\n  }\n\n  /**\n   * Adds the given observer.\n   */\n  private addObserver_(observer: Observer<UploadTaskSnapshot>) {\n    this.observers_.push(observer);\n    this.notifyObserver_(observer);\n  }\n\n  /**\n   * Removes the given observer.\n   */\n  private removeObserver_(observer: Observer<UploadTaskSnapshot>) {\n    fbsArray.remove(this.observers_, observer);\n  }\n\n  private notifyObservers_() {\n    this.finishPromise_();\n    const observers = fbsArray.clone(this.observers_);\n    observers.forEach((observer) => {\n      this.notifyObserver_(observer);\n    });\n  }\n\n  private finishPromise_() {\n    if (this.resolve_ !== null) {\n      let triggered = true;\n      switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n        case TaskState.SUCCESS:\n          fbsAsync(this.resolve_.bind(null, this.snapshot))();\n          break;\n        case TaskState.CANCELED:\n        case TaskState.ERROR:\n          const toCall = (this.reject_ as ((p1: Error) => void));\n          fbsAsync(toCall.bind(null, (this.error_ as Error)))();\n          break;\n        default:\n          triggered = false;\n          break;\n      }\n      if (triggered) {\n        this.resolve_ = null;\n        this.reject_ = null;\n      }\n    }\n  }\n\n  private notifyObserver_(observer: Observer<UploadTaskSnapshot>) {\n    const externalState =\n        fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n    switch (externalState) {\n      case TaskState.RUNNING:\n      case TaskState.PAUSED:\n        if (observer.next !== null) {\n          fbsAsync(observer.next.bind(observer, this.snapshot))();\n        }\n        break;\n      case TaskState.SUCCESS:\n        if (observer.complete !== null) {\n          fbsAsync(observer.complete.bind(observer))();\n        }\n        break;\n      case TaskState.CANCELED:\n      case TaskState.ERROR:\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, (this.error_ as Error)))();\n        }\n        break;\n      default:\n\n        // TODO(andysoto): assert(false);\n        if (observer.error !== null) {\n          fbsAsync(observer.error.bind(observer, (this.error_ as Error)))();\n        }\n    }\n  }\n\n  /**\n   * Resumes a paused task. Has no effect on a currently running or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  resume(): boolean {\n    fbsArgs.validate('resume', [], arguments);\n    const valid = this.state_ === InternalTaskState.PAUSED ||\n        this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.RUNNING);\n    }\n    return valid;\n  }\n\n  /**\n   * Pauses a currently running task. Has no effect on a paused or failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  pause(): boolean {\n    fbsArgs.validate('pause', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING;\n    if (valid) {\n      this.transition_(InternalTaskState.PAUSING);\n    }\n    return valid;\n  }\n\n  /**\n   * Cancels a currently running or paused task. Has no effect on a complete or\n   * failed task.\n   * @return True if the operation took effect, false if ignored.\n   */\n  cancel(): boolean {\n    fbsArgs.validate('cancel', [], arguments);\n    const valid = this.state_ === InternalTaskState.RUNNING ||\n        this.state_ === InternalTaskState.PAUSING;\n    if (valid) {\n      this.transition_(InternalTaskState.CANCELING);\n    }\n    return valid;\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines types for interacting with blob transfer tasks.\n */\nimport { InternalTaskState } from './implementation/taskenums';\nimport { Observer } from './implementation/observer';\nimport { TaskEvent, TaskState } from './implementation/taskenums';\nimport { UploadTaskSnapshot } from './tasksnapshot';\nimport * as fbsArgs from './implementation/args';\nimport * as fbsArray from './implementation/array';\nimport { async as fbsAsync } from './implementation/async';\nimport * as errors from './implementation/error';\nimport * as fbsPromiseimpl from './implementation/promise_external';\nimport * as fbsRequests from './implementation/requests';\nimport * as fbsTaskEnums from './implementation/taskenums';\nimport * as typeUtils from './implementation/type';\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n */\nvar UploadTask = (function () {\n    /**\n     * @param ref The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob The blob to upload.\n     */\n    function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {\n        if (metadata === void 0) { metadata = null; }\n        var _this = this;\n        this.transferred_ = 0;\n        this.needToFetchStatus_ = false;\n        this.needToFetchMetadata_ = false;\n        this.observers_ = [];\n        this.error_ = null;\n        this.uploadUrl_ = null;\n        this.request_ = null;\n        this.chunkMultiplier_ = 1;\n        this.resolve_ = null;\n        this.reject_ = null;\n        this.ref_ = ref;\n        this.authWrapper_ = authWrapper;\n        this.location_ = location;\n        this.blob_ = blob;\n        this.metadata_ = metadata;\n        this.mappings_ = mappings;\n        this.resumable_ = this.shouldDoResumable_(this.blob_);\n        this.state_ = InternalTaskState.RUNNING;\n        this.errorHandler_ = function (error) {\n            _this.request_ = null;\n            _this.chunkMultiplier_ = 1;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.needToFetchStatus_ = true;\n                _this.completeTransitions_();\n            }\n            else {\n                _this.error_ = error;\n                _this.transition_(InternalTaskState.ERROR);\n            }\n        };\n        this.metadataErrorHandler_ = function (error) {\n            _this.request_ = null;\n            if (error.codeEquals(errors.Code.CANCELED)) {\n                _this.completeTransitions_();\n            }\n            else {\n                _this.error_ = error;\n                _this.transition_(InternalTaskState.ERROR);\n            }\n        };\n        this.promise_ = fbsPromiseimpl.make(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n            _this.start_();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this.promise_.then(null, function () { });\n    }\n    UploadTask.prototype.makeProgressCallback_ = function () {\n        var _this = this;\n        var sizeBefore = this.transferred_;\n        return function (loaded, total) {\n            _this.updateProgress_(sizeBefore + loaded);\n        };\n    };\n    UploadTask.prototype.shouldDoResumable_ = function (blob) {\n        return blob.size() > 256 * 1024;\n    };\n    UploadTask.prototype.start_ = function () {\n        if (this.state_ !== InternalTaskState.RUNNING) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this.request_ !== null) {\n            return;\n        }\n        if (this.resumable_) {\n            if (this.uploadUrl_ === null) {\n                this.createResumable_();\n            }\n            else {\n                if (this.needToFetchStatus_) {\n                    this.fetchStatus_();\n                }\n                else {\n                    if (this.needToFetchMetadata_) {\n                        // Happens if we miss the metadata on upload completion.\n                        this.fetchMetadata_();\n                    }\n                    else {\n                        this.continueUpload_();\n                    }\n                }\n            }\n        }\n        else {\n            this.oneShotUpload_();\n        }\n    };\n    UploadTask.prototype.resolveToken_ = function (callback) {\n        var _this = this;\n        this.authWrapper_.getAuthToken().then(function (authToken) {\n            switch (_this.state_) {\n                case InternalTaskState.RUNNING:\n                    callback(authToken);\n                    break;\n                case InternalTaskState.CANCELING:\n                    _this.transition_(InternalTaskState.CANCELED);\n                    break;\n                case InternalTaskState.PAUSING:\n                    _this.transition_(InternalTaskState.PAUSED);\n                    break;\n                default:\n            }\n        });\n    };\n    // TODO(andysoto): assert false\n    UploadTask.prototype.createResumable_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.createResumableUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n            var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = createRequest;\n            createRequest.getPromise().then(function (url) {\n                _this.request_ = null;\n                _this.uploadUrl_ = url;\n                _this.needToFetchStatus_ = false;\n                _this.completeTransitions_();\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.fetchStatus_ = function () {\n        var _this = this;\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        var url = this.uploadUrl_;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.getResumableUploadStatus(_this.authWrapper_, _this.location_, url, _this.blob_);\n            var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = statusRequest;\n            statusRequest.getPromise().then(function (status) {\n                status = status;\n                _this.request_ = null;\n                _this.updateProgress_(status.current);\n                _this.needToFetchStatus_ = false;\n                if (status.finalized) {\n                    _this.needToFetchMetadata_ = true;\n                }\n                _this.completeTransitions_();\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.continueUpload_ = function () {\n        var _this = this;\n        var chunkSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n        var status = new fbsRequests.ResumableUploadStatus(this.transferred_, this.blob_.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        var url = this.uploadUrl_;\n        this.resolveToken_(function (authToken) {\n            var requestInfo;\n            try {\n                requestInfo = fbsRequests.continueResumableUpload(_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());\n            }\n            catch (e) {\n                _this.error_ = e;\n                _this.transition_(InternalTaskState.ERROR);\n                return;\n            }\n            var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = uploadRequest;\n            uploadRequest.getPromise().then(function (newStatus) {\n                _this.increaseMultiplier_();\n                _this.request_ = null;\n                _this.updateProgress_(newStatus.current);\n                if (newStatus.finalized) {\n                    _this.metadata_ = newStatus.metadata;\n                    _this.transition_(InternalTaskState.SUCCESS);\n                }\n                else {\n                    _this.completeTransitions_();\n                }\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.increaseMultiplier_ = function () {\n        var currentSize = fbsRequests.resumableUploadChunkSize * this.chunkMultiplier_;\n        // Max chunk size is 32M.\n        if (currentSize < 32 * 1024 * 1024) {\n            this.chunkMultiplier_ *= 2;\n        }\n    };\n    UploadTask.prototype.fetchMetadata_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.getMetadata(_this.authWrapper_, _this.location_, _this.mappings_);\n            var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = metadataRequest;\n            metadataRequest.getPromise().then(function (metadata) {\n                _this.request_ = null;\n                _this.metadata_ = metadata;\n                _this.transition_(InternalTaskState.SUCCESS);\n            }, _this.metadataErrorHandler_);\n        });\n    };\n    UploadTask.prototype.oneShotUpload_ = function () {\n        var _this = this;\n        this.resolveToken_(function (authToken) {\n            var requestInfo = fbsRequests.multipartUpload(_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);\n            var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);\n            _this.request_ = multipartRequest;\n            multipartRequest.getPromise().then(function (metadata) {\n                _this.request_ = null;\n                _this.metadata_ = metadata;\n                _this.updateProgress_(_this.blob_.size());\n                _this.transition_(InternalTaskState.SUCCESS);\n            }, _this.errorHandler_);\n        });\n    };\n    UploadTask.prototype.updateProgress_ = function (transferred) {\n        var old = this.transferred_;\n        this.transferred_ = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this.transferred_ !== old) {\n            this.notifyObservers_();\n        }\n    };\n    UploadTask.prototype.transition_ = function (state) {\n        if (this.state_ === state) {\n            return;\n        }\n        switch (state) {\n            case InternalTaskState.CANCELING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this.state_ = state;\n                if (this.request_ !== null) {\n                    this.request_.cancel();\n                }\n                break;\n            case InternalTaskState.PAUSING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING);\n                this.state_ = state;\n                if (this.request_ !== null) {\n                    this.request_.cancel();\n                }\n                break;\n            case InternalTaskState.RUNNING:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                var wasPaused = this.state_ === InternalTaskState.PAUSED;\n                this.state_ = state;\n                if (wasPaused) {\n                    this.notifyObservers_();\n                    this.start_();\n                }\n                break;\n            case InternalTaskState.PAUSED:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.CANCELED:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.error_ = errors.canceled();\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.ERROR:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n            case InternalTaskState.SUCCESS:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this.state_ = state;\n                this.notifyObservers_();\n                break;\n        }\n    };\n    UploadTask.prototype.completeTransitions_ = function () {\n        switch (this.state_) {\n            case InternalTaskState.PAUSING:\n                this.transition_(InternalTaskState.PAUSED);\n                break;\n            case InternalTaskState.CANCELING:\n                this.transition_(InternalTaskState.CANCELED);\n                break;\n            case InternalTaskState.RUNNING:\n                this.start_();\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                break;\n        }\n    };\n    Object.defineProperty(UploadTask.prototype, \"snapshot\", {\n        get: function () {\n            var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n            return new UploadTaskSnapshot(this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Adds a callback for an event.\n     * @param type The type of event to listen for.\n     */\n    UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {\n        if (nextOrObserver === void 0) { nextOrObserver = undefined; }\n        if (error === void 0) { error = undefined; }\n        if (completed === void 0) { completed = undefined; }\n        function typeValidator(_p) {\n            if (type !== TaskEvent.STATE_CHANGED) {\n                throw \"Expected one of the event types: [\" + TaskEvent.STATE_CHANGED + \"].\";\n            }\n        }\n        var nextOrObserverMessage = 'Expected a function or an Object with one of ' +\n            '`next`, `error`, `complete` properties.';\n        var nextValidator = fbsArgs.nullFunctionSpec(true).validator;\n        var observerValidator = fbsArgs.looseObjectSpec(null, true).validator;\n        function nextOrObserverValidator(p) {\n            try {\n                nextValidator(p);\n                return;\n            }\n            catch (e) {\n            }\n            try {\n                observerValidator(p);\n                var anyDefined = typeUtils.isJustDef(p['next']) || typeUtils.isJustDef(p['error']) ||\n                    typeUtils.isJustDef(p['complete']);\n                if (!anyDefined) {\n                    throw '';\n                }\n                return;\n            }\n            catch (e) {\n                throw nextOrObserverMessage;\n            }\n        }\n        var specs = [\n            fbsArgs.stringSpec(typeValidator),\n            fbsArgs.looseObjectSpec(nextOrObserverValidator, true),\n            fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n        ];\n        fbsArgs.validate('on', specs, arguments);\n        var self = this;\n        function makeBinder(specs) {\n            function binder(nextOrObserver, error, opt_complete) {\n                if (specs !== null) {\n                    fbsArgs.validate('on', specs, arguments);\n                }\n                var observer = new Observer(nextOrObserver, error, completed);\n                self.addObserver_(observer);\n                return function () {\n                    self.removeObserver_(observer);\n                };\n            }\n            return binder;\n        }\n        function binderNextOrObserverValidator(p) {\n            if (p === null) {\n                throw nextOrObserverMessage;\n            }\n            nextOrObserverValidator(p);\n        }\n        var binderSpecs = [\n            fbsArgs.looseObjectSpec(binderNextOrObserverValidator),\n            fbsArgs.nullFunctionSpec(true), fbsArgs.nullFunctionSpec(true)\n        ];\n        var typeOnly = !(typeUtils.isJustDef(nextOrObserver) || typeUtils.isJustDef(error) ||\n            typeUtils.isJustDef(completed));\n        if (typeOnly) {\n            return makeBinder(binderSpecs);\n        }\n        else {\n            return makeBinder(null)(nextOrObserver, error, completed);\n        }\n    };\n    /**\n     * This object behaves like a Promise, and resolves with its snapshot data\n     * when the upload completes.\n     *     The fulfillment callback. Promise chaining works as normal.\n     * @param onRejected The rejection callback.\n     */\n    UploadTask.prototype.then = function (onFulfilled, onRejected) {\n        return this.promise_.then(onFulfilled, onRejected);\n    };\n    /**\n     * Equivalent to calling `then(null, onRejected)`.\n     */\n    UploadTask.prototype.catch = function (onRejected) {\n        return this.then(null, onRejected);\n    };\n    /**\n     * Adds the given observer.\n     */\n    UploadTask.prototype.addObserver_ = function (observer) {\n        this.observers_.push(observer);\n        this.notifyObserver_(observer);\n    };\n    /**\n     * Removes the given observer.\n     */\n    UploadTask.prototype.removeObserver_ = function (observer) {\n        fbsArray.remove(this.observers_, observer);\n    };\n    UploadTask.prototype.notifyObservers_ = function () {\n        var _this = this;\n        this.finishPromise_();\n        var observers = fbsArray.clone(this.observers_);\n        observers.forEach(function (observer) {\n            _this.notifyObserver_(observer);\n        });\n    };\n    UploadTask.prototype.finishPromise_ = function () {\n        if (this.resolve_ !== null) {\n            var triggered = true;\n            switch (fbsTaskEnums.taskStateFromInternalTaskState(this.state_)) {\n                case TaskState.SUCCESS:\n                    fbsAsync(this.resolve_.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    var toCall = this.reject_;\n                    fbsAsync(toCall.bind(null, this.error_))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this.resolve_ = null;\n                this.reject_ = null;\n            }\n        }\n    };\n    UploadTask.prototype.notifyObserver_ = function (observer) {\n        var externalState = fbsTaskEnums.taskStateFromInternalTaskState(this.state_);\n        switch (externalState) {\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next !== null) {\n                    fbsAsync(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete !== null) {\n                    fbsAsync(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error !== null) {\n                    fbsAsync(observer.error.bind(observer, this.error_))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error !== null) {\n                    fbsAsync(observer.error.bind(observer, this.error_))();\n                }\n        }\n    };\n    /**\n     * Resumes a paused task. Has no effect on a currently running or failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.resume = function () {\n        fbsArgs.validate('resume', [], arguments);\n        var valid = this.state_ === InternalTaskState.PAUSED ||\n            this.state_ === InternalTaskState.PAUSING;\n        if (valid) {\n            this.transition_(InternalTaskState.RUNNING);\n        }\n        return valid;\n    };\n    /**\n     * Pauses a currently running task. Has no effect on a paused or failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.pause = function () {\n        fbsArgs.validate('pause', [], arguments);\n        var valid = this.state_ === InternalTaskState.RUNNING;\n        if (valid) {\n            this.transition_(InternalTaskState.PAUSING);\n        }\n        return valid;\n    };\n    /**\n     * Cancels a currently running or paused task. Has no effect on a complete or\n     * failed task.\n     * @return True if the operation took effect, false if ignored.\n     */\n    UploadTask.prototype.cancel = function () {\n        fbsArgs.validate('cancel', [], arguments);\n        var valid = this.state_ === InternalTaskState.RUNNING ||\n            this.state_ === InternalTaskState.PAUSING;\n        if (valid) {\n            this.transition_(InternalTaskState.CANCELING);\n        }\n        return valid;\n    };\n    return UploadTask;\n}());\nexport { UploadTask };\n\n\n"]}