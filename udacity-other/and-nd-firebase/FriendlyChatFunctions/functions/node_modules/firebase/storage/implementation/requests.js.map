{"version":3,"sources":["src/storage/implementation/requests.ts","storage/implementation/requests.js"],"names":["handlerCheck","metadataHandler","sharedErrorHandler","objectErrorHandler","getMetadata","updateMetadata","deleteObject","determineContentType_","metadataForUpload_","multipartUpload","checkResumeHeader_","createResumableUpload","getResumableUploadStatus","continueResumableUpload","array","errorsExports","MetadataUtils","object","type","UrlUtils","cndn","unknown","authWrapper","mappings","handler","xhr","text","metadata","fromResourceString","location","errorHandler","err","newErr","getStatus","unauthenticated","quotaExceeded","bucket","unauthorized","path","setServerResponseProp","serverResponseProp","shared","objectNotFound","urlPart","fullServerUrl","url","makeNormalUrl","method","timeout","maxOperationRetryTime","requestInfo","body","toResourceString","headers","successCodes","blob","opt_metadata","clone","size","bucketOnlyServerUrl","genBoundary","str","i","Math","random","toString","slice","boundary","metadataString","preBlobPart","postBlobPart","getBlob","cannotSliceBlob","urlParams","makeUploadUrl","maxUploadRetryTime","uploadData","ResumableUploadStatus","current","total","finalized","opt_allowed","status","getResponseHeader","e","allowed","contains","isString","sizeString","parseInt","isNaN","resumableUploadChunkSize","chunkSize","opt_status","opt_progressCallback","serverFileWrongSize","bytesLeft","bytesToUpload","min","startByte","endByte","uploadCommand","uploadStatus","newCurrent","progressCallback"],"mappings":"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","file":"requests.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods for interacting with the network.\n */\n\nimport {Metadata} from '../metadata';\n\nimport * as array from './array';\nimport {AuthWrapper} from './authwrapper';\nimport {FbsBlob} from './blob';\nimport * as errorsExports from './error';\nimport {FirebaseStorageError} from './error';\nimport {errors} from './error';\nimport {Location} from './location';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport {RequestInfo} from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport {XhrIo} from './xhrio';\n\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn: boolean) {\n  if (!cndn) {\n    throw errorsExports.unknown();\n  }\n}\n\nexport function metadataHandler(\n    authWrapper: AuthWrapper,\n    mappings: MetadataUtils.Mappings): (p1: XhrIo, p2: string) => Metadata {\n  function handler(xhr: XhrIo, text: string): Metadata {\n    let metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n    handlerCheck(metadata !== null);\n    return metadata as Metadata;\n  }\n  return handler;\n}\n\nexport function sharedErrorHandler(location: Location): (\n    p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {\n    let newErr;\n    if (xhr.getStatus() === 401) {\n      newErr = errorsExports.unauthenticated();\n    } else {\n      if (xhr.getStatus() === 402) {\n        newErr = errorsExports.quotaExceeded(location.bucket);\n      } else {\n        if (xhr.getStatus() === 403) {\n          newErr = errorsExports.unauthorized(location.path);\n        } else {\n          newErr = err;\n        }\n      }\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function objectErrorHandler(location: Location): (\n    p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {\n  let shared = sharedErrorHandler(location);\n\n  function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {\n    let newErr = shared(xhr, err);\n    if (xhr.getStatus() === 404) {\n      newErr = errorsExports.objectNotFound(location.path);\n    }\n    newErr.setServerResponseProp(err.serverResponseProp());\n    return newErr;\n  }\n  return errorHandler;\n}\n\nexport function getMetadata(\n    authWrapper: AuthWrapper, location: Location,\n    mappings: MetadataUtils.Mappings): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'GET';\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function updateMetadata(\n    authWrapper: AuthWrapper, location: Location, metadata: Metadata,\n    mappings: MetadataUtils.Mappings): RequestInfo<Metadata> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'PATCH';\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let headers = {'Content-Type': 'application/json; charset=utf-8'};\n  let timeout = authWrapper.maxOperationRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function deleteObject(\n    authWrapper: AuthWrapper, location: Location): RequestInfo<void> {\n  let urlPart = location.fullServerUrl();\n  let url = UrlUtils.makeNormalUrl(urlPart);\n  let method = 'DELETE';\n  let timeout = authWrapper.maxOperationRetryTime();\n\n  function handler(xhr: XhrIo, text: string) {}\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.successCodes = [200, 204];\n  requestInfo.errorHandler = objectErrorHandler(location);\n  return requestInfo;\n}\n\nexport function determineContentType_(\n    metadata: Metadata|null, blob: FbsBlob|null): string {\n  return metadata && metadata['contentType'] || blob && blob.type() ||\n      'application/octet-stream';\n}\n\nexport function metadataForUpload_(\n    location: Location, blob: FbsBlob, opt_metadata?: Metadata|null): Metadata {\n  let metadata = object.clone<Metadata>(opt_metadata);\n  metadata['fullPath'] = location.path;\n  metadata['size'] = blob.size();\n  if (!metadata['contentType']) {\n    metadata['contentType'] = determineContentType_(null, blob);\n  }\n  return metadata;\n}\n\nexport function multipartUpload(\n    authWrapper: AuthWrapper, location: Location, mappings: MetadataUtils.Mappings,\n    blob: FbsBlob, opt_metadata?: Metadata|null): RequestInfo<Metadata> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let headers: { [prop: string]: string } = {'X-Goog-Upload-Protocol': 'multipart'};\n\n  function genBoundary() {\n    let str = '';\n    for (let i = 0; i < 2; i++) {\n      str = str + Math.random().toString().slice(2);\n    }\n    return str;\n  }\n  let boundary = genBoundary();\n  headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let metadataString = MetadataUtils.toResourceString(metadata, mappings);\n  let preBlobPart = '--' + boundary + '\\r\\n' +\n      'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString +\n      '\\r\\n--' + boundary + '\\r\\n' +\n      'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n  let postBlobPart = '\\r\\n--' + boundary + '--';\n  let body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n  let urlParams = {'name': metadata['fullPath']};\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(\n      url, method, metadataHandler(authWrapper, mappings), timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nexport class ResumableUploadStatus {\n  finalized: boolean;\n  metadata: Metadata|null;\n\n  constructor(\n      public current: number,\n      public total: number,\n      finalized?: boolean,\n      metadata?: Metadata|null) {\n    this.finalized = !!finalized;\n    this.metadata = metadata || null;\n  }\n}\n\nexport function checkResumeHeader_(xhr: XhrIo, opt_allowed?: string[]): string {\n  let status;\n  try {\n    status = xhr.getResponseHeader('X-Goog-Upload-Status');\n  } catch (e) {\n    handlerCheck(false);\n  }\n  let allowed = opt_allowed || ['active'];\n  handlerCheck(array.contains(allowed, status));\n  return (status as string);\n}\n\nexport function createResumableUpload(\n    authWrapper: AuthWrapper, location: Location, mappings: MetadataUtils.Mappings,\n    blob: FbsBlob, opt_metadata?: Metadata|null): RequestInfo<string> {\n  let urlPart = location.bucketOnlyServerUrl();\n  let metadata = metadataForUpload_(location, blob, opt_metadata);\n  let urlParams = {'name': metadata['fullPath']};\n  let url = UrlUtils.makeUploadUrl(urlPart);\n  let method = 'POST';\n  let headers = {\n    'X-Goog-Upload-Protocol': 'resumable',\n    'X-Goog-Upload-Command': 'start',\n    'X-Goog-Upload-Header-Content-Length': blob.size(),\n    'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n    'Content-Type': 'application/json; charset=utf-8'\n  };\n  let body = MetadataUtils.toResourceString(metadata, mappings);\n  let timeout = authWrapper.maxUploadRetryTime();\n\n  function handler(xhr: XhrIo, text: string): string {\n    checkResumeHeader_(xhr);\n    let url;\n    try {\n      url = xhr.getResponseHeader('X-Goog-Upload-URL');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    handlerCheck(type.isString(url));\n    return (url as string);\n  }\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.urlParams = urlParams;\n  requestInfo.headers = headers;\n  requestInfo.body = body;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(\n    authWrapper: AuthWrapper, location: Location, url: string,\n    blob: FbsBlob): RequestInfo<ResumableUploadStatus> {\n  let headers = {'X-Goog-Upload-Command': 'query'};\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    let status = checkResumeHeader_(xhr, ['active', 'final']);\n    let sizeString;\n    try {\n      sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n    } catch (e) {\n      handlerCheck(false);\n    }\n    let size = parseInt(sizeString, 10);\n    handlerCheck(!isNaN(size));\n    return new ResumableUploadStatus(size, blob.size(), status === 'final');\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport const resumableUploadChunkSize: number = 256 * 1024;\n\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(\n    location: Location, authWrapper: AuthWrapper, url: string, blob: FbsBlob,\n    chunkSize: number, mappings: MetadataUtils.Mappings,\n    opt_status?: ResumableUploadStatus|null,\n    opt_progressCallback?: ((p1: number, p2: number) => void) | null): RequestInfo<ResumableUploadStatus> {\n  // TODO(andysoto): standardize on internal asserts\n  // assert(!(opt_status && opt_status.finalized));\n  let status = new ResumableUploadStatus(0, 0);\n  if (opt_status) {\n    status.current = opt_status.current;\n    status.total = opt_status.total;\n  } else {\n    status.current = 0;\n    status.total = blob.size();\n  }\n  if (blob.size() !== status.total) {\n    throw errorsExports.serverFileWrongSize();\n  }\n  let bytesLeft = status.total - status.current;\n  let bytesToUpload = bytesLeft;\n  if (chunkSize > 0) {\n    bytesToUpload = Math.min(bytesToUpload, chunkSize);\n  }\n  let startByte = status.current;\n  let endByte = startByte + bytesToUpload;\n  let uploadCommand =\n      bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n  let headers = {\n    'X-Goog-Upload-Command': uploadCommand,\n    'X-Goog-Upload-Offset': status.current\n  };\n  let body = blob.slice(startByte, endByte);\n  if (body === null) {\n    throw errorsExports.cannotSliceBlob();\n  }\n\n  function handler(xhr: XhrIo, text: string): ResumableUploadStatus {\n    // TODO(andysoto): Verify the MD5 of each uploaded range:\n    // the 'x-range-md5' header comes back with status code 308 responses.\n    // We'll only be able to bail out though, because you can't re-upload a\n    // range that you previously uploaded.\n    let uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n    let newCurrent = status.current + bytesToUpload;\n    let size = blob.size();\n    let metadata;\n    if (uploadStatus === 'final') {\n      metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n    } else {\n      metadata = null;\n    }\n    return new ResumableUploadStatus(\n        newCurrent, size, uploadStatus === 'final', metadata);\n  }\n  let method = 'POST';\n  let timeout = authWrapper.maxUploadRetryTime();\n  let requestInfo = new RequestInfo(url, method, handler, timeout);\n  requestInfo.headers = headers;\n  requestInfo.body = body.uploadData();\n  requestInfo.progressCallback = opt_progressCallback || null;\n  requestInfo.errorHandler = sharedErrorHandler(location);\n  return requestInfo;\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as array from './array';\nimport { FbsBlob } from './blob';\nimport * as errorsExports from './error';\nimport * as MetadataUtils from './metadata';\nimport * as object from './object';\nimport { RequestInfo } from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n/**\n * Throws the UNKNOWN FirebaseStorageError if cndn is false.\n */\nexport function handlerCheck(cndn) {\n    if (!cndn) {\n        throw errorsExports.unknown();\n    }\n}\nexport function metadataHandler(authWrapper, mappings) {\n    function handler(xhr, text) {\n        var metadata = MetadataUtils.fromResourceString(authWrapper, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nexport function sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        var newErr;\n        if (xhr.getStatus() === 401) {\n            newErr = errorsExports.unauthenticated();\n        }\n        else {\n            if (xhr.getStatus() === 402) {\n                newErr = errorsExports.quotaExceeded(location.bucket);\n            }\n            else {\n                if (xhr.getStatus() === 403) {\n                    newErr = errorsExports.unauthorized(location.path);\n                }\n                else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.setServerResponseProp(err.serverResponseProp());\n        return newErr;\n    }\n    return errorHandler;\n}\nexport function objectErrorHandler(location) {\n    var shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        var newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = errorsExports.objectNotFound(location.path);\n        }\n        newErr.setServerResponseProp(err.serverResponseProp());\n        return newErr;\n    }\n    return errorHandler;\n}\nexport function getMetadata(authWrapper, location, mappings) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'GET';\n    var timeout = authWrapper.maxOperationRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function updateMetadata(authWrapper, location, metadata, mappings) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'PATCH';\n    var body = MetadataUtils.toResourceString(metadata, mappings);\n    var headers = { 'Content-Type': 'application/json; charset=utf-8' };\n    var timeout = authWrapper.maxOperationRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function deleteObject(authWrapper, location) {\n    var urlPart = location.fullServerUrl();\n    var url = UrlUtils.makeNormalUrl(urlPart);\n    var method = 'DELETE';\n    var timeout = authWrapper.maxOperationRetryTime();\n    function handler(xhr, text) { }\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [200, 204];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nexport function determineContentType_(metadata, blob) {\n    return metadata && metadata['contentType'] || blob && blob.type() ||\n        'application/octet-stream';\n}\nexport function metadataForUpload_(location, blob, opt_metadata) {\n    var metadata = object.clone(opt_metadata);\n    metadata['fullPath'] = location.path;\n    metadata['size'] = blob.size();\n    if (!metadata['contentType']) {\n        metadata['contentType'] = determineContentType_(null, blob);\n    }\n    return metadata;\n}\nexport function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {\n    var urlPart = location.bucketOnlyServerUrl();\n    var headers = { 'X-Goog-Upload-Protocol': 'multipart' };\n    function genBoundary() {\n        var str = '';\n        for (var i = 0; i < 2; i++) {\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    var boundary = genBoundary();\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n    var metadata = metadataForUpload_(location, blob, opt_metadata);\n    var metadataString = MetadataUtils.toResourceString(metadata, mappings);\n    var preBlobPart = '--' + boundary + '\\r\\n' +\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' + metadataString +\n        '\\r\\n--' + boundary + '\\r\\n' +\n        'Content-Type: ' + metadata['contentType'] + '\\r\\n\\r\\n';\n    var postBlobPart = '\\r\\n--' + boundary + '--';\n    var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw errorsExports.cannotSliceBlob();\n    }\n    var urlParams = { 'name': metadata['fullPath'] };\n    var url = UrlUtils.makeUploadUrl(urlPart);\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, metadataHandler(authWrapper, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n * @struct\n */\nvar ResumableUploadStatus = (function () {\n    function ResumableUploadStatus(current, total, finalized, metadata) {\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n    return ResumableUploadStatus;\n}());\nexport { ResumableUploadStatus };\nexport function checkResumeHeader_(xhr, opt_allowed) {\n    var status;\n    try {\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\n    }\n    catch (e) {\n        handlerCheck(false);\n    }\n    var allowed = opt_allowed || ['active'];\n    handlerCheck(array.contains(allowed, status));\n    return status;\n}\nexport function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {\n    var urlPart = location.bucketOnlyServerUrl();\n    var metadata = metadataForUpload_(location, blob, opt_metadata);\n    var urlParams = { 'name': metadata['fullPath'] };\n    var url = UrlUtils.makeUploadUrl(urlPart);\n    var method = 'POST';\n    var headers = {\n        'X-Goog-Upload-Protocol': 'resumable',\n        'X-Goog-Upload-Command': 'start',\n        'X-Goog-Upload-Header-Content-Length': blob.size(),\n        'X-Goog-Upload-Header-Content-Type': metadata['contentType'],\n        'Content-Type': 'application/json; charset=utf-8'\n    };\n    var body = MetadataUtils.toResourceString(metadata, mappings);\n    var timeout = authWrapper.maxUploadRetryTime();\n    function handler(xhr, text) {\n        checkResumeHeader_(xhr);\n        var url;\n        try {\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(type.isString(url));\n        return url;\n    }\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nexport function getResumableUploadStatus(authWrapper, location, url, blob) {\n    var headers = { 'X-Goog-Upload-Command': 'query' };\n    function handler(xhr, text) {\n        var status = checkResumeHeader_(xhr, ['active', 'final']);\n        var sizeString;\n        try {\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        var size = parseInt(sizeString, 10);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\n    }\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nexport var resumableUploadChunkSize = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param opt_status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nexport function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    var status = new ResumableUploadStatus(0, 0);\n    if (opt_status) {\n        status.current = opt_status.current;\n        status.total = opt_status.total;\n    }\n    else {\n        status.current = 0;\n        status.total = blob.size();\n    }\n    if (blob.size() !== status.total) {\n        throw errorsExports.serverFileWrongSize();\n    }\n    var bytesLeft = status.total - status.current;\n    var bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    var startByte = status.current;\n    var endByte = startByte + bytesToUpload;\n    var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';\n    var headers = {\n        'X-Goog-Upload-Command': uploadCommand,\n        'X-Goog-Upload-Offset': status.current\n    };\n    var body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw errorsExports.cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n        var newCurrent = status.current + bytesToUpload;\n        var size = blob.size();\n        var metadata;\n        if (uploadStatus === 'final') {\n            metadata = metadataHandler(authWrapper, mappings)(xhr, text);\n        }\n        else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n    }\n    var method = 'POST';\n    var timeout = authWrapper.maxUploadRetryTime();\n    var requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = opt_progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n\n\n"]}