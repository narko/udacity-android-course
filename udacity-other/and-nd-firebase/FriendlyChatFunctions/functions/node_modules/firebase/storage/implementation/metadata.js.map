{"version":3,"sources":["src/storage/implementation/metadata.ts","storage/implementation/metadata.js"],"names":["noXform_","xformPath","getMappings","addRef","fromResource","fromResourceString","toResourceString","metadataValidator","json","path","type","UrlUtils","metadata","value","Mapping","server","opt_local","opt_writable","opt_xform","local","writable","xform","mappings_","fullPath","valid","isString","length","lastComponent","mappings","push","mappingsXformPath","nameMapping","xformSize","size","isDef","sizeMapping","xformTokens","tokens","encode","encodeURIComponent","tokensList","split","urls","map","token","bucket","urlPart","base","makeDownloadUrl","queryString","makeQueryString","authWrapper","generateRef","loc","makeStorageReference","Object","defineProperty","get","resource","len","i","mapping","resourceString","obj","jsonObjectOrNull","JSON","stringify","p","validType","isObject","key","val","isNonNullObject"],"mappings":"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","file":"metadata.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Documentation for the metadata format\n */\nimport {Metadata} from '../metadata';\n\nimport {AuthWrapper} from './authwrapper';\nimport * as json from './json';\nimport {Location} from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\n\nexport function noXform_(\n    metadata: Metadata, value: any): any {\n  return value;\n}\n\n/**\n * @struct\n */\nexport class Mapping {\n  local: string;\n  writable: boolean;\n  xform: (p1: Metadata, p2: any) => any;\n\n  constructor(\n      public server: string, opt_local?: string|null, opt_writable?: boolean,\n      opt_xform?: (p1: Metadata, p2: any) => any |\n          null) {\n    this.local = opt_local || server;\n    this.writable = !!opt_writable;\n    this.xform = opt_xform || noXform_;\n  }\n}\ntype Mappings = Mapping[];\n\nexport {Mappings};\n\nlet mappings_: Mappings|null = null;\n\nexport function xformPath(fullPath: any): string {\n  let valid = type.isString(fullPath);\n  if (!valid || fullPath.length < 2) {\n    return fullPath;\n  } else {\n    fullPath = (fullPath as string);\n    return path.lastComponent(fullPath);\n  }\n}\n\nexport function getMappings(): Mappings {\n  if (mappings_) {\n    return mappings_;\n  }\n  let mappings = [];\n  mappings.push(new Mapping('bucket'));\n  mappings.push(new Mapping('generation'));\n  mappings.push(new Mapping('metageneration'));\n  mappings.push(new Mapping('name', 'fullPath', true));\n\n  function mappingsXformPath(\n      metadata: Metadata, fullPath: any): string {\n    return xformPath(fullPath);\n  }\n  let nameMapping = new Mapping('name');\n  nameMapping.xform = mappingsXformPath;\n  mappings.push(nameMapping);\n\n  /**\n   * Coerces the second param to a number, if it is defined.\n   */\n  function xformSize(\n      metadata: Metadata, size: any): number|null|undefined {\n    if (type.isDef(size)) {\n      return +(size as number);\n    } else {\n      return size;\n    }\n  }\n  let sizeMapping = new Mapping('size');\n  sizeMapping.xform = xformSize;\n  mappings.push(sizeMapping);\n  mappings.push(new Mapping('timeCreated'));\n  mappings.push(new Mapping('updated'));\n  mappings.push(new Mapping('md5Hash', null, true));\n  mappings.push(new Mapping('cacheControl', null, true));\n  mappings.push(new Mapping('contentDisposition', null, true));\n  mappings.push(new Mapping('contentEncoding', null, true));\n  mappings.push(new Mapping('contentLanguage', null, true));\n  mappings.push(new Mapping('contentType', null, true));\n  mappings.push(new Mapping('metadata', 'customMetadata', true));\n\n  /**\n   * Transforms a comma-separated string of tokens into a list of download\n   * URLs.\n   */\n  function xformTokens(\n      metadata: Metadata, tokens: any): string[] {\n    let valid = type.isString(tokens) && tokens.length > 0;\n    if (!valid) {\n      // This can happen if objects are uploaded through GCS and retrieved\n      // through list, so we don't want to throw an Error.\n      return [];\n    }\n    let encode = encodeURIComponent;\n    let tokensList = tokens.split(',');\n    let urls = tokensList.map(function(token: string) {\n      let bucket: string = metadata['bucket'] as string;\n      let path: string = metadata['fullPath'] as string;\n      let urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n      let base = UrlUtils.makeDownloadUrl(urlPart);\n      let queryString = UrlUtils.makeQueryString({'alt': 'media', 'token': token});\n      return base + queryString;\n    });\n    return urls;\n  }\n  mappings.push(\n      new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n  mappings_ = mappings;\n  return mappings_;\n}\n\nexport function addRef(metadata: Metadata, authWrapper: AuthWrapper) {\n  function generateRef() {\n    let bucket: string = metadata['bucket'] as string;\n    let path: string = metadata['fullPath'] as string;\n    let loc = new Location(bucket, path);\n    return authWrapper.makeStorageReference(loc);\n  }\n  Object.defineProperty(metadata, 'ref', {get: generateRef});\n}\n\nexport function fromResource(\n    authWrapper: AuthWrapper, resource: {[name: string]: any},\n    mappings: Mappings): Metadata {\n  let metadata: Metadata = {} as Metadata;\n  metadata['type']  = 'file';\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n  }\n  addRef(metadata, authWrapper);\n  return metadata;\n}\n\nexport function fromResourceString(\n    authWrapper: AuthWrapper, resourceString: string,\n    mappings: Mappings): Metadata|null {\n  let obj = json.jsonObjectOrNull(resourceString);\n  if (obj === null) {\n    return null;\n  }\n  let resource = (obj as Metadata);\n  return fromResource(authWrapper, resource, mappings);\n}\n\nexport function toResourceString(\n    metadata: Metadata, mappings: Mappings): string {\n  let resource: {\n    [prop: string]: any\n  } = {};\n  let len = mappings.length;\n  for (let i = 0; i < len; i++) {\n    let mapping = mappings[i];\n    if (mapping.writable) {\n      resource[mapping.server] = metadata[mapping.local];\n    }\n  }\n  return JSON.stringify(resource);\n}\n\nexport function metadataValidator(p: any) {\n  let validType = p && type.isObject(p);\n  if (!validType) {\n    throw 'Expected Metadata object.';\n  }\n  for (let key in p) {\n    let val = p[key];\n    if (key === 'customMetadata') {\n      if (!type.isObject(val)) {\n        throw 'Expected object for \\'customMetadata\\' mapping.';\n      }\n    } else {\n      if (type.isNonNullObject(val)) {\n        throw 'Mapping for \\'' + key + '\\' cannot be an object.';\n      }\n    }\n  }\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport * as json from './json';\nimport { Location } from './location';\nimport * as path from './path';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nexport function noXform_(metadata, value) {\n    return value;\n}\n/**\n * @struct\n */\nvar Mapping = (function () {\n    function Mapping(server, opt_local, opt_writable, opt_xform) {\n        this.server = server;\n        this.local = opt_local || server;\n        this.writable = !!opt_writable;\n        this.xform = opt_xform || noXform_;\n    }\n    return Mapping;\n}());\nexport { Mapping };\nvar mappings_ = null;\nexport function xformPath(fullPath) {\n    var valid = type.isString(fullPath);\n    if (!valid || fullPath.length < 2) {\n        return fullPath;\n    }\n    else {\n        fullPath = fullPath;\n        return path.lastComponent(fullPath);\n    }\n}\nexport function getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    var mappings = [];\n    mappings.push(new Mapping('bucket'));\n    mappings.push(new Mapping('generation'));\n    mappings.push(new Mapping('metageneration'));\n    mappings.push(new Mapping('name', 'fullPath', true));\n    function mappingsXformPath(metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    var nameMapping = new Mapping('name');\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\n     * Coerces the second param to a number, if it is defined.\n     */\n    function xformSize(metadata, size) {\n        if (type.isDef(size)) {\n            return +size;\n        }\n        else {\n            return size;\n        }\n    }\n    var sizeMapping = new Mapping('size');\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping('timeCreated'));\n    mappings.push(new Mapping('updated'));\n    mappings.push(new Mapping('md5Hash', null, true));\n    mappings.push(new Mapping('cacheControl', null, true));\n    mappings.push(new Mapping('contentDisposition', null, true));\n    mappings.push(new Mapping('contentEncoding', null, true));\n    mappings.push(new Mapping('contentLanguage', null, true));\n    mappings.push(new Mapping('contentType', null, true));\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\n    /**\n     * Transforms a comma-separated string of tokens into a list of download\n     * URLs.\n     */\n    function xformTokens(metadata, tokens) {\n        var valid = type.isString(tokens) && tokens.length > 0;\n        if (!valid) {\n            // This can happen if objects are uploaded through GCS and retrieved\n            // through list, so we don't want to throw an Error.\n            return [];\n        }\n        var encode = encodeURIComponent;\n        var tokensList = tokens.split(',');\n        var urls = tokensList.map(function (token) {\n            var bucket = metadata['bucket'];\n            var path = metadata['fullPath'];\n            var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n            var base = UrlUtils.makeDownloadUrl(urlPart);\n            var queryString = UrlUtils.makeQueryString({ 'alt': 'media', 'token': token });\n            return base + queryString;\n        });\n        return urls;\n    }\n    mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));\n    mappings_ = mappings;\n    return mappings_;\n}\nexport function addRef(metadata, authWrapper) {\n    function generateRef() {\n        var bucket = metadata['bucket'];\n        var path = metadata['fullPath'];\n        var loc = new Location(bucket, path);\n        return authWrapper.makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\nexport function fromResource(authWrapper, resource, mappings) {\n    var metadata = {};\n    metadata['type'] = 'file';\n    var len = mappings.length;\n    for (var i = 0; i < len; i++) {\n        var mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, authWrapper);\n    return metadata;\n}\nexport function fromResourceString(authWrapper, resourceString, mappings) {\n    var obj = json.jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    var resource = obj;\n    return fromResource(authWrapper, resource, mappings);\n}\nexport function toResourceString(metadata, mappings) {\n    var resource = {};\n    var len = mappings.length;\n    for (var i = 0; i < len; i++) {\n        var mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\nexport function metadataValidator(p) {\n    var validType = p && type.isObject(p);\n    if (!validType) {\n        throw 'Expected Metadata object.';\n    }\n    for (var key in p) {\n        var val = p[key];\n        if (key === 'customMetadata') {\n            if (!type.isObject(val)) {\n                throw 'Expected object for \\'customMetadata\\' mapping.';\n            }\n        }\n        else {\n            if (type.isNonNullObject(val)) {\n                throw 'Mapping for \\'' + key + '\\' cannot be an object.';\n            }\n        }\n    }\n}\n\n\n"]}