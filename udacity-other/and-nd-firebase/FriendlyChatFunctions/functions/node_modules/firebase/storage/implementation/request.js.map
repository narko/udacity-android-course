{"version":3,"sources":["src/storage/implementation/request.ts","storage/implementation/request.js"],"names":["addAuthHeader_","addVersionHeader_","makeRequest","array","backoff","errorsExports","object","promiseimpl","type","UrlUtils","XhrIoExports","NetworkRequest","url","method","headers","body","successCodes","additionalRetryCodes","callback","errorCallback","timeout","progressCallback","pool","pendingXhr_","backoffId_","resolve_","reject_","canceled_","appDelete_","url_","method_","headers_","body_","successCodes_","slice","additionalRetryCodes_","callback_","errorCallback_","progressCallback_","timeout_","pool_","self","promise_","make","resolve","reject","start_","prototype","doTheRequest","backoffCallback","canceled","RequestEndStatus","xhr","createXhrIo","progressListener","progressEvent","loaded","total","lengthComputable","addUploadProgressListener","send","then","removeUploadProgressListener","hitServer","getErrorCode","ErrorCode","NO_ERROR","status","getStatus","isRetryStatusCode_","wasCanceled","ABORT","successCode","contains","backoffDone","requestWentThrough","wasSuccessCode","result","getResponseText","isJustDef","e","err","unknown","setServerResponseProp","appDeleted","retryLimitExceeded","start","getPromise","cancel","appDelete","stop","abort","isFiveHundredCode","extraRetryCodes","isExtraRetryCode","isRequestSpecificRetryCode","opt_canceled","authToken","length","number","firebase","SDK_VERSION","requestInfo","queryPart","makeQueryString","urlParams","clone","handler","errorHandler"],"mappings":"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","file":"request.js","sourcesContent":["/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport {FirebaseStorageError} from './error';\nimport {errors} from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport {RequestInfo} from './requestinfo';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\nimport {Headers, XhrIo} from './xhrio';\nimport {XhrIoPool} from './xhriopool';\nimport { FirebaseNamespace } from \"../../app/firebase_app\";\n\ndeclare var firebase: FirebaseNamespace;\n\n/**\n * @template T\n */\nexport interface Request<T> {\n  getPromise(): Promise<T>;\n\n  /**\n   * Cancels the request. IMPORTANT: the promise may still be resolved with an\n   * appropriate value (if the request is finished before you call this method,\n   * but the promise has not yet been resolved), so don't just assume it will be\n   * rejected if you call this function.\n   * @param appDelete True if the cancelation came from the app being deleted.\n   */\n  cancel(appDelete?: boolean): void;\n}\n\n/**\n * @struct\n * @template T\n */\nclass NetworkRequest<T> implements Request<T> {\n  private url_: string;\n  private method_: string;\n  private headers_: Headers;\n  private body_: string|Blob|Uint8Array|null;\n  private successCodes_: number[];\n  private additionalRetryCodes_: number[];\n  private pendingXhr_: XhrIo|null = null;\n  private backoffId_: backoff.id|null = null;\n  private resolve_: Function|null = null;\n  private reject_: Function|null = null;\n  private canceled_: boolean = false;\n  private appDelete_: boolean = false;\n  private callback_: (p1: XhrIo, p2: string) => T;\n  private errorCallback_: ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError) | null;\n  private progressCallback_:\n      ((p1: number, p2: number) => void) | null;\n  private timeout_: number;\n  private pool_: XhrIoPool;\n  promise_: Promise<T>;\n\n  constructor(\n      url: string, method: string, headers: Headers,\n      body: string|Blob|Uint8Array|null, successCodes: number[],\n      additionalRetryCodes: number[],\n      callback: (p1: XhrIo, p2: string) => T,\n      errorCallback: ((p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError) | null, timeout: number,\n      progressCallback: ((p1: number, p2: number) => void) | null,\n      pool: XhrIoPool) {\n    this.url_ = url;\n    this.method_ = method;\n    this.headers_ = headers;\n    this.body_ = body;\n    this.successCodes_ = successCodes.slice();\n    this.additionalRetryCodes_ = additionalRetryCodes.slice();\n    this.callback_ = callback;\n    this.errorCallback_ = errorCallback;\n    this.progressCallback_ = progressCallback;\n    this.timeout_ = timeout;\n    this.pool_ = pool;\n    let self = this;\n    this.promise_ = promiseimpl.make(function(resolve, reject) {\n      self.resolve_ = resolve;\n      self.reject_ = reject;\n      self.start_();\n    });\n  }\n\n  /**\n   * Actually starts the retry loop.\n   */\n  private start_() {\n    let self = this;\n\n    function doTheRequest(\n        backoffCallback: (p1: boolean, ...p2: any[]) => void,\n        canceled: boolean) {\n      if (canceled) {\n        backoffCallback(false, new RequestEndStatus(false, null, true));\n        return;\n      }\n      let xhr = self.pool_.createXhrIo();\n      self.pendingXhr_ = xhr;\n\n      function progressListener(progressEvent: ProgressEvent) {\n        let loaded = progressEvent.loaded;\n        let total = progressEvent.lengthComputable ? progressEvent.total : -1;\n        if (self.progressCallback_ !== null) {\n          self.progressCallback_(loaded, total);\n        }\n      }\n      if (self.progressCallback_ !== null) {\n        xhr.addUploadProgressListener(progressListener);\n      }\n      xhr.send(self.url_, self.method_, self.body_, self.headers_)\n          .then(function(xhr: XhrIo) {\n            if (self.progressCallback_ !== null) {\n              xhr.removeUploadProgressListener(progressListener);\n            }\n            self.pendingXhr_ = null;\n            xhr = (xhr as XhrIo);\n            let hitServer =\n                xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n            let status = xhr.getStatus();\n            if (!hitServer || self.isRetryStatusCode_(status)) {\n              let wasCanceled =\n                  xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n              backoffCallback(\n                  false, new RequestEndStatus(false, null, wasCanceled));\n              return;\n            }\n            let successCode = array.contains(self.successCodes_, status);\n            backoffCallback(true, new RequestEndStatus(successCode, xhr));\n          });\n    }\n\n    /**\n     * @param requestWentThrough True if the request eventually went\n     *     through, false if it hit the retry limit or was canceled.\n     */\n    function backoffDone(\n        requestWentThrough: boolean, status: RequestEndStatus) {\n      let resolve = self.resolve_ as Function;\n      let reject = self.reject_ as Function;\n      let xhr = status.xhr as XhrIo;\n      if (status.wasSuccessCode) {\n        try {\n          let result = self.callback_(xhr, xhr.getResponseText());\n          if (type.isJustDef(result)) {\n            resolve(result);\n          } else {\n            resolve();\n          }\n        } catch (e) {\n          reject(e);\n        }\n      } else {\n        if (xhr !== null) {\n          let err = errorsExports.unknown();\n          err.setServerResponseProp(xhr.getResponseText());\n          if (self.errorCallback_) {\n            reject(self.errorCallback_(xhr, err));\n          } else {\n            reject(err);\n          }\n        } else {\n          if (status.canceled) {\n            let err = self.appDelete_ ? errorsExports.appDeleted() :\n                                        errorsExports.canceled();\n            reject(err);\n          } else {\n            let err = errorsExports.retryLimitExceeded();\n            reject(err);\n          }\n        }\n      }\n    }\n    if (this.canceled_) {\n      backoffDone(false, new RequestEndStatus(false, null, true));\n    } else {\n      this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n    }\n  }\n\n  /** @inheritDoc */\n  getPromise() {\n    return this.promise_;\n  }\n\n  /** @inheritDoc */\n  cancel(appDelete?: boolean) {\n    this.canceled_ = true;\n    this.appDelete_ = appDelete || false;\n    if (this.backoffId_ !== null) {\n      backoff.stop(this.backoffId_);\n    }\n    if (this.pendingXhr_ !== null) {\n      this.pendingXhr_.abort();\n    }\n  }\n\n  private isRetryStatusCode_(status: number): boolean {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    let isFiveHundredCode = status >= 500 && status < 600;\n    let extraRetryCodes = [\n      // Request Timeout: web server didn't receive full request in time.\n      408,\n      // Too Many Requests: you're getting rate-limited, basically.\n      429\n    ];\n    let isExtraRetryCode = array.contains(extraRetryCodes, status);\n    let isRequestSpecificRetryCode =\n        array.contains(this.additionalRetryCodes_, status);\n    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n  }\n}\n\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nexport class RequestEndStatus {\n  /**\n   * True if the request was canceled.\n   */\n  canceled: boolean;\n\n  constructor(\n      public wasSuccessCode: boolean, public xhr: XhrIo|null,\n      opt_canceled?: boolean) {\n    this.canceled = !!opt_canceled;\n  }\n}\n\nexport function addAuthHeader_(headers: Headers, authToken: string|null) {\n  if (authToken !== null && authToken.length > 0) {\n    headers['Authorization'] = 'Firebase ' + authToken;\n  }\n}\n\nexport function addVersionHeader_(headers: Headers) {\n  let number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n  headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n\n/**\n * @template T\n */\nexport function makeRequest<T>(\n    requestInfo: RequestInfo<T>, authToken: string|null,\n    pool: XhrIoPool): Request<T> {\n  let queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n  let url = requestInfo.url + queryPart;\n  let headers = object.clone<Headers>(requestInfo.headers);\n  addAuthHeader_(headers, authToken);\n  addVersionHeader_(headers);\n  return new NetworkRequest<T>(\n      url, requestInfo.method, headers, requestInfo.body,\n      requestInfo.successCodes, requestInfo.additionalRetryCodes,\n      requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout,\n      requestInfo.progressCallback, pool);\n}\n","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Defines methods used to actually send HTTP requests from\n * abstract representations.\n */\nimport * as array from './array';\nimport * as backoff from './backoff';\nimport * as errorsExports from './error';\nimport * as object from './object';\nimport * as promiseimpl from './promise_external';\nimport * as type from './type';\nimport * as UrlUtils from './url';\nimport * as XhrIoExports from './xhrio';\n/**\n * @struct\n * @template T\n */\nvar NetworkRequest = (function () {\n    function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {\n        this.pendingXhr_ = null;\n        this.backoffId_ = null;\n        this.resolve_ = null;\n        this.reject_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.url_ = url;\n        this.method_ = method;\n        this.headers_ = headers;\n        this.body_ = body;\n        this.successCodes_ = successCodes.slice();\n        this.additionalRetryCodes_ = additionalRetryCodes.slice();\n        this.callback_ = callback;\n        this.errorCallback_ = errorCallback;\n        this.progressCallback_ = progressCallback;\n        this.timeout_ = timeout;\n        this.pool_ = pool;\n        var self = this;\n        this.promise_ = promiseimpl.make(function (resolve, reject) {\n            self.resolve_ = resolve;\n            self.reject_ = reject;\n            self.start_();\n        });\n    }\n    /**\n     * Actually starts the retry loop.\n     */\n    NetworkRequest.prototype.start_ = function () {\n        var self = this;\n        function doTheRequest(backoffCallback, canceled) {\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            var xhr = self.pool_.createXhrIo();\n            self.pendingXhr_ = xhr;\n            function progressListener(progressEvent) {\n                var loaded = progressEvent.loaded;\n                var total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (self.progressCallback_ !== null) {\n                    self.progressCallback_(loaded, total);\n                }\n            }\n            if (self.progressCallback_ !== null) {\n                xhr.addUploadProgressListener(progressListener);\n            }\n            xhr.send(self.url_, self.method_, self.body_, self.headers_)\n                .then(function (xhr) {\n                if (self.progressCallback_ !== null) {\n                    xhr.removeUploadProgressListener(progressListener);\n                }\n                self.pendingXhr_ = null;\n                xhr = xhr;\n                var hitServer = xhr.getErrorCode() === XhrIoExports.ErrorCode.NO_ERROR;\n                var status = xhr.getStatus();\n                if (!hitServer || self.isRetryStatusCode_(status)) {\n                    var wasCanceled = xhr.getErrorCode() === XhrIoExports.ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                var successCode = array.contains(self.successCodes_, status);\n                backoffCallback(true, new RequestEndStatus(successCode, xhr));\n            });\n        }\n        /**\n         * @param requestWentThrough True if the request eventually went\n         *     through, false if it hit the retry limit or was canceled.\n         */\n        function backoffDone(requestWentThrough, status) {\n            var resolve = self.resolve_;\n            var reject = self.reject_;\n            var xhr = status.xhr;\n            if (status.wasSuccessCode) {\n                try {\n                    var result = self.callback_(xhr, xhr.getResponseText());\n                    if (type.isJustDef(result)) {\n                        resolve(result);\n                    }\n                    else {\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            else {\n                if (xhr !== null) {\n                    var err = errorsExports.unknown();\n                    err.setServerResponseProp(xhr.getResponseText());\n                    if (self.errorCallback_) {\n                        reject(self.errorCallback_(xhr, err));\n                    }\n                    else {\n                        reject(err);\n                    }\n                }\n                else {\n                    if (status.canceled) {\n                        var err = self.appDelete_ ? errorsExports.appDeleted() :\n                            errorsExports.canceled();\n                        reject(err);\n                    }\n                    else {\n                        var err = errorsExports.retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        }\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        }\n        else {\n            this.backoffId_ = backoff.start(doTheRequest, backoffDone, this.timeout_);\n        }\n    };\n    /** @inheritDoc */\n    NetworkRequest.prototype.getPromise = function () {\n        return this.promise_;\n    };\n    /** @inheritDoc */\n    NetworkRequest.prototype.cancel = function (appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            backoff.stop(this.backoffId_);\n        }\n        if (this.pendingXhr_ !== null) {\n            this.pendingXhr_.abort();\n        }\n    };\n    NetworkRequest.prototype.isRetryStatusCode_ = function (status) {\n        // The codes for which to retry came from this page:\n        // https://cloud.google.com/storage/docs/exponential-backoff\n        var isFiveHundredCode = status >= 500 && status < 600;\n        var extraRetryCodes = [\n            // Request Timeout: web server didn't receive full request in time.\n            408,\n            // Too Many Requests: you're getting rate-limited, basically.\n            429\n        ];\n        var isExtraRetryCode = array.contains(extraRetryCodes, status);\n        var isRequestSpecificRetryCode = array.contains(this.additionalRetryCodes_, status);\n        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;\n    };\n    return NetworkRequest;\n}());\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled Defaults to false.\n * @struct\n */\nvar RequestEndStatus = (function () {\n    function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {\n        this.wasSuccessCode = wasSuccessCode;\n        this.xhr = xhr;\n        this.canceled = !!opt_canceled;\n    }\n    return RequestEndStatus;\n}());\nexport { RequestEndStatus };\nexport function addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers['Authorization'] = 'Firebase ' + authToken;\n    }\n}\nexport function addVersionHeader_(headers) {\n    var number = typeof firebase !== 'undefined' ? firebase.SDK_VERSION : 'AppManager';\n    headers['X-Firebase-Storage-Version'] = 'webjs/' + number;\n}\n/**\n * @template T\n */\nexport function makeRequest(requestInfo, authToken, pool) {\n    var queryPart = UrlUtils.makeQueryString(requestInfo.urlParams);\n    var url = requestInfo.url + queryPart;\n    var headers = object.clone(requestInfo.headers);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);\n}\n\n\n"]}