{"version":3,"sources":["webpack:///firebase-app.js","webpack:///webpack/bootstrap 8ab15b975f62acbe3906","webpack:///./src/utils/promise.ts","webpack:///./src/app/firebase_app.ts","webpack:///./src/app.ts","webpack:///./src/app/errors.ts","webpack:///./src/app/subscribe.ts","webpack:///./src/utils/globalScope.ts","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/process/browser.js","webpack:///./src/utils/deep_copy.ts","webpack:///./node_modules/promise-polyfill/promise.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js"],"names":["firebase","window","self","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","parentJsonpFunction","chunkIds","moreModules","executeModules","chunkId","result","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","shift","s","3","e","onScriptComplete","script","onerror","onload","clearTimeout","timeout","chunk","Error","undefined","installedChunkData","Promise","resolve","promise","reject","head","document","getElementsByTagName","createElement","type","charset","async","nc","setAttribute","src","p","setTimeout","appendChild","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","n","__esModule","object","property","oe","err","console","error","__webpack_exports__","PromiseImpl","Deferred","attachDummyErrorHandler","__WEBPACK_IMPORTED_MODULE_0__utils_globalScope__","this","wrapCallback","opt_nodeCallback","meta","opt_value","catch","createFirebaseNamespace","removeApp","callAppHooks","apps_","app","DEFAULT_ENTRY_NAME","contains","initializeApp","options","FirebaseAppImpl","namespace","getApps","keys","map","registerService","createService","serviceProperties","appHook","allowMultipleInstances","factories","appHooks","forEach","serviceNamespace","appArg","__WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__","args","_i","arguments","_getService","bind","apply","extendNamespace","props","eventName","serviceName","factoryName","useAsService","useService","apps","__WEBPACK_IMPORTED_MODULE_2__utils_promise__","SDK_VERSION","INTERNAL","createSubscribe","__WEBPACK_IMPORTED_MODULE_0__subscribe__","ErrorFactory","__WEBPACK_IMPORTED_MODULE_1__errors__","deepExtend","code","appErrors","create","value","obj","key","tokenListeners","firebase_","isDeleted_","services_","name_","options_","getUid","getToken","addAuthTokenListener","callback","removeAuthTokenListener","filter","listener","checkDestroyed_","delete","_this","then","services","serviceKey","instanceKey","all","service","instanceIdentifier","instanceSpecifier","extendApp","log","errors","no-app","bad-app-name","duplicate-app","app-deleted","duplicate-service","sa-not-supported","invalid-app-argument","ERROR_NAME","captureStackTrace","FirebaseError","message","err_1","stack","constructor","pattern","data","template","fullCode","replace","match","prop","slice","executor","onNoObservers","proxy","ObserverProxy","subscribe","implementsAnyMethods","methods","_typeof","methods_1","method","noop","__WEBPACK_IMPORTED_MODULE_0__utils_promise__","Symbol","iterator","observers","unsubscribes","observerCount","task","finalized","next","forEachObserver","observer","close","complete","nextOrObserver","unsub","unsubscribeOne","finalError","fn","sendOne","global","globalScope","scope","Function","g","eval","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","len","run","Item","array","process","nextTick","Array","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","deepCopy","target","source","Date","dateValue","getTime","patchProperty","setImmediate","root","thisArg","TypeError","_state","_handled","_value","_deferreds","doResolve","handle","deferred","_immediateFn","cb","onFulfilled","onRejected","ret","newValue","finale","_unhandledRejectionFn","Handler","done","reason","ex","setTimeoutFunc","prom","arr","res","val","remaining","race","values","warn","_setImmediateFn","_setUnhandledRejectionFn","Timeout","id","clearFn","_id","_clearFn","setInterval","clearInterval","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","clearImmediate","tasksByHandle","nextHandle","registerImmediate","runIfPresent","currentlyRunningATask","doc","attachTo","getPrototypeOf","toString","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","messagePrefix","Math","random","onGlobalMessage","event","indexOf","addEventListener","attachEvent","MessageChannel","channel","port1","port2","html","documentElement","onreadystatechange","removeChild","default"],"mappings":"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","file":"firebase-app.js","sourcesContent":["var firebase = (function() {\n            var window = typeof window === 'undefined' ? self : window;\n          return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonpFirebase\"];\n/******/ \twindow[\"webpackJsonpFirebase\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId]) {\n/******/ \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n/******/ \t\t\t}\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n/******/ \t\twhile(resolves.length) {\n/******/ \t\t\tresolves.shift()();\n/******/ \t\t}\n/******/ \t\tif(executeModules) {\n/******/ \t\t\tfor(i=0; i < executeModules.length; i++) {\n/******/ \t\t\t\tresult = __webpack_require__(__webpack_require__.s = executeModules[i]);\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\treturn result;\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// objects to store loaded and loading chunks\n/******/ \tvar installedChunks = {\n/******/ \t\t3: 0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId) {\n/******/ \t\tvar installedChunkData = installedChunks[chunkId];\n/******/ \t\tif(installedChunkData === 0) {\n/******/ \t\t\treturn new Promise(function(resolve) { resolve(); });\n/******/ \t\t}\n/******/\n/******/ \t\t// a Promise means \"currently loading\".\n/******/ \t\tif(installedChunkData) {\n/******/ \t\t\treturn installedChunkData[2];\n/******/ \t\t}\n/******/\n/******/ \t\t// setup Promise in chunk cache\n/******/ \t\tvar promise = new Promise(function(resolve, reject) {\n/******/ \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n/******/ \t\t});\n/******/ \t\tinstalledChunkData[2] = promise;\n/******/\n/******/ \t\t// start chunk loading\n/******/ \t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\tvar script = document.createElement('script');\n/******/ \t\tscript.type = 'text/javascript';\n/******/ \t\tscript.charset = 'utf-8';\n/******/ \t\tscript.async = true;\n/******/ \t\tscript.timeout = 120000;\n/******/\n/******/ \t\tif (__webpack_require__.nc) {\n/******/ \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n/******/ \t\t}\n/******/ \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".js\";\n/******/ \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n/******/ \t\tscript.onerror = script.onload = onScriptComplete;\n/******/ \t\tfunction onScriptComplete() {\n/******/ \t\t\t// avoid mem leaks in IE.\n/******/ \t\t\tscript.onerror = script.onload = null;\n/******/ \t\t\tclearTimeout(timeout);\n/******/ \t\t\tvar chunk = installedChunks[chunkId];\n/******/ \t\t\tif(chunk !== 0) {\n/******/ \t\t\t\tif(chunk) {\n/******/ \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n/******/ \t\t\t\t}\n/******/ \t\t\t\tinstalledChunks[chunkId] = undefined;\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t\thead.appendChild(script);\n/******/\n/******/ \t\treturn promise;\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// on error function for async loading\n/******/ \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return PromiseImpl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Deferred; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return attachDummyErrorHandler; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globalScope__ = __webpack_require__(14);\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\nvar PromiseImpl = __WEBPACK_IMPORTED_MODULE_0__utils_globalScope__[\"a\" /* globalScope */].Promise || __webpack_require__(19);\n/**\r\n * A deferred promise implementation.\r\n */\nvar Deferred = function () {\n    /** @constructor */\n    function Deferred() {\n        var self = this;\n        this.resolve = null;\n        this.reject = null;\n        this.promise = new PromiseImpl(function (resolve, reject) {\n            self.resolve = resolve;\n            self.reject = reject;\n        });\n    }\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} opt_nodeCallback\r\n     * @return {!function(?(Error), ?=)}\r\n     */\n    Deferred.prototype.wrapCallback = function (opt_nodeCallback) {\n        var self = this;\n        /**\r\n           * @param {?Error} error\r\n           * @param {?=} opt_value\r\n           */\n        function meta(error, opt_value) {\n            if (error) {\n                self.reject(error);\n            } else {\n                self.resolve(opt_value);\n            }\n            if (typeof opt_nodeCallback === 'function') {\n                attachDummyErrorHandler(self.promise);\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (opt_nodeCallback.length === 1) {\n                    opt_nodeCallback(error);\n                } else {\n                    opt_nodeCallback(error, opt_value);\n                }\n            }\n        }\n        return meta;\n    };\n    return Deferred;\n}();\n\n;\n/**\r\n * Chrome (and maybe other browsers) report an Error in the console if you reject a promise\r\n * and nobody handles the error. This is normally a good thing, but this will confuse devs who\r\n * never intended to use promises in the first place. So in some cases (in particular, if the\r\n * developer attached a callback), we should attach a dummy resolver to the promise to suppress\r\n * this error.\r\n *\r\n * Note: We can't do this all the time, since it breaks the Promise spec (though in the obscure\r\n * 3.3.3 section related to upgrading non-compliant promises).\r\n * @param {!firebase.Promise} promise\r\n */\nvar attachDummyErrorHandler = function attachDummyErrorHandler(promise) {\n    promise.catch(function () {});\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/app/firebase_app.ts\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__subscribe__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_promise__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__ = __webpack_require__(17);\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n\n\n\n\nvar contains = function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n};\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n// An array to capture listeners before the true auth functions\n// exist\nvar tokenListeners = [];\n/**\r\n * Global context object for a collection of services using\r\n * a shared authentication state.\r\n */\nvar FirebaseAppImpl = function () {\n    function FirebaseAppImpl(options, name, firebase_) {\n        this.firebase_ = firebase_;\n        this.isDeleted_ = false;\n        this.services_ = {};\n        this.name_ = name;\n        this.options_ = __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"a\" /* deepCopy */](options);\n        this.INTERNAL = {\n            'getUid': function getUid() {\n                return null;\n            },\n            'getToken': function getToken() {\n                return __WEBPACK_IMPORTED_MODULE_2__utils_promise__[\"b\" /* PromiseImpl */].resolve(null);\n            },\n            'addAuthTokenListener': function addAuthTokenListener(callback) {\n                tokenListeners.push(callback);\n                // Make sure callback is called, asynchronously, in the absence of the auth module\n                setTimeout(function () {\n                    return callback(null);\n                }, 0);\n            },\n            'removeAuthTokenListener': function removeAuthTokenListener(callback) {\n                tokenListeners = tokenListeners.filter(function (listener) {\n                    return listener !== callback;\n                });\n            }\n        };\n    }\n    Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n        get: function get() {\n            this.checkDestroyed_();\n            return this.name_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n        get: function get() {\n            this.checkDestroyed_();\n            return this.options_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FirebaseAppImpl.prototype.delete = function () {\n        var _this = this;\n        return new __WEBPACK_IMPORTED_MODULE_2__utils_promise__[\"b\" /* PromiseImpl */](function (resolve) {\n            _this.checkDestroyed_();\n            resolve();\n        }).then(function () {\n            _this.firebase_.INTERNAL.removeApp(_this.name_);\n            var services = [];\n            Object.keys(_this.services_).forEach(function (serviceKey) {\n                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {\n                    services.push(_this.services_[serviceKey][instanceKey]);\n                });\n            });\n            return __WEBPACK_IMPORTED_MODULE_2__utils_promise__[\"b\" /* PromiseImpl */].all(services.map(function (service) {\n                return service.INTERNAL.delete();\n            }));\n        }).then(function () {\n            _this.isDeleted_ = true;\n            _this.services_ = {};\n        });\n    };\n    /**\r\n     * Return a service instance associated with this app (creating it\r\n     * on demand), identified by the passed instanceIdentifier.\r\n     *\r\n     * NOTE: Currently storage is the only one that is leveraging this\r\n     * functionality. They invoke it by calling:\r\n     *\r\n     * ```javascript\r\n     * firebase.app().storage('STORAGE BUCKET ID')\r\n     * ```\r\n     *\r\n     * The service name is passed to this already\r\n     * @internal\r\n     */\n    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n        if (instanceIdentifier === void 0) {\n            instanceIdentifier = DEFAULT_ENTRY_NAME;\n        }\n        this.checkDestroyed_();\n        if (!this.services_[name]) {\n            this.services_[name] = {};\n        }\n        if (!this.services_[name][instanceIdentifier]) {\n            /**\r\n             * If a custom instance has been defined (i.e. not '[DEFAULT]')\r\n             * then we will pass that instance on, otherwise we pass `null`\r\n             */\n            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n            this.services_[name][instanceIdentifier] = service;\n        }\n        return this.services_[name][instanceIdentifier];\n    };\n    /**\r\n     * Callback function used to extend an App instance at the time\r\n     * of service instance creation.\r\n     */\n    FirebaseAppImpl.prototype.extendApp = function (props) {\n        var _this = this;\n        // Copy the object onto the FirebaseAppImpl prototype\n        __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"b\" /* deepExtend */](this, props);\n        /**\r\n         * If the app has overwritten the addAuthTokenListener stub, forward\r\n         * the active token listeners on to the true fxn.\r\n         *\r\n         * TODO: This function is required due to our current module\r\n         * structure. Once we are able to rely strictly upon a single module\r\n         * implementation, this code should be refactored and Auth should\r\n         * provide these stubs and the upgrade logic\r\n         */\n        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n            tokenListeners.forEach(function (listener) {\n                _this.INTERNAL.addAuthTokenListener(listener);\n            });\n            tokenListeners = [];\n        }\n    };\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\n    FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n        if (this.isDeleted_) {\n            error('app-deleted', { 'name': this.name_ });\n        }\n    };\n    return FirebaseAppImpl;\n}();\n;\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\nFirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log(\"dc\");\n/**\r\n * Return a firebase namespace object.\r\n *\r\n * In production, this will be called exactly once and the result\r\n * assigned to the 'firebase' global.  It may be called multiple times\r\n * in unit tests.\r\n */\nfunction createFirebaseNamespace() {\n    var apps_ = {};\n    var factories = {};\n    var appHooks = {};\n    // A namespace is a plain JavaScript Object.\n    var namespace = {\n        // Hack to prevent Babel from modifying the object returned\n        // as the firebase namespace.\n        '__esModule': true,\n        'initializeApp': initializeApp,\n        'app': app,\n        'apps': null,\n        'Promise': __WEBPACK_IMPORTED_MODULE_2__utils_promise__[\"b\" /* PromiseImpl */],\n        'SDK_VERSION': '4.1.4',\n        'INTERNAL': {\n            'registerService': registerService,\n            'createFirebaseNamespace': createFirebaseNamespace,\n            'extendNamespace': extendNamespace,\n            'createSubscribe': __WEBPACK_IMPORTED_MODULE_0__subscribe__[\"a\" /* createSubscribe */],\n            'ErrorFactory': __WEBPACK_IMPORTED_MODULE_1__errors__[\"a\" /* ErrorFactory */],\n            'removeApp': removeApp,\n            'factories': factories,\n            'useAsService': useAsService,\n            'Promise': __WEBPACK_IMPORTED_MODULE_2__utils_promise__[\"b\" /* PromiseImpl */],\n            'deepExtend': __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"b\" /* deepExtend */]\n        }\n    };\n    // Inject a circular default export to allow Babel users who were previously\n    // using:\n    //\n    //   import firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase').default;\n    //\n    // instead of\n    //\n    //   import * as firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase');\n    __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"c\" /* patchProperty */](namespace, 'default', namespace);\n    // firebase.apps is a read-only getter.\n    Object.defineProperty(namespace, 'apps', {\n        get: getApps\n    });\n    /**\r\n     * Called by App.delete() - but before any services associated with the App\r\n     * are deleted.\r\n     */\n    function removeApp(name) {\n        var app = apps_[name];\n        callAppHooks(app, 'delete');\n        delete apps_[name];\n    }\n    /**\r\n     * Get the App object for a given name (or DEFAULT).\r\n     */\n    function app(name) {\n        name = name || DEFAULT_ENTRY_NAME;\n        if (!contains(apps_, name)) {\n            error('no-app', { 'name': name });\n        }\n        return apps_[name];\n    }\n    __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"c\" /* patchProperty */](app, 'App', FirebaseAppImpl);\n    /**\r\n     * Create a new App instance (name must be unique).\r\n     */\n    function initializeApp(options, name) {\n        if (name === undefined) {\n            name = DEFAULT_ENTRY_NAME;\n        } else {\n            if (typeof name !== 'string' || name === '') {\n                error('bad-app-name', { 'name': name + '' });\n            }\n        }\n        if (contains(apps_, name)) {\n            error('duplicate-app', { 'name': name });\n        }\n        var app = new FirebaseAppImpl(options, name, namespace);\n        apps_[name] = app;\n        callAppHooks(app, 'create');\n        return app;\n    }\n    /*\r\n     * Return an array of all the non-deleted FirebaseApps.\r\n     */\n    function getApps() {\n        // Make a copy so caller cannot mutate the apps list.\n        return Object.keys(apps_).map(function (name) {\n            return apps_[name];\n        });\n    }\n    /*\r\n     * Register a Firebase Service.\r\n     *\r\n     * firebase.INTERNAL.registerService()\r\n     *\r\n     * TODO: Implement serviceProperties.\r\n     */\n    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n        // Cannot re-register a service that already exists\n        if (factories[name]) {\n            error('duplicate-service', { 'name': name });\n        }\n        // Capture the service factory for later service instantiation\n        factories[name] = createService;\n        // Capture the appHook, if passed\n        if (appHook) {\n            appHooks[name] = appHook;\n            // Run the **new** app hook on all existing apps\n            getApps().forEach(function (app) {\n                appHook('create', app);\n            });\n        }\n        // The Service namespace is an accessor function ...\n        var serviceNamespace = function serviceNamespace(appArg) {\n            if (appArg === void 0) {\n                appArg = app();\n            }\n            if (typeof appArg[name] !== 'function') {\n                // Invalid argument.\n                // This happens in the following case: firebase.storage('gs:/')\n                error('invalid-app-argument', { 'name': name });\n            }\n            // Forward service instance lookup to the FirebaseApp.\n            return appArg[name]();\n        };\n        // ... and a container for service-level properties.\n        if (serviceProperties !== undefined) {\n            __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"b\" /* deepExtend */](serviceNamespace, serviceProperties);\n        }\n        // Monkey-patch the serviceNamespace onto the firebase namespace\n        namespace[name] = serviceNamespace;\n        // Patch the FirebaseAppImpl prototype\n        FirebaseAppImpl.prototype[name] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var serviceFxn = this._getService.bind(this, name);\n            return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n        };\n        return serviceNamespace;\n    }\n    /**\r\n     * Patch the top-level firebase namespace with additional properties.\r\n     *\r\n     * firebase.INTERNAL.extendNamespace()\r\n     */\n    function extendNamespace(props) {\n        __WEBPACK_IMPORTED_MODULE_3__utils_deep_copy__[\"b\" /* deepExtend */](namespace, props);\n    }\n    function callAppHooks(app, eventName) {\n        Object.keys(factories).forEach(function (serviceName) {\n            // Ignore virtual services\n            var factoryName = useAsService(app, serviceName);\n            if (factoryName === null) {\n                return;\n            }\n            if (appHooks[factoryName]) {\n                appHooks[factoryName](eventName, app);\n            }\n        });\n    }\n    // Map the requested service to a registered service name\n    // (used to map auth to serverAuth service when needed).\n    function useAsService(app, name) {\n        if (name === 'serverAuth') {\n            return null;\n        }\n        var useService = name;\n        var options = app.options;\n        return useService;\n    }\n    return namespace;\n}\nfunction error(code, args) {\n    throw appErrors.create(code, args);\n}\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nvar errors = {\n    'no-app': 'No Firebase App \\'{$name}\\' has been created - ' + 'call Firebase App.initializeApp()',\n    'bad-app-name': 'Illegal App name: \\'{$name}',\n    'duplicate-app': 'Firebase App named \\'{$name}\\' already exists',\n    'app-deleted': 'Firebase App named \\'{$name}\\' already deleted',\n    'duplicate-service': 'Firebase service named \\'{$name}\\' already registered',\n    'sa-not-supported': 'Initializing the Firebase SDK with a service ' + 'account is only allowed in a Node.js environment. On client ' + 'devices, you should instead initialize the SDK with an api key and ' + 'auth domain',\n    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.'\n};\nvar appErrors = new __WEBPACK_IMPORTED_MODULE_1__errors__[\"a\" /* ErrorFactory */]('app', 'Firebase', errors);\n// CONCATENATED MODULE: ./src/app.ts\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n// Import the createFirebaseNamespace function\n\n// Export a single instance of firebase app\nvar firebase = createFirebaseNamespace();\n/* harmony default export */ __webpack_exports__[\"default\"] = (firebase);\n\n/***/ }),\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export patchCapture */\n/* unused harmony export FirebaseError */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ErrorFactory; });\nvar ERROR_NAME = 'FirebaseError';\nvar captureStackTrace = Error.captureStackTrace;\n// Export for faking in tests\nfunction patchCapture(captureFake) {\n    var result = captureStackTrace;\n    captureStackTrace = captureFake;\n    return result;\n}\nvar FirebaseError = function () {\n    function FirebaseError(code, message) {\n        this.code = code;\n        this.message = message;\n        var stack;\n        // We want the stack value, if implemented by Error\n        if (captureStackTrace) {\n            // Patches this.stack, omitted calls above ErrorFactory#create\n            captureStackTrace(this, ErrorFactory.prototype.create);\n        } else {\n            var err_1 = Error.apply(this, arguments);\n            this.name = ERROR_NAME;\n            // Make non-enumerable getter for the property.\n            Object.defineProperty(this, 'stack', {\n                get: function get() {\n                    return err_1.stack;\n                }\n            });\n        }\n    }\n    return FirebaseError;\n}();\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype);\nFirebaseError.prototype.constructor = FirebaseError;\nFirebaseError.prototype.name = ERROR_NAME;\nvar ErrorFactory = function () {\n    function ErrorFactory(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n        // Matches {$name}, by default.\n        this.pattern = /\\{\\$([^}]+)}/g;\n        // empty\n    }\n    ErrorFactory.prototype.create = function (code, data) {\n        if (data === undefined) {\n            data = {};\n        }\n        var template = this.errors[code];\n        var fullCode = this.service + '/' + code;\n        var message;\n        if (template === undefined) {\n            message = \"Error\";\n        } else {\n            message = template.replace(this.pattern, function (match, key) {\n                var value = data[key];\n                return value !== undefined ? value.toString() : '<' + key + '?>';\n            });\n        }\n        // Service: Error message (service/code).\n        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n        var err = new FirebaseError(fullCode, message);\n        // Populate the Error object with message parts for programmatic\n        // accesses (e.g., e.file).\n        for (var prop in data) {\n            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n                continue;\n            }\n            err[prop] = data[prop];\n        }\n        return err;\n    };\n    return ErrorFactory;\n}();\n\n\n/***/ }),\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = createSubscribe;\n/* unused harmony export async */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_promise__ = __webpack_require__(4);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\nfunction createSubscribe(executor, onNoObservers) {\n    var proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\nvar ObserverProxy = function () {\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\n    function ObserverProxy(executor, onNoObservers) {\n        var _this = this;\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = __WEBPACK_IMPORTED_MODULE_0__utils_promise__[\"b\" /* PromiseImpl */].resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task.then(function () {\n            executor(_this);\n        }).catch(function (e) {\n            _this.error(e);\n        });\n    }\n    ObserverProxy.prototype.next = function (value) {\n        this.forEachObserver(function (observer) {\n            observer.next(value);\n        });\n    };\n    ObserverProxy.prototype.error = function (error) {\n        this.forEachObserver(function (observer) {\n            observer.error(error);\n        });\n        this.close(error);\n    };\n    ObserverProxy.prototype.complete = function () {\n        this.forEachObserver(function (observer) {\n            observer.complete();\n        });\n        this.close();\n    };\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\n    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n        var _this = this;\n        var observer;\n        if (nextOrObserver === undefined && error === undefined && complete === undefined) {\n            throw new Error(\"Missing Observer.\");\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n            observer = nextOrObserver;\n        } else {\n            observer = {\n                next: nextOrObserver,\n                error: error,\n                complete: complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        var unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            this.task.then(function () {\n                try {\n                    if (_this.finalError) {\n                        observer.error(_this.finalError);\n                    } else {\n                        observer.complete();\n                    }\n                } catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    };\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    ObserverProxy.prototype.unsubscribeOne = function (i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    };\n    ObserverProxy.prototype.forEachObserver = function (fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (var i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    };\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    ObserverProxy.prototype.sendOne = function (i, fn) {\n        var _this = this;\n        // Execute the callback asynchronously\n        this.task.then(function () {\n            if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n                try {\n                    fn(_this.observers[i]);\n                } catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== \"undefined\" && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    };\n    ObserverProxy.prototype.close = function (err) {\n        var _this = this;\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        this.task.then(function () {\n            _this.observers = undefined;\n            _this.onNoObservers = undefined;\n        });\n    };\n    return ObserverProxy;\n}();\n/** Turn synchronous function into one called asynchronously. */\nfunction async(fn, onError) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        __WEBPACK_IMPORTED_MODULE_0__utils_promise__[\"b\" /* PromiseImpl */].resolve(true).then(function () {\n            fn.apply(void 0, args);\n        }).catch(function (error) {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\nfunction implementsAnyMethods(obj, methods) {\n    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {\n        return false;\n    }\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return globalScope; });\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\nvar scope;\nif (typeof global !== 'undefined') {\n    scope = global;\n} else if (typeof self !== 'undefined') {\n    scope = self;\n} else {\n    try {\n        scope = Function('return this')();\n    } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n}\nvar globalScope = scope;\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(15)))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = deepCopy;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = deepExtend;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = patchProperty;\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\n/**\r\n* Copyright 2017 Google Inc.\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the \"License\");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an \"AS IS\" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n*/function deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            var dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (var prop in source) {\n        if (!source.hasOwnProperty(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\n// TODO: Really needed (for JSCompiler type checking)?\nfunction patchProperty(obj, prop, value) {\n    obj[prop] = value;\n}\n\n/***/ }),\n/* 18 */,\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n  \n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new (this.constructor)(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    var args = Array.prototype.slice.call(arr);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||\n    function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n  \n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).setImmediate))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(21);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(16)))\n\n/***/ })\n/******/ ]);\n          })().default;\n\n\n// WEBPACK FOOTER //\n// firebase-app.js"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonpFirebase\"];\n \twindow[\"webpackJsonpFirebase\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n \t\tif(executeModules) {\n \t\t\tfor(i=0; i < executeModules.length; i++) {\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = executeModules[i]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t3: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData === 0) {\n \t\t\treturn new Promise(function(resolve) { resolve(); });\n \t\t}\n\n \t\t// a Promise means \"currently loading\".\n \t\tif(installedChunkData) {\n \t\t\treturn installedChunkData[2];\n \t\t}\n\n \t\t// setup Promise in chunk cache\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunkData[2] = promise;\n\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) {\n \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\t}\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n \t\thead.appendChild(script);\n\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8ab15b975f62acbe3906","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { globalScope } from '../utils/globalScope';\n\nexport const PromiseImpl = globalScope.Promise || require('promise-polyfill');\n\n/**\n * A deferred promise implementation.\n */\nexport class Deferred {\n  resolve;\n  reject;\n  promise;\n  \n  /** @constructor */\n  constructor() {\n    var self = this;\n    this.resolve = null;\n    this.reject = null;\n    this.promise = new PromiseImpl(function(resolve, reject) {\n      self.resolve = resolve;\n      self.reject = reject;\n    });\n  }\n\n  /**\n   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\n   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n   * and returns a node-style callback which will resolve or reject the Deferred's promise.\n   * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} opt_nodeCallback\n   * @return {!function(?(Error), ?=)}\n   */\n  wrapCallback(opt_nodeCallback?) {\n    var self = this;\n    /**\n       * @param {?Error} error\n       * @param {?=} opt_value\n       */\n    function meta(error, opt_value) {\n      if (error) {\n        self.reject(error);\n      } else {\n        self.resolve(opt_value);\n      }\n      if (typeof opt_nodeCallback === 'function') {\n        attachDummyErrorHandler(self.promise);\n\n        // Some of our callbacks don't expect a value and our own tests\n        // assert that the parameter length is 1\n        if (opt_nodeCallback.length === 1) {\n          opt_nodeCallback(error);\n        } else {\n          opt_nodeCallback(error, opt_value);\n        }\n      }\n    }\n    return meta;\n  }\n};\n\n\n/**\n * Chrome (and maybe other browsers) report an Error in the console if you reject a promise\n * and nobody handles the error. This is normally a good thing, but this will confuse devs who\n * never intended to use promises in the first place. So in some cases (in particular, if the\n * developer attached a callback), we should attach a dummy resolver to the promise to suppress\n * this error.\n *\n * Note: We can't do this all the time, since it breaks the Promise spec (though in the obscure\n * 3.3.3 section related to upgrading non-compliant promises).\n * @param {!firebase.Promise} promise\n */\nexport const attachDummyErrorHandler = function(promise) {\n  promise.catch(() => {});\n};\n\n\n// WEBPACK FOOTER //\n// ./src/utils/promise.ts","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nimport { \n  createSubscribe,\n  Observer,\n  Subscribe\n} from './subscribe';\nimport { \n  ErrorFactory,\n  FirebaseError\n} from './errors';\nimport { PromiseImpl } from '../utils/promise';\nimport { patchProperty, deepCopy, deepExtend } from '../utils/deep_copy';\n\nexport interface FirebaseAuthTokenData { accessToken: string; }\n\nexport interface FirebaseAppInternals {\n  getToken(refreshToken?: boolean): Promise< FirebaseAuthTokenData | null >;\n  getUid(): string|null;\n  addAuthTokenListener(fn: (token: string|null) => void): void;\n  removeAuthTokenListener(fn: (token: string|null) => void): void;\n}\n\nexport type FirebaseOptions = { \n  apiKey?: string,\n  authDomain?: string,\n  databaseURL?: string,\n  projectId?: string,\n  storageBucket?: string,\n  messagingSenderId?: string\n  [name: string]: any \n};\n\n// An instance of the firebase.App\nexport interface FirebaseApp {\n  /**\n   * The (read-only) name (identifier) for this App. '[DEFAULT]' is the default\n   * App.\n   */\n  name: string;\n\n  /**\n   * The (read-only) configuration options from the app initialization.\n   */\n  options: FirebaseOptions;\n\n  /**\n   * Make the given App unusable and free resources.\n   */\n  delete(): Promise<void>;\n\n  INTERNAL: FirebaseAppInternals;\n}\n\nexport interface FirebaseServiceInternals {\n  /**\n   * Delete the service and free it's resources - called from\n   * app.delete().\n   */\n  delete(): Promise<void>;\n}\n\n// Services are exposed through instances - each of which is associated with a\n// FirebaseApp.\nexport interface FirebaseService {\n  app: FirebaseApp;\n  INTERNAL?: FirebaseServiceInternals;\n}\n\nexport type AppHook = (event: string, app: FirebaseApp) => void;\n\n/**\n * Firebase Services create instances given a Firebase App instance and can\n * optionally add properties and methods to each FirebaseApp via the extendApp()\n * function.\n */\nexport interface FirebaseServiceFactory {\n  (app: FirebaseApp, extendApp?: (props: {[prop: string]: any}) => void,\n   instanceString?: string): FirebaseService;\n}\n\n/**\n * All ServiceNamespaces extend from FirebaseServiceNamespace\n */\nexport interface FirebaseServiceNamespace <T extends FirebaseService> {\n  (app?: FirebaseApp): T;\n}\n\nexport interface FirebaseErrorFactory<T> {\n  create(code: T, data?: {[prop: string]: any}): FirebaseError;\n}\n\nexport interface FirebaseErrorFactoryClass {\n  new (service: string, serviceName: string, errors: {[code: string]: string}): FirebaseErrorFactory<any>;\n}\n\nexport interface FirebaseNamespace {\n  /**\n   * Create (and intialize) a FirebaseApp.\n   *\n   * @param options Options to configure the services use in the App.\n   * @param name The optional name of the app to initialize ('[DEFAULT]' if\n   *   none)\n   */\n  initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;\n\n  app: {\n    /**\n     * Retrieve an instance of a FirebaseApp.\n     *\n     * Usage: firebase.app()\n     *\n     * @param name The optional name of the app to return ('[DEFAULT]' if none)\n     */\n    (name?: string): FirebaseApp;\n\n    /**\n     * For testing FirebaseApp instances:\n     *   app() instanceof firebase.app.App\n     * DO NOT call this constuctor directly (use firebase.app() instead).\n     */\n    App: Function;\n  };\n\n  /**\n   * A (read-only) array of all the initialized Apps.\n   */\n  apps: FirebaseApp[];\n\n  // Inherit the type information of our exported Promise implementation from\n  // es6-promises.\n  Promise: typeof Promise;\n\n  // The current SDK version ('4.1.4').\n  SDK_VERSION: string;\n\n  // TODO: Migrate to firebase-app-internal.d.ts\n  INTERNAL: {\n    /**\n     * Internal API to register a Firebase Service into the firebase namespace.\n     *\n     * Each service will create a child namespace (firease.name) which acts as\n     * both a namespace for service specific properties, and also as a service\n     * accessor function (firebase.name() or firebase.name(app)).\n     *\n     * @param name The Firebase Service being registered.\n     * @param createService Factory function to create a service instance.\n     * @param serviceProperties Properties to copy to the service's namespace.\n     * @param appHook All appHooks called before intializeApp returns to caller.\n     * @param allowMultipleInstances Whether the registered service supports\n     *   multiple instances per app. If not specified, the default is false.\n     */\n    registerService(\n        name: string, \n        createService: FirebaseServiceFactory,\n        serviceProperties?: {[prop: string]: any}, \n        appHook?: AppHook,\n        allowMultipleInstances?: boolean): FirebaseServiceNamespace<FirebaseService>;\n\n    /**\n     * Just used for testing to start from a fresh namespace.\n     */\n    createFirebaseNamespace(): FirebaseNamespace;\n\n    /**\n     * Internal API to install properties on the top-level firebase namespace.\n     * @prop props The top level properties of this object are copied to the\n     *   namespace.\n     */\n    extendNamespace(props: {[prop: string]: any}): void;\n\n    /**\n     * Create a Subscribe function.  A proxy Observer is created so that\n     * events can be sent to single Observer to be fanned out automatically.\n     */\n    createSubscribe<T>(\n        executor: (observer: Observer<T>) => void,\n        onNoObservers?: (observer: Observer<T>) => void): Subscribe<T>;\n\n    /**\n     * Utility exposed for internal testing.\n     */\n    deepExtend(target: any, source: any): any;\n\n    /**\n     * Internal API to remove an app from the list of registered apps.\n     */\n    removeApp(name: string): void;\n\n    /**\n     * Service factories for each registered service.\n     */\n    factories: {[name: string]: FirebaseServiceFactory};\n\n    /*\n     * Convert service name to factory name to use.\n     */\n    useAsService(app: FirebaseApp, serviceName: string): string | null;\n\n    /**\n     * Use to construct all thrown FirebaseError's.\n     */\n    ErrorFactory: FirebaseErrorFactoryClass;\n  }\n}\n\nconst contains = function(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n// An array to capture listeners before the true auth functions\n// exist\nlet tokenListeners = [];\n\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nclass FirebaseAppImpl implements FirebaseApp {\n  private options_: FirebaseOptions;\n  private name_: string;\n  private isDeleted_ = false;\n  private services_: {\n    [name: string]: {\n      [serviceName: string]: FirebaseService\n    }\n  } = {};\n\n  public INTERNAL;\n\n  constructor(options: FirebaseOptions,\n              name: string,\n              private firebase_: FirebaseNamespace) {\n    this.name_ = name;\n    this.options_ = deepCopy<FirebaseOptions>(options);\n    this.INTERNAL = {\n      'getUid': () => null,\n      'getToken': () => PromiseImpl.resolve(null),\n      'addAuthTokenListener': (callback: (token: string|null) => void) => {\n        tokenListeners.push(callback);\n        // Make sure callback is called, asynchronously, in the absence of the auth module\n        setTimeout(() => callback(null), 0);\n      },\n      'removeAuthTokenListener': (callback) => {\n        tokenListeners = tokenListeners.filter(listener => listener !== callback);\n      },\n    };\n  }\n\n  get name(): string {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n\n  get options(): FirebaseOptions {\n    this.checkDestroyed_();\n    return this.options_;\n  }\n\n  delete(): Promise<void> {\n    return new PromiseImpl((resolve) => {\n      this.checkDestroyed_();\n      resolve();\n    })\n      .then(() => {\n        this.firebase_.INTERNAL.removeApp(this.name_);\n        let services: FirebaseService[] = [];\n        Object.keys(this.services_).forEach((serviceKey) => {\n          Object.keys(this.services_[serviceKey]).forEach((instanceKey) => {\n            services.push(this.services_[serviceKey][instanceKey]);\n          });\n        });\n        return PromiseImpl.all(services.map((service) => {\n          return service.INTERNAL!.delete();\n        }));\n      })\n      .then((): void => {\n        this.isDeleted_ = true;\n        this.services_ = {};\n      });\n  }\n\n  /**\n   * Return a service instance associated with this app (creating it\n   * on demand), identified by the passed instanceIdentifier.\n   * \n   * NOTE: Currently storage is the only one that is leveraging this\n   * functionality. They invoke it by calling:\n   * \n   * ```javascript\n   * firebase.app().storage('STORAGE BUCKET ID')\n   * ```\n   * \n   * The service name is passed to this already\n   * @internal\n   */\n  _getService(name: string, instanceIdentifier: string = DEFAULT_ENTRY_NAME): FirebaseService {\n    this.checkDestroyed_();\n\n    if (!this.services_[name]) {\n      this.services_[name] = {};\n    }\n\n    if (!this.services_[name][instanceIdentifier]) {\n      /**\n       * If a custom instance has been defined (i.e. not '[DEFAULT]')\n       * then we will pass that instance on, otherwise we pass `null`\n       */\n      const instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;\n      const service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n      this.services_[name][instanceIdentifier] = service;\n    }\n\n    return this.services_[name][instanceIdentifier];\n  }\n\n  /**\n   * Callback function used to extend an App instance at the time\n   * of service instance creation.\n   */\n  private extendApp(props: {[name: string]: any}): void {\n    // Copy the object onto the FirebaseAppImpl prototype\n    deepExtend(this, props);\n\n    /**\n     * If the app has overwritten the addAuthTokenListener stub, forward\n     * the active token listeners on to the true fxn.\n     * \n     * TODO: This function is required due to our current module\n     * structure. Once we are able to rely strictly upon a single module\n     * implementation, this code should be refactored and Auth should \n     * provide these stubs and the upgrade logic\n     */\n    if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n      tokenListeners.forEach(listener => {\n        this.INTERNAL.addAuthTokenListener(listener);\n      });\n      tokenListeners = [];\n    }\n  }\n\n  /**\n   * This function will throw an Error if the App has already been deleted -\n   * use before performing API actions on the App.\n   */\n  private checkDestroyed_(): void {\n    if (this.isDeleted_) {\n      error('app-deleted', {'name': this.name_});\n    }\n  }\n};\n\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\nFirebaseAppImpl.prototype.name &&\n  FirebaseAppImpl.prototype.options ||\n  FirebaseAppImpl.prototype.delete ||\n  console.log(\"dc\");\n\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nexport function createFirebaseNamespace(): FirebaseNamespace {\n  let apps_: {[name: string]: FirebaseApp} = {};\n  let factories: {[service: string]: FirebaseServiceFactory} = {};\n  let appHooks: {[service: string]: AppHook} = {};\n\n  // A namespace is a plain JavaScript Object.\n  let namespace = {\n    // Hack to prevent Babel from modifying the object returned\n    // as the firebase namespace.\n    '__esModule': true,\n    'initializeApp': initializeApp,\n    'app': app as any,\n    'apps': null as any,\n    'Promise': PromiseImpl,\n    'SDK_VERSION': '4.1.4',\n    'INTERNAL': {\n      'registerService': registerService,\n      'createFirebaseNamespace': createFirebaseNamespace,\n      'extendNamespace': extendNamespace,\n      'createSubscribe': createSubscribe,\n      'ErrorFactory': ErrorFactory,\n      'removeApp': removeApp,\n      'factories': factories,\n      'useAsService': useAsService,\n      'Promise': PromiseImpl,\n      'deepExtend': deepExtend,\n    }\n  };\n\n  // Inject a circular default export to allow Babel users who were previously\n  // using:\n  //\n  //   import firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase').default;\n  //\n  // instead of\n  //\n  //   import * as firebase from 'firebase';\n  //   which becomes: var firebase = require('firebase');\n  patchProperty(namespace, 'default', namespace);\n\n  // firebase.apps is a read-only getter.\n  Object.defineProperty(namespace, 'apps', {\n    get: getApps\n  });\n\n  /**\n   * Called by App.delete() - but before any services associated with the App\n   * are deleted.\n   */\n  function removeApp(name: string): void {\n    let app = apps_[name];\n    callAppHooks(app, 'delete');\n    delete apps_[name];\n  }\n\n  /**\n   * Get the App object for a given name (or DEFAULT).\n   */\n  function app(name?: string): FirebaseApp {\n    name = name || DEFAULT_ENTRY_NAME;\n    if (!contains(apps_, name)) {\n      error('no-app', {'name': name});\n    }\n    return apps_[name];\n  }\n\n  patchProperty(app, 'App', FirebaseAppImpl);\n\n  /**\n   * Create a new App instance (name must be unique).\n   */\n  function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp {\n    if (name === undefined) {\n      name = DEFAULT_ENTRY_NAME;\n    } else {\n      if (typeof name !== 'string' || name === '') {\n        error('bad-app-name', {'name': name + ''});\n      }\n    }\n    if (contains(apps_, name) ) {\n      error('duplicate-app', {'name': name});\n    }\n\n    let app = new FirebaseAppImpl(options, name!, namespace as FirebaseNamespace);\n\n    apps_[name!] = app;\n    callAppHooks(app, 'create');\n\n    return app;\n  }\n\n  /*\n   * Return an array of all the non-deleted FirebaseApps.\n   */\n  function getApps(): FirebaseApp[] {\n    // Make a copy so caller cannot mutate the apps list.\n    return Object.keys(apps_).map((name) => apps_[name]);\n  }\n\n  /*\n   * Register a Firebase Service.\n   *\n   * firebase.INTERNAL.registerService()\n   *\n   * TODO: Implement serviceProperties.\n   */\n  function registerService(\n      name: string, \n      createService: FirebaseServiceFactory,\n      serviceProperties?: {[prop: string]: any}, \n      appHook?: AppHook,\n      allowMultipleInstances?: boolean):\n      FirebaseServiceNamespace<FirebaseService> {\n    // Cannot re-register a service that already exists\n    if (factories[name]) {\n      error('duplicate-service', {'name': name});\n    }\n\n    // Capture the service factory for later service instantiation\n    factories[name] = createService;\n    \n    // Capture the appHook, if passed\n    if (appHook) {\n      appHooks[name] = appHook;\n\n      // Run the **new** app hook on all existing apps\n      getApps().forEach(app => {\n        appHook('create', app);\n      });\n    }\n\n    // The Service namespace is an accessor function ...\n    const serviceNamespace = (appArg: FirebaseApp = app()) => {\n      if (typeof(appArg as any)[name] !== 'function') {\n        // Invalid argument.\n        // This happens in the following case: firebase.storage('gs:/')\n        error('invalid-app-argument', {'name': name});\n      }\n\n      // Forward service instance lookup to the FirebaseApp.\n      return (appArg as any)[name]();\n    };\n\n    // ... and a container for service-level properties.\n    if (serviceProperties !== undefined) {\n      deepExtend(serviceNamespace, serviceProperties);\n    }\n\n    // Monkey-patch the serviceNamespace onto the firebase namespace\n    (namespace as any)[name] = serviceNamespace;\n\n    // Patch the FirebaseAppImpl prototype\n    FirebaseAppImpl.prototype[name] = function(...args) {\n      const serviceFxn = this._getService.bind(this, name);\n      return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n    }\n\n    return serviceNamespace;\n  }\n\n  /**\n   * Patch the top-level firebase namespace with additional properties.\n   *\n   * firebase.INTERNAL.extendNamespace()\n   */\n  function extendNamespace(props: {[prop: string]: any}): void {\n    deepExtend(namespace, props);\n  }\n\n  function callAppHooks(app: FirebaseApp, eventName: string) {\n    Object.keys(factories).forEach((serviceName) => {\n      // Ignore virtual services\n      let factoryName = useAsService(app, serviceName);\n      if (factoryName === null) {\n        return;\n      }\n\n      if (appHooks[factoryName]) {\n        appHooks[factoryName](eventName, app);\n      }\n    });\n  }\n\n  // Map the requested service to a registered service name\n  // (used to map auth to serverAuth service when needed).\n  function useAsService(app: FirebaseApp, name: string): string | null {\n    if (name === 'serverAuth') {\n      return null;\n    }\n\n    let useService = name;\n    let options = app.options;\n\n    return useService;\n  }\n\n  return (namespace as any) as FirebaseNamespace;\n}\n\ntype AppError = 'no-app'|'bad-app-name'|'duplicate-app'|'app-deleted'|\n    'duplicate-service'|'sa-not-supported'|'invalid-app-argument';\n\nfunction error(code: AppError, args?: {[name: string]: any}) {\n  throw appErrors.create(code, args);\n}\n\n// TypeScript does not support non-string indexes!\n// let errors: {[code: AppError: string} = {\nlet errors: {[code: string]: string} = {\n  'no-app': 'No Firebase App \\'{$name}\\' has been created - ' +\n      'call Firebase App.initializeApp()',\n  'bad-app-name': 'Illegal App name: \\'{$name}',\n  'duplicate-app': 'Firebase App named \\'{$name}\\' already exists',\n  'app-deleted': 'Firebase App named \\'{$name}\\' already deleted',\n  'duplicate-service': 'Firebase service named \\'{$name}\\' already registered',\n  'sa-not-supported': 'Initializing the Firebase SDK with a service ' +\n      'account is only allowed in a Node.js environment. On client ' +\n      'devices, you should instead initialize the SDK with an api key and ' +\n      'auth domain',\n  'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +\n      'Firebase App instance.'\n};\n\nlet appErrors = new ErrorFactory<AppError>('app', 'Firebase', errors);\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/firebase_app.ts","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n// Import the createFirebaseNamespace function\nimport { \n  createFirebaseNamespace,\n  FirebaseNamespace\n} from './app/firebase_app';\n\n// Export a single instance of firebase app\nconst firebase: FirebaseNamespace = createFirebaseNamespace();\n\nexport default firebase;\n\n\n// WEBPACK FOOTER //\n// ./src/app.ts","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = {[code: string]: string};\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void =\n  (Error as any).captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string,\n\n  // Developer-friendly error message.\n  message: string,\n\n  // Always 'FirebaseError'\n  name: string,\n\n  // Where available - stack backtrace in a string\n  stack: string,\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string,\n              public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g\n\n  constructor(private service: string,\n              private serviceName: string,\n              private errors: ErrorList<T>) {\n    // empty\n  }\n\n  create(code: T, data?: {[prop: string]: StringLike}): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[(code as string)];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = \"Error\";\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString()\n          : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/app/errors.ts","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<T> {\n  // Called once for each value in a stream of values.\n  next: NextFn<T>;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error: ErrorFn;\n\n  // No events will be sent to next() once complete() is called.\n  complete: CompleteFn;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nimport { PromiseImpl } from '../utils/promise';\n\nexport type Executor<T> = (observer: Observer<T>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(executor: Executor<T>,\n                                   onNoObservers?: Executor<T>)\n: Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T>{\n  private observers: Array<Observer<T>>|undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T>|undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = PromiseImpl.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch((e) => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(nextOrObserver: PartialObserver<T> | Function,\n            error?: ErrorFn,\n            complete?: CompleteFn)\n  : Unsubscribe {\n    let observer: Observer<T>;\n\n    if (nextOrObserver === undefined && error === undefined &&\n        complete === undefined) {\n      throw new Error(\"Missing Observer.\");\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete,\n      } as Observer<T>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n        return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== \"undefined\" && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    PromiseImpl.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof(obj) !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n\n\n// WEBPACK FOOTER //\n// ./src/app/subscribe.ts","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nlet scope;\n\nif (typeof global !== 'undefined') {\n    scope = global;\n} else if (typeof self !== 'undefined') {\n    scope = self;\n} else {\n    try {\n        scope = Function('return this')();\n    } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n}\n\nexport const globalScope = scope;\n\n\n// WEBPACK FOOTER //\n// ./src/utils/globalScope.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 15\n// module chunks = 3","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 16\n// module chunks = 3","/**\n* Copyright 2017 Google Inc.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nexport function deepCopy<T>(value: T): T {\n  return deepExtend(undefined, value);\n}\n\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n */\nexport function deepExtend(target: any, source: any): any {\n  if (!(source instanceof Object)) {\n    return source;\n  }\n\n  switch (source.constructor) {\n  case Date:\n    // Treat Dates like scalars; if the target date object had any child\n    // properties - they will be lost!\n    let dateValue = (source as any) as Date;\n    return new Date(dateValue.getTime());\n\n  case Object:\n    if (target === undefined) {\n      target = {};\n    }\n    break;\n\n  case Array:\n    // Always copy the array source and overwrite the target.\n    target = [];\n    break;\n\n  default:\n    // Not a plain Object - treat it as a scalar.\n    return source;\n  }\n\n  for (let prop in source) {\n    if (!source.hasOwnProperty(prop)) {\n      continue;\n    }\n    target[prop] = deepExtend(target[prop], source[prop]);\n  }\n\n  return target;\n}\n\n// TODO: Really needed (for JSCompiler type checking)?\nexport function patchProperty(obj: any, prop: string, value: any) {\n  obj[prop] = value;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/deep_copy.ts","(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {}\n  \n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    Promise._immediateFn(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      Promise._immediateFn(function() {\n        if (!self._handled) {\n          Promise._unhandledRejectionFn(self._value);\n        }\n      });\n    }\n\n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new (this.constructor)(noop);\n\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function (arr) {\n    var args = Array.prototype.slice.call(arr);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  // Use polyfill for setImmediate for performance gains\n  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||\n    function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n\n  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n    if (typeof console !== 'undefined' && console) {\n      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n    }\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @deprecated\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    Promise._immediateFn = fn;\n  };\n\n  /**\n   * Change the function to execute on unhandled rejection\n   * @param {function} fn Function to execute on unhandled rejection\n   * @deprecated\n   */\n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    Promise._unhandledRejectionFn = fn;\n  };\n  \n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise-polyfill/promise.js\n// module id = 19\n// module chunks = 3","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/timers-browserify/main.js\n// module id = 20\n// module chunks = 3","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/setimmediate/setImmediate.js\n// module id = 21\n// module chunks = 3"],"sourceRoot":""}